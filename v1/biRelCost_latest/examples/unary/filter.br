Lam. fix filter(f). Lam. lam l. caseL l of 
   nil => pack nil
 | h::tl => let r' = filter f [] tl in
   	    let b = (f h) in
            unpack r' as r'' in
	    clet r'' as r in if b then pack (h::r) else pack r

<= [max, 0] : forall k [max, 0] :: cost.
 (int [max, k] -> bool) [max,0]-> forall i [max, 0] :: size. 
 (list[i] int) [max, (k+3) * i] ->
exists j ::size. { j <= i } (list[j] int)
