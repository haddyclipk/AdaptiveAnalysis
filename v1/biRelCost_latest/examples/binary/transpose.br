let map = {contra : unitR => forall n; alpha. (list [n, alpha] U int) => list [n, alpha] (list[1,1] U int) , 0} in

let mapap = {contra: unitR => forall n; m; alpha; beta. (((U int) X list[m,beta]
U int) => list[m+1,beta+1] U int) => (list [n, alpha] ((U int) X (list[m,beta]
U int))) => list [n, alpha] (list[m+1,beta+1] U int),0} in

let ziptrans = {contra: unitR => forall n; m; alpha; beta; teta. 
((list [n, alpha] U int) X (list[n, teta] (list [m, beta] U int))) =>
list [ n,min(n,alpha+teta)] ((U int) X list[m,beta] (U int)), 0} in

fix tran(z). Lam. Lam. Lam. Lam. lam x.
caseL x of
nil => contra
| r:: tl => caseL tl of
  		nil => (map ()) [] [] r
            | t::rl => let trec = tran () [] [] [] [] tl in
                       let p = ziptrans () [] [] [] [] [] (r,trec) in
                       mapap () [] [] [] [] (lam y. (fst y) :: (snd y)) p
 <= 0 :
 unitR => forall n; m; a; b. {1 <= n && 1 <= m && a <= n && b <= m} ((list[n,a] (list[m,b] U int)) => list[m,m] (list[n,n] U int))
