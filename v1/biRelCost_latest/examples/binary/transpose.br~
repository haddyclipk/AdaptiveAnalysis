let map = {contra : unitR => forall n, alpha. (U int -> list[1,1] U int) => (list [n, alpha]
U int => list [n, alpha] (list[1,1] U int)) , 0} in

let mapap = {contra: unitR => forall n, m, alpha, beta. (((U int) X list[m,beta]
U int) => list[m+1,beta+1] U int) => (list [n, alpha] (U int X (list[m,beta]
U int)) => list [n, alpha] (list[m+1,beta+1] U int)) ,0} in

let ziptrans = {contra: unit => forall n, m, alpha, beta, teta. 
((list [n, alpha] U int) X (list[n, teta] (list [m, beta] U int))) ->
list [ n,min(n,alpha+teta)] ((U int) X list[m,beta] (U int)), 0} in

fix tran(z). Lam. Lam. Lam. Lam. lam x.
caseL x of
nil -> contra
| r:: tl -> case tl of
  		nil -> ((map ()) [] [] (lam x. (x::nil))) r
            | t::rl -> let trec = ((tran ()) [] [] [] []). tl in
                       let p = ((ziptrans ()) [] [] [] [] []) (r,trec) in
                       (((mapap ()) [] [] [] []) (lam y. (fst y) :: (snd y))) p
) <= 0 :
 unit -> forall n, m, a, b. {1 <= n and 1 <= m and a <= n and b <= m}
 ((list[n,a] (list[m,b] U int)) -> list[m,m] (list[n,n] U int)), 0
