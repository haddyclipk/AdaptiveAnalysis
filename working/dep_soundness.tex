\input{dep_inversion}
\clearpage
\subsection{Variable Dependency Soundness}
\begin{thm}[$\vardep$ implies $\flowsto$]
Given a program $\ssa{c}$, 
\[
  \forall \ssa{x}_1^{l_1}, \ssa{x}_2^{l_2} \in \lvar_{\ssa{c}}.
  \vardep(\ssa{x}_1^{l_1}, \ssa{x}_2^{l_2}, \ssa{c})
  \implies 
  \Big( \exists z_1, \cdots, z_n \in \lvar_{\ssa{c}}. ~ n \geq 0 \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, \ssa{x}_2^{l_2}) \Big)
\]
\end{thm}
\begin{proof}
Unfolding $\vardep(\ssa{x}_1^{l_1}, \ssa{x}_2^{l_2}, \ssa{c})$ by Definition~\ref{def:var_dep},
we get:
\[
\exists \event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom. ~
(\pi_1{\event_1}, \pi_2(\event_1))= (\ssa{x}_1, l_1)
\land
(\pi_1{\event_2}, \pi_2(\event_2)) = (\ssa{x}_2, l_2)
\land 
\eventdep(\event_1, \event_2, c, D)
\]
%
Let $\event_1 = (x_1, l_1, n_1, v_1)$, $\event_2 = (x_2, l_2, n_2, v_2)$, unfolding $\eventdep(\event_1, \event_2, c, D)$ by Definition~\ref{def:event_dep}, we have:
\[
\eventdep^{val}(\event_1, \event_2, c, D) ~ (a) 
\lor
\eventdep^{\ctl}(\event_1, \event_2, c, D) ~ (b)
\]
Prove by cases $(a)$ and $(b)$:
\caseL{$(a) ~ \eventdep^{val}(\event_1, \event_2, c, D)$}
Unfolding $\eventdep^{val}(\event_1, \event_2, c, D)$ by Definition~\ref{def:event_valdep}, we have:
\[
\exists \vtrace_0,
\vtrace_1, \vtrace_2, \vtrace_2' \in \mathcal{T}, \event_2', \event_1' \in \eventset, \ssa{c}_1, \ssa{c}_2,  \ssa{c}_2'.
  \left(
  \begin{array}{ll}   
 & \config{\ssa{c}, \vtrace_0} \rightarrow^{*} 
\config{\ssa{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{\ssa{c}_2,  \vtrace_1 \cdot \event_1 \vtrace_2 \cdot \event_2 } 
  % 
 \\ 
 \bigwedge &
  \config{\ssa{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{\ssa{c}_2',  \vtrace_1 \cdot \event_1 \vtrace_2' \cdot \event_2' } 
\\
\bigwedge &
\event_2 \eventneq \event_2' \land \event_2 \sigeq \event_2'
\end{array}
\right)
 \]
 %
 By induction on length of $\vtrace_2$, $m = |\vtrace_2|$, it is sufficient to show:
%
 \[
 \Big(\exists z_1, \cdots, z_n \in \lvar_{\ssa{c}} \st (0 \leq n \leq m )
 \land \flowsto(x_1^{l_1}, z_1) \land \cdots \land \flowsto(z_n, \ssa{x}_2^{l_2}) \Big)
  \]
 \caseL{$m = 0$}
%
By inversion \todo{lemma-(Assignement Event --> Query / Assignment Command)} on 
 $\event_1$ and $\event_2$, we know $\exists \expr_1 or \qexpr_1$, $\exists \expr_2 or \qexpr_2$
 \[
  \begin{array}{l}   
\config{\ssa{c}, \vtrace_0, \vcounter_0} \rightarrow^{*} 
\config{[\assign{\ssa{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; \ssa{c}_1, \vtrace_0 \vtrace_1}  
\rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1} \\
  \qquad \rightarrow^{*} 
  \config{[\assign{\ssa{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};\ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1 \vtrace_2} 
  \rightarrow^{assn/query} 
  \config{\ssa{c}_2,  \vtrace_0 \vtrace_1 \cdot \event_1 \vtrace_2 \cdot \event_2} 
  % 
\end{array} ~ (1)
 \]
 and 
  \[
  \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{[\assign{\ssa{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; \ssa{c}_2', \vtrace_0 \vtrace_1 \cdot \event_1 \vtrace_2'} 
  \rightarrow^{assn/query} 
  \config{\ssa{c}_2',  \vtrace_0 \vtrace_1 \cdot \event_1 \vtrace_2' \cdot \event_2'} 
 ~(2)
 \]
%
 By evaluation $(1)$ and $(2)$, we have:
\[
  \begin{array}{l}   
\config{\ssa{c}, \vtrace_0, \vcounter_0} \rightarrow^{*} 
\config{[\assign{\ssa{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; \ssa{c}_1, \vtrace_0 \vtrace_1}  \rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1} \\
  \qquad \rightarrow^{\eskip^*} 
  \config{[\assign{\ssa{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};\ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{assn/query} 
  \config{\ssa{c}_2,  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_2} 
  % 
\end{array}
 \]
 and 
  \[
  \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip*} 
  \config{[\assign{\ssa{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; \ssa{c}_2', \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{\ssa{c}_2',  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_2'} 
 \]
%
By definition of environment, we have:
\[
  \forall z \in \lvar_c \setminus \{x_1^{l_1}\} ,
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event'') (z) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event') (z)
\]
%
By operational semantics rule \rname{ssa-assn} and \rname{ssa-query} and \todo{inversion Lemma} of arithmetic expression evaluation, we have 
\[
  x_1 \in VAR(\expr_2)
\]
or
\[
  x_1 \in VAR(\qexpr_2)
\]
%
By $\flowsto$ definition, we have:
%
\[
\flowsto(x_1^{l_1}, \ssa{x}_2^{l_2})
\]
i.e.,
%
\[
 \Big( \exists z_1, \cdots, z_n \in \lvar_{\ssa{c}} \st (0 \leq n \leq 0 )
 \land \flowsto(x_1^{l_1}, z_1) \land \cdots \land \flowsto(z_n, \ssa{x}_2^{l_2}) \Big)
\]
%
This case is proved.
%
 \caseL{$m = 1$}
%
Let $\vtrace_2 = \cdot \event' \cdot$, there are 2 sub-cases: 
%
 \[
 \big(\event' \in \eventset^{\test}\big) \lor \big(\event' \in \eventset^{\asn}\big)
 \]
%
This case is proved by splitting the 2 sub-cases.
%
\subcaseL{$\event' \in \eventset^{\test}$}
 %
Let $\event' = (b, l_b, n_b, v_b)$, by evaluation $(1)$ and $(2)$, and \todo{inversion Lemma (test event --> if /  While command)}, we have:
\[
  \begin{array}{l}   
\config{\ssa{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{\ssa{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; \ssa{c}_1, \vtrace_0 \vtrace_1}  
\rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1} 
 \\
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif ([b]^{l_b}, c^1, c^2) / \ewhile [b]^{l_b} \edo c_b;\ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
 \rightarrow^{if / while} 
  \config{c_3, 
  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event'} 
  \\
  \qquad   \rightarrow^{*} 
  \config{[\assign{\ssa{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};\ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event'} 
  \rightarrow^{assn/query} 
  \config{\ssa{c}_2,  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event' \cdot \event_2} 
  % 
\end{array}
 \]
 and 
  \[
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{\eskip^*} 
  \config{\eif ([b]^{l_b}, c^1, c^2) / \ewhile [b]^{l_b} \edo c_b;\ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{if / while} 
  \config{c_3, 
  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event''} 
  \\
  \qquad \rightarrow^{\eskip^*} 
  \config{[\assign{\ssa{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};\ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1\cdot \event''} 
  \rightarrow^{assn/query} 
  \config{\ssa{c}_2',  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \event_2'} 
\end{array} ~(2)
 \]
%
By definition of environment, we have:
\[
  \forall z \in \lvar_c \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event'') (z) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event') (z)
\]
By operational semantics rule \rname{ssa-assn} and \rname{ssa-query} and \todo{inversion Lemma} of arithmetic expression evaluation, we have 
\[
  x_1 \in VAR(\expr_2) 
\]
or
\[
  x_1 \in VAR(\qexpr_2)
\]
%
By $\flowsto$ definition, we have:
%
\[
\flowsto(x_1^{l_1}, \ssa{x}_2^{l_2})
\]
i.e.,
%
\[
 \Big( \exists z_1, \cdots, z_n \in \lvar_{\ssa{c}} \st (0 \leq n \leq 1 )
 \land \flowsto(x_1^{l_1}, z_1) \land \cdots \land \flowsto(z_n, \ssa{x}_2^{l_2}) \Big)
\]
%
This case is proved.
%
\subcaseL{$\event' \in \eventset^{\asn}$}
%
Let $\event' = (z, l', n', v')$, there are 2 cases:
%
$\eventdep^{val}(\event_1, \event', c, D)$ or $\neg \eventdep^{val}(\event_1, \event', c, D)$.
%
This sub-case is proved by splitting the 2 cases.
%
\subsubcaseL{$\eventdep^{val}(\event_1, \event', c D)$}
%
By conclusion from \textbf{case: $m = 0$}, we know
\[
  \flowsto(x_1^{l_1}, z^{l'})
\]
%
By definition of environment, we have:
\[
  \forall u \in \lvar_c \setminus \{x_1^{l_1}, z^{l'}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event'') (u) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event') (u)
\]
By operational semantics rule \rname{ssa-assn} and \rname{ssa-query} and \todo{inversion Lemma} of arithmetic expression evaluation, we have 
\[
  x_1 \in VAR(\expr_2) \lor z \in VAR(\expr_2)
\]
or
\[
  x_1 \in VAR(\qexpr_2) \lor z \in VAR(\qexpr_2)
\]
%
By Definition of $\flowsto$, we know
\[
  \flowsto(x_1^{l_1}, x_2^{l_2}) \lor 
  \big(\flowsto(x_1^{l_1}, z) \land \flowsto(z, x_2^{l_2}) \big)
\]
%
i.e.,
%
\[
 \Big( \exists z_1, \cdots, z_n \in \lvar_{\ssa{c}} \st (0 \leq n \leq 1 )
 \land \flowsto(x_1^{l_1}, z_1) \land \cdots \land \flowsto(z_n, \ssa{x}_2^{l_2}) \Big)
\]
%
This case is proved.
%
\subsubcaseL{$\neg \eventdep^{val}(\event_1, \event', c D)$}
Then, we know by conclusion from the case $m = 0$:
\[
  x_1 \in VAR(\expr_2)
\]
%
By Definition of $\flowsto$, we know
\[
  \flowsto(x_1^{l_1}, x_2^{l_2}) 
\]
this case is proved.
%
In conclusion, we have:
\[
  \Big( \exists z_1, \cdots, z_n \in \lvar_{\ssa{c}}. ~ 0 \leq n \leq 1 \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
\]
The case $m = 1$ is proved.
%
\caseL{$m = m' + 1, n \geq 0$}
By induction hypothesis on $n$ and $\vardep(x_1^{l_1}, x_2^{l_2}, c, D)$, 
$\vardep(x_1^{l_1}, z^{l_z}, c, D) \land \vardep(z^{l_z}, x_2^{l_2}, c, D)$ respectively, 
we have $\exists y_1, \cdots, y_n, 0 \leq n \leq m'$ s.t.:
\[
\begin{array}{ll}
      & \flowsto(x_1, x_2) \\
  \lor  & \flowsto(x_1, y_1) \land \flowsto(y_1, x_2)\\
  \lor  & \flowsto(x_1, y_1) \land \flowsto(y_1, z) \land \flowsto(z, x_2) \\
  \lor  & \flowsto(x_1, z) \land \flowsto(z, y_1) \land \flowsto(y_1, x_2) \\
  \lor  & \cdots \\
  \lor  & \flowsto(x_1, y_1) \land \cdots \land \flowsto(y_n, z) \land \flowsto(z, x_2) \\
\end{array}
\]
i.e.,
\[
  \Big( \exists z, y_1, \cdots, y_n \in \lvar_{\ssa{c}}. ~ 0 \leq n + 1 \leq m \land
  \flowsto(x_1^{l_1}, z) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
\]
This case is proved.

\caseL{$(b)$}
Unfolding $\eventdep^{\ctl}(\event_1, \event_2, c, D)$, we have:
\[
\exists \event_1' \in \eventset^{\asn}, \vtrace_0,
\vtrace_1, \vtrace_2, \vtrace_2' \in \mathcal{T}, \ssa{c}_1.
  \left(
  \begin{array}{ll}   
  & \config{\ssa{c}, \vtrace_0} \rightarrow^{*} 
    \config{\ssa{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
    \config{\eskip,  \vtrace_1 \cdot \event_1 \vtrace_2} 
  \\ 
  \bigwedge &
  \config{\ssa{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{\eskip,  \vtrace_1 \cdot \event_1 \vtrace_2' } 
  \\
  \bigwedge &
  \event_2 \sigin \vtrace_2 \land \event_2 \notsigin \vtrace_2'
\end{array}
\right)
 \]
 %
 By \todo{Inversion Lemma (Control -> testing event)}, we have:
 \[
   \exists \event_b\in \eventset^{\test} \st (\event_b \eventlt \event_2) \land \eventdep^{val}(\event_1, \event_b, c, D)
 \]
 \todo{And $\event_2$ in the body command of $\event_b$ By inversion Lemma (control -> event 2)}
 %
 Unfolding $\eventdep^{val}(\event_1, \event_b, c, D)$ by Definition~\ref{def:event_valdep}, we have:
\[
\exists \vtrace_0, \vtrace_1, \vtrace_b, \vtrace_b' \in \mathcal{T},  \event_b', \event_1' \in \eventset, 
\ssa{c}_1, \ssa{c}_2, \ssa{c}_2 \st
  \left(
  \begin{array}{ll}   
 & \config{\ssa{c}, \vtrace_0} \rightarrow^{*} 
  \config{\ssa{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{\ssa{c}_2,  \vtrace_1 \cdot \event_1 \vtrace_b \cdot \event_b } 
  % 
  \\ 
  \bigwedge &
  \config{\ssa{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{\ssa{c}_2',  \vtrace_1 \cdot \event_1' \vtrace_b' \cdot \event_b' } 
  \\
  \bigwedge &
  \event_b \eventneq \event_b' \land \event_b \sigeq \event_b'
\end{array}
\right)
 \]
 Let $\event_b = (b, l_b, n_b, v_b)$, by \todo{Inversion Lemma (Testing Event -> If / While Command)},
we know $\exists \vtrace_2, \vtrace_2', \ssa{c}_1, \ssa{c}_2$
 \[
  \begin{array}{l}   
  \config{\ssa{c}, \vtrace_0} 
  \rightarrow^{*} 
  \config{[\assign{\ssa{x}_1}{\expr_1~ or ~ \query(\qexpr_1)}]^{l_1} ; \ssa{c}_1, \vtrace_0 \vtrace_1}  \rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1} 
  \\ 
  \qquad \rightarrow^{*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; \ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1 \vtrace_b} 
  \rightarrow^{if / while} 
  \config{\ssa{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1 \vtrace_b \cdot \event_b} 
\end{array} ~ (3)
 \]
and 
 \[
  \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; \ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1' \vtrace_b'} 
  \rightarrow^{if/while} 
  \config{\ssa{c}_3',  \vtrace_0 \vtrace_1 \cdot \event_1' \vtrace_b' \cdot \event_b'} 
  ~(4)
 \]
 %
 %
Induction on length of $m = |\vtrace_b|$, the following proposition is proved:
%
 \[
 \Big( \exists z_1, \cdots, z_n \in \lvar_{\ssa{c}}. ~ 0 \leq n \leq m \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
  \]
 \caseL{$m = 0$}
 By execution $(3)$ and $(4)$, we have:
\[
  \begin{array}{l}   
  \config{\ssa{c}, \vtrace_0} 
  \rightarrow^{*} 
  \config{[\assign{\ssa{x}_1}{\expr_1~ or ~ \query(\qexpr_1)}]^{l_1} ; \ssa{c}_1, \vtrace_0 \vtrace_1}  \rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; \ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{if / while} 
  \config{\ssa{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_b} 
\end{array}
 \]
and 
 \[
  \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; \ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1 \vtrace_2'} 
  \rightarrow^{if / while} 
  \config{\ssa{c}_2,  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_b'} 
 \]
 By definition of environment, we have:
\[
  \forall u \in \lvar_c \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event'') (u) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event') (u)
\]
%
By \todo{inversion Lemma} of boolean expression evaluation, we have since $x$ is the only variable has different value, $x$ can only be in the $VAR(b)$ in order to change value of $\event_b$, i.e.,
 \[
  x_1^{l_1} \in VAR(b)
 \]
 %
 By \todo{Inversion Lemma: Control DEP -> event 2}, we know $\event_2$ is generated from the either $c^1$, $c^2$ or $c'$.
 By definition of $\flowsto$, we know
 \[
 \forall z \in VAR(b), \flowsto(z, x_2^{l2})
 \]
 Then, we have
 \[
 \flowsto(x_1^{l_1}, x_2^{l_2})
 \]
 i.e.,
 \[
 \Big( \exists z_1, \cdots, z_n \in \lvar_{\ssa{c}}. ~ 0 \leq n \leq 0 \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
 \]
 This case is proved.
%
 \caseL{$m = 1$}
 %
 Let $\vtrace_2 = \cdot \event^2 \cdot$, there are 2 sub cases: 
 \[
 \event' \in \eventset^{\test} \lor \event' \in \eventset^{\asn}
 \]
 %
 This case is proved by splitting the 2 sub cases.
 %
 \subcaseL{$\event^2 \in \eventset^{\test}$}
  %
By execution $(3)$ and $(4)$, and \todo{Inversion Lemma : test event -> if / While Command}, we have:
\[
  \begin{array}{l}   
  \config{\ssa{c}, \vtrace_0} 
  \rightarrow^{*} 
  \config{[\assign{\ssa{x}_1}{\expr_1~ or ~ \query(\qexpr_1)}]^{l_1} ; \ssa{c}_1, \vtrace_0 \vtrace_1}  \rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif([b_2]{}^{l_{b_2}}, c^3, c^4) / \ewhile [b_2]{}^{l_{b_2}} \edo c^5; \ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{if / while} 
  \config{\ssa{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event^2} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; \ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1\cdot \event^2} 
  \rightarrow^{if / while} 
  \config{\ssa{c}_4,  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event^2 \cdot \event_b} 
\end{array}
 \]
and 
 \[
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1'} 
 \rightarrow^{\eskip^*} 
  \config{\eif([b_2]{}^{l_{b_2}}, c^3, c^4) / \ewhile [b_2]{}^{l_{b_2}} \edo c^5; \ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{if / while} 
  \config{\ssa{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event^3} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; \ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event^3} 
  \rightarrow^{if / while} 
  \config{\ssa{c}_4,  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event^3 \cdot \event_b'} 
\end{array}
 \]
 By definition of environment, we have:
\[
  \forall u \in \lvar_c \setminus \{x_1^{l_1}, z^{l'}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event^3) (u) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event^2) (u)
\]
%
By \todo{inversion Lemma} of boolean expression evaluation, we have since $x$ is the only variable has different value, $x$ can only be in the $VAR(b)$ in order to change value of $\event_b$, i.e.,
 \[
  x_1^{l_1} \in VAR(b)
 \]
 %
 Since $\event_2$ is generated from the either $c^1$, $c^2$ or $c'$ by \todo{Inversion Lemma: Control DEP -> event 2}
 By definition of $\flowsto$, we know
 \[
 \forall z \in VAR(b), \flowsto(z, x_2^{l2})
 \]
 Then, we have
 \[
 \flowsto(x_1^{l_1}, x_2^{l_2})
 \]
 i.e.,
 \[
 \Big( \exists z_1, \cdots, z_n \in \lvar_{\ssa{c}}. ~ 0 \leq n \leq 1 \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
 \]
  This case is proved.
%
\subcaseL{$\event_3 \in \eventset^{\asn}$}
Let $\event_3 = (z, l_3, n_3, v_3)$ or $\event_3 = (z, l_3, n_3, \qval_3, v_3)$, there are 2 cases:
$\eventdep^{val}(\event_1, \event', c D)$ or $\neg \eventdep^{val}(\event_1, \event', c D)$
%
\subsubcaseL{$\eventdep^{val}(\event_1, \event', c D)$}
%
By conclusion from \textbf{case: $\eventdep^{val}(\event_1, \event_2, c, D)$ and $m = 0$}, we know
\[
  \flowsto(x_1^{l_1}, z^{l_3})
\]
%
By execution $(3)$ and $(4)$, we have:
\[
  \begin{array}{l}   
  \config{\ssa{c}, \vtrace_0} 
  \rightarrow^{*} 
  \config{[\assign{\ssa{x}_1}{\expr_1~ or ~ \query(\qexpr_1)}]^{l_1} ; \ssa{c}_1, \vtrace_0 \vtrace_1}  \rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{[\assign{z}{\expr_3~ or ~ \query(\qexpr_3)}]^{l_3}; \ssa{c}_2', 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{assn / query} 
  \config{\ssa{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_3} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; \ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_3} 
  \rightarrow^{if / while} 
  \config{\ssa{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_3 \cdot \event_b} 
\end{array}
 \]
and 
 \[
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{z}{\expr_3~ or ~ \query(\qexpr_3)}]^{l_3}; \ssa{c}_2', 
  \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn / query} 
  \config{\ssa{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_3'} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; \ssa{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_3'} 
  \rightarrow^{if / while} 
  \config{\ssa{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_3' \cdot \event_b'} 
\end{array}
 \]
 By definition of environment, we have:
\[
  \forall u \in \lvar_c \setminus \{x_1^{l_1}, z^{l'}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_3 ) (u) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_3') (u)
\]
%
By \todo{inversion Lemma} of boolean expression evaluation, we have since $x$ is the only variable has different value, $x$ can only be in the $VAR(b)$ in order to change value of $\event_b$, i.e.,
 \[
  x_1^{l_1} \in VAR(b) \lor z \in VAR(b)
 \]
 %
 By \todo{Inversion Lemma: Control DEP -> event 2}, we know $\event_2$ is generated from the either $c^1$, $c^2$ or $c'$.
 By definition of $\flowsto$, we know
 \[
 \forall u \in VAR(b), \flowsto(u, x_2^{l2})
 \]
 Then, we have
 \[
  \flowsto(x_1^{l_1}, x_2^{l_2}) \lor 
  \big(\flowsto(x_1^{l_1}, z) \land \flowsto(z, x_2^{l_2}) \big)
 \]
 i.e.,
 \[
 \Big( \exists z_1, \cdots, z_n \in \lvar_{\ssa{c}}. ~ 0 \leq n \leq 0 \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
 \]
 This case is proved.
%
%
\subsubcaseL{$\neg \eventdep^{val}(\event_1, \event', c D)$}
By $\neg \eventdep^{val}(\event_1, \event', c D)$ and the definition of environment, we have:
\[
  \forall u \in \lvar_c \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_3 ) (u) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_3') (u)
\]
in execution $(3)$ and $(4)$.
%
Then, we know by conclusion from the case $m = 0$:
\[
  x_1^{l_1} \in VAR(b)
\]
%
By Definition of $\flowsto$, we know
\[
  \flowsto(x_1^{l_1}, x_2^{l_2}) 
\]
this case is proved.
%
In conclusion, we have:
\[
  \Big( \exists z_1, \cdots, z_n \in \lvar_{\ssa{c}}. ~ 0 \leq n \leq 1 \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
\]
The case $m = 1$ is proved.
%
\caseL{$m = n + 1, n \geq 0$}
By induction hypothesis on $n$ and case of $m = 1$ we have $\exists y_1, \cdots, y_n$ s.t.:
\[
\begin{array}{ll}
      & \flowsto(x_1, x_2) \\
  \lor  & \flowsto(x_1, y_1) \land \flowsto(y_1, x_2)\\
  \lor  & \flowsto(x_1, y_1) \land \flowsto(y_1, z) \land \flowsto(z, x_2) \\
  \lor  & \flowsto(x_1, z) \land \flowsto(z, y_1) \land \flowsto(y_1, x_2) \\
  \lor  & \cdots \\
  \lor  & \flowsto(x_1, y_1) \land \cdots \land \flowsto(y_n, z) \land \flowsto(z, x_2) \\
\end{array}
\]
This case is proved.
\end{proof}