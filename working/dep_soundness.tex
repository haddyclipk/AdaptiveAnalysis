{\input{dep_inversion}
\clearpage
\subsection{Variable Dependency Soundness}
\begin{thm}[$\vardep$ implies $\flowsto$]
Given a program ${c}$, 
\[
  \forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}}.
  \vardep({x}_1^{l_1}, {x}_2^{l_2}, {c})
  \implies 
  \Big( \exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st n \geq 0 \land
  \flowsto(x_1^{l_1}, z_1^{r_1}) 
  \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
\]
\end{thm}
\begin{proof}
Unfolding $\vardep({x}_1^{l_1}, {x}_2^{l_2}, {c})$ by Definition~\ref{def:var_dep},
we get:
\[
\exists \event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom \st
\pi_{(1,2)}{(\event_1)} = ({x}_1, l_1)
\land
\pi_{(1,2)}{(\event_2)} = ({x}_2, l_2)
\land 
\eventdep(\event_1, \event_2, c, D)
\]
%
Let $\event_1 = (x_1, l_1, n_1, v_1)$, $\event_2 = (x_2, l_2, n_2, v_2)$, unfolding $\eventdep(\event_1, \event_2, c, D)$ by Definition~\ref{def:event_dep}, we have:
\[
\eventdep^{val}(\event_1, \event_2, c, D) ~ (a) 
\lor
\eventdep^{\ctl}(\event_1, \event_2, c, D) ~ (b)
\]
%
It is proved by splitting the cases $(a)$ and $(b)$:
%
\caseL{$(a) ~ \eventdep^{val}(\event_1, \event_2, c, D)$}
%
Unfolding $\eventdep^{val}(\event_1, \event_2, c, D)$ by Definition~\ref{def:event_valdep}, we have:
\[
\exists \vtrace_0,
\vtrace_1, \vtrace_2, \vtrace_2' \in \mathcal{T}, \event_2' \in \eventset, \event_1' \in \eventset^{\asn}, {c}_1, {c}_2,  {c}_2'.
\left(
  \begin{array}{ll}   
 & \config{{c}, \vtrace_0} \rightarrow^{*} 
  \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{{c}_2,  \vtrace_1 \cdot \event_1 \cdot \vtrace_2 \cdot \event_2}
  % 
 \\ 
 \bigwedge &
  \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{{c}_2',  \vtrace_1 \cdot \event_1'  \cdot \vtrace_2' \cdot \event_2'}
\\
\bigwedge & \event_1 \sigeq \event_1' \land \sigdiff(\event_2,\event_2')
\end{array}
\right)
 \]
%
 %
 \textbf{By induction on length of $\vtrace_2$, $m = |\vtrace_2|$, it is sufficient to show:}
%
 \[
 \Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} 
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
  \]
%
By Inversion Lemma~\ref{lem:inv_asn} on 
 $\event_1$, $\event_2$ we know $\exists \expr_1$ or $\qexpr_1$, $\exists \expr_2$ or $\qexpr_2$
 \todo{notation $\assign{x}{\expr / \query(\qexpr)}$ denotes variable $x$ is assigned by either an expression $\expr$ or query $\query(\qexpr)$}
\begin{equation}
\label{eq:valdep_inv1}
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \cdot \vtrace_1}  
\rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \vtrace_2} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \vtrace_2 \cdot \event_2} 
  % 
\end{array}
\end{equation}
%
%
By Inversion Lemma~\ref{lem:inv_asn} on 
$\event_2'$ and execution $(2)$, we know $\exists \expr_2'$ or $\qexpr_2'$
 \[
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{[\assign{{x}_2'}{\expr_2' / \query(\qexpr_2')}]^{l_2'} ; {c}_2', \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \vtrace_2'} 
  \rightarrow^{assn/query} 
  \config{{c}_2',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2'} 
  % 
\end{array}
 \]
%
Unfolding $\sigdiff(\event_2,\event_2')$, we have:
\[
  \event_2 \sigeq \event_2'
\] 
%
Then, we have:
\begin{equation}
\label{eq:valdep_inv2}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2' / \query(\qexpr_2')}]^{l_2} ; {c}_2', \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \vtrace_2'} 
  \rightarrow^{assn/query} 
  \config{{c}_2',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2'} 
\end{equation}
%
By $\event_2 \sigeq \event_2'$, we also know
\[
  x_2 = x_2' \land l_2 = l_2' \land 
  \vcounter(\vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \vtrace_2 \cdot \event_2) l_2 = 
  \vcounter(\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2') l_2'
\] 
By $\event_1 \sigeq \event_1'$, we have:
\begin{equation}
\label{eq:valdep_invn}
   \vcounter(\vtrace_2) l_2 = 
  \vcounter(\vtrace_2') l_2'
\end{equation}
%
 %
\caseL{$m = 0$}
%
%
 By Eq.~\ref{eq:valdep_inv1}, we have:
\[
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \cdot \vtrace_1}  \rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_2} 
  % 
\end{array}
 \]
 By Induction on the operational semantics rules on 
 \[\config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1}
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1} \]
 %
 we know by  \todo{Inversion Lemma: no event generated, iff the program is $\eskip$}, \todo{notation $[\eskip]{}^*$}:
 \[
 c_1 =_c 
 [\eskip]{}^*;[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2
 \]
 %
 %
There are two possible cases, where $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$ 
or $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_2$.
\\
If $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2}\notin_c c_2$,
by substituting $c_1$ in the execution in Eq.~\ref{eq:valdep_inv2}, we have 
\todo{notation $\rightarrow^{\eskip^*}$ denotes evaluations of $\eskip$ command 0 for more times}
 %
  \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_2'} 
 \]
%
If $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$, \todo{Inversion lemma}, it must be in a while body.
\\
 By substituting $c_1$ in the execution in Eq.~\ref{eq:valdep_inv2}, we have following possible executions
 %
  \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, n_2', v_2')} 
 \]
%
  \[
  \begin{array}{l}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, n_2', v_2')} 
  \\ \qquad
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, v_2') \cdot \trace_3} 
  \\ \qquad
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, n_2', v_2') \cdot \trace_3 \cdot (x_2, l_2, n_2'', v_2'')} 
 \end{array}
 \]
\[
  \cdots
\] 
with iterations of the while body in $c_2$ $0$ or more times.
%
\\
%
For each possible execution, we have $\trace_2'$ and $\event_2'$ as follows:
\\
  $\trace_2'  = \cdot$
\\
$\trace_2' = \cdot (x_2, l_2, n_2', v_2') \cdot \trace_3 $
%
\\
$\cdots$
%
\\
%
By Eq.~\ref{eq:valdep_invn}, we know:
%
\[
 \vcounter(\trace_2') l_2 = 0
\]
%
Only the first execution with 0 iteration of while body in $c_2$ satisfy this restriction, i.e., $\trace_2' = \cdot$ and $\event_2' = (x_2, l_2, n_2', v_2')$
%
\\
%
By $\event_1 \sigeq \event_1'$, and definition of environment, we have:
\[
  \forall z^r \in \lvar_c \setminus \{x_1^{l_1}\} ,
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1) (z) =  
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1') (z)
\]
%
By {Inversion Lemma~\ref{lem:inv_a}} of arithmetic expression evaluation, we have 
\[
  x_1 \in VAR(\expr_2) ~ \mbox{or} ~
  x_1 \in VAR(\qexpr_2)
\]
%
By $\flowsto$ definition, we have:
%
\[
\flowsto(x_1^{l_1}, {x}_2^{l_2})
\]
i.e.,
%
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st (0 \leq n )
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
 \]
%
This case is proved.
%
 \caseL{$m = 1$}
%
Let $\vtrace_2 = {} \cdot {} \event'$, there are 2 sub-cases: 
%
 \[
 \big(\event' \in \eventset^{\test}\big) \lor \big(\event' \in \eventset^{\asn}\big)
 \]
%
This case is proved by splitting the 2 sub-cases.
%
\subcaseL{$\event' \in \eventset^{\asn}$}
%
Let $\event' = (z, l', n', v')$, there are 2 cases:
%
\[
\eventdep^{val}(\event_1, \event', c, D) \lor \neg \eventdep^{val}(\event_1, \event', c, D)
\]
%
This sub-case is proved by splitting the 2 subsub-cases.
%
\subsubcaseL{$\eventdep^{val}(\event_1, \event', c, D)$}
%
By conclusion from \textbf{case: $m = 0$}, we have following execution based on Eq.~\ref{eq:valdep_inv1}:
\begin{equation}
\label{eq:m1asn_inv1}
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \cdot \vtrace_1}  \rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} \\
  \qquad \rightarrow^{*} 
  \config{[\assign{z}{\expr_z / \query(\qexpr_z)}]^{l'};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event'}  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_3, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1\cdot \event'} 
  \rightarrow^{assn/query} 
  \config{{c}_3,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event' \cdot \event_2} 
  % 
\end{array}
 \end{equation}
and
 \[
 c_1 =_c 
 [\eskip]{}^*;[\assign{z}{\expr_z / \query(\qexpr_z)}]^{l'};  [\eskip]{}^*; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2
 \]
 %
 By substituting $c_1$ in the execution in Eq.~\ref{eq:valdep_inv2}, and conclusion from \textbf{case: $m = 0$}, we know the only possible execution satisfying:
 \[
  \vcounter(\vtrace_2') l_2 = 0
\]
%
 is as follows:
 %
\begin{equation}
\label{eq:m1asn_inv2}
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{z}{\expr_z / \query(\qexpr_z)}]^{l'};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event''}  \\
  \qquad \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_3, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1\cdot \event'} 
  \rightarrow^{assn/query} 
  \config{{c}_3,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \event_2'} 
\end{array}
 \end{equation}
 %
By induction hypothesis on $\eventdep^{val}(\event_1, \event', c, D)$ in case $m = 0$, we also have:
\[
  \flowsto(x_1^{l_1}, z^{l'})
\]
%
By $\eventdep^{val}(\event_1, \event', c, D)$, we have:
%
\[
  \sigdiff(\event, \event'')
\]
%
By definition of environment, we have:
\[
  \forall u^r \in \lvar_c \setminus \{x_1^{l_1}, z^{l'}\} \st
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'') (u) =  
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event') (u)
\]
By {Inversion Lemma~\ref{lem:inv_a}} of arithmetic expression evaluation, we have 
\[
  x_1 \in VAR(\expr_2) \lor z \in VAR(\expr_2) ~ \mbox{or} ~
  x_1 \in VAR(\qexpr_2) \lor z \in VAR(\qexpr_2)
\]
%
By Definition of $\flowsto$, we know
\[
  \flowsto(x_1^{l_1}, x_2^{l_2}) \lor \flowsto(z^{l'}, x_2^{l_2}) \big)
\]
%
Then we have:
%
\[
  \flowsto(x_1^{l_1}, z^{l'}) \land 
  \big( \flowsto(x_1^{l_1}, x_2^{l_2}) \lor \flowsto(z^{l'}, x_2^{l_2}) \big)
\]
%
i.e.,
%
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st (0 \leq n \leq 1 )
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
\]
%
This case is proved.
%
\subsubcaseL{$\neg \eventdep^{val}(\event_1, \event', c, D)$}
By subsubcase $\eventdep^{val}(\event_1, \event', c, D)$, 
we have the same 2 executions as in Eq.\ref{eq:m1asn_inv2} and Eq.\ref{eq:m1asn_inv1}.
\\
By $\neg \eventdep^{val}(\event_1, \event', c, D)$, we know:
\[
  \event' \eventeq \event''
\]
%
Then by definition of environment, we have:
\[
  \forall u^r \in \lvar_c \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'') (u) =  
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event') (u)
\]
%
By {Inversion Lemma~\ref{lem:inv_a}} of arithmetic expression evaluation, we have 
\[
  x_1 \in VAR(\expr_2)
\]
%
By Definition of $\flowsto$, we know
\[
  \flowsto(x_1^{l_1}, x_2^{l_2}) 
\]
%
i.e.,
%
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st (0 \leq n  )
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
\]
This case is proved.
%
%
\subcaseL{$\event' \in \eventset^{\test}$}
 %
Let $\event' = (b, l_b, n_b, v_b)$, by Eq.~\ref{eq:valdep_inv1} and {Inversion Lemma~\ref{lem:inv_test}}, we have:
\begin{equation}
\label{eq:m1test_inv1}
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \vtrace_1}  
\rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
 \\
  \qquad \rightarrow^{*} 
  \config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w;{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
 \rightarrow^{if-b / while-b} 
  \config{c_3, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event'} 
  \\
  \qquad   \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event'} 
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event' \cdot \event_2} 
  % 
\end{array}
\end{equation}
 By induction on operational semantics rules and the evaluations: 
 \todo{Inversion Lemma: no event generated, iff the program is $\eskip$}
 \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
  \rightarrow^{*} 
  \config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w;{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
 \]
 \[
 \config{c_3, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event'} 
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event'} 
 \]
 we know:
 \[
 c_1 =_c 
 [\eskip^*]; \eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w;{c}_2
 \]
  \[
 c_3 =_c 
 [\eskip^*]; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
 \]
By substituting $c_1$ in the execution in Eq.~\ref{eq:valdep_inv2}, we have 
 %
\begin{equation}
\label{eq:m1test_inv2}
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w ; {c}_2', \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{if / while} 
  \config{c_3', \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event''} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_2'}
  \rightarrow^{assn/query} 
  \config{{c}_4',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_2' \cdot \event_2'} 
\end{array}
\end{equation}
 %
By Eq.~\ref{eq:valdep_invn}, we know:
%
\[
 \vcounter({} \cdot {} \event') l_2 = \vcounter({} \cdot {} \event'' \cdot \vtrace_2') l_2
 \]
i.e., 
\[
  \vcounter(\vtrace_2') l_2 = 0
\]
Consider the two subsub-cases: 
%
$$
\eventdep^{val}(\event_1, \event', c, D) \lor \neg\eventdep^{val}(\event_1, \event', c, D)
$$
%
\subsubcaseL{$\neg\eventdep^{val}(\event_1, \event', c, D)$}
By execution in Eq.~\ref{eq:m1test_inv2} and Eq.~\ref{eq:m1test_inv1}, 
since $\neg\eventdep^{val}(\event_1, \event', c, D)$, we have:
\[
  \event' \eventeq \event''
\]
By operational semantics rules $\rname{if-b}$ and $\rname{while-b}$ and $\event' =_q \event''$, we have:
\[
 c_3 =_c c_3'
\]
%
Substituting $c_3'$ by $c_3$ in Eq.~\ref{eq:m1test_inv2}, we have:
\[
  \config{c_3', \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event''} 
  \rightarrow^{\eskip*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event''}
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \event_2'} 
\]
%
or
%
\[
 \begin{array}{l}
  \config{c_3', \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event''} 
  \rightarrow^{\eskip*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event''}
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot (x_2, l_2, n_2', v_2')} 
  \\ \qquad 
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event''\cdot (x_2, l_2, n_2', v_2') \cdot \trace_3}
  \\ \qquad 
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot (x_2, l_2, n_2', v_2')\cdot \trace_3 \cdot \event_2'} 
 \end{array} 
\]
if $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_4$ and 
the execution involves 1 or more iterations of $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2}$.
%
\\
By $\vcounter(\vtrace_2') l_2 = 0$ in Eq.~\ref{eq:m1test_inv2}, 
the first execution with no iteration of $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2}$ 
is the only possible execution instance of Eq.~\ref{eq:m1test_inv2}, i.e., $\vtrace_2' = \cdot$.
\\
By $\event_1 \sigeq \event_1'$ and $\event' \eventeq \event''$, and definition of environment, we have:
\[
  \forall z^r \in \lvar_c \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'') (z) =  
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event') (z)
\]
By {Inversion Lemma~\ref{lem:inv_a}} of arithmetic expression evaluation, we have 
\[
  x_1 \in VAR(\expr_2) ~ \mbox(or) ~  x_1 \in VAR(\qexpr_2)
\]
%
By $\flowsto$ definition, we have:
%
\[
\flowsto(x_1^{l_1}, {x}_2^{l_2})
\]
i.e.,
%
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st (0 \leq n \leq 1 )
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
\]
%
This case is proved.
%
\subsubcaseL{$\eventdep^{val}(\event_1, \event', c, D)$}
%
By execution in Eq.~\ref{eq:m1test_inv2} and Eq.~\ref{eq:m1test_inv1}, since $\eventdep^{val}(\event_1, \event', c, D)$, we have:
\[
  \event' \eventeq \event'' \lor \sigdiff(\event', \event'')
\]
%
Case of $\event' \eventeq \event''$ is proved in the same way in \textbf{subsub-case:} $\neg \eventdep^{val}(\event_1, \event', c, D)$.
\\
Case of $\sigdiff(\event', \event'')$ is proved by splitting two following cases:
\[
  c_1 =_c \eif ([b]^{l_b}, c_t, c_f);{c}_2
  \lor
  c_1 =_c \ewhile [b]^{l_b} \edo c_w;{c}_2
\]
\begin{subproof}[\textbf{Subsubsub-case}:] 
%
$c_1 =_c \eif ([b]^{l_b}, c_t, c_f);{c}_2$ 
\\
Without loss of generalization, 
let $\event' = (b, l_b, n_b, \etrue)$ and
$\event'' = (b, l_b, n_b, \efalse)$,
by execution Eq.~\ref{eq:m1test_inv1} and $\event' = (b, l_b, n_b, \etrue)$, we have:
\[
  \begin{array}{l}   
  \config{{c}, \vtrace_0} \rightarrow^{*} 
  \config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \vtrace_1}  
  \rightarrow^{assn/query}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
  \\
  \qquad \rightarrow^{*} 
  \config{\eif ([b]^{l_b}, c_t, c_f);{c}_2, \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{if-t} 
  \config{c_t;c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event'} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event'} 
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event' \cdot \event_2} 
  % 
  \end{array}
\]
and 
\[
  c_t;c_2 =_c [\eskip^*]; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
%
By execution in Eq.~\ref{eq:valdep_inv2} and $\event'' = (b, l_b, n_b, \efalse)$, we have:
 %
\begin{equation}
\label{eq:m1testif_inv2}
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\eif ([b]^{l_b}, c_t, c_f); {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{if-f} 
  \config{c_f;c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event''} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_2'}
  \rightarrow^{assn/query} 
  \config{{c}_4',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_2' \cdot \event_2'} 
\end{array}
\end{equation}
 %
By Inversion Lemma~\ref{lem:inv_b} on evaluation of boolean expression $b$ and following: 
\[
  \forall z \in \lvar \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1')(z) = \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1)(z)
\]
we know:
\[
  x_1^{l_1} \in VAR(b)
\]
%
 By uniqueness of label, we have following cases:
 \begin{enumerate}
 \item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_t$:
\\
By definition of $\lvar$, we know:
\[
  x_2^{l_2} \in \lvar_{c_t}
\]
%
 By uniqueness of program label, we have:
 \[
 [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_f
 \]
 %
 If $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_2$,
 %
we know $\forall \trace, \trace' \in \mathcal{T}$, there doesn't exist execution
 \[
  \config{c_f;c_2, \vtrace} \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', \trace'}
 \]
 This is contradict to the existence of execution in Eq.\ref{eq:m1testif_inv2}.
 \\
 If $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$, 
 by uniqueness of label \todo{Inversion Lemma}, 
 it must exist in the body of a while command in $c_2$,
 and $\eif ([b]^{l_b}, c_t, c_f) \in_c c_2$ and $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_t$. 
 %
\\
%
i.e., 
\\
%
By $\flowsto$ definition, we have:
\[
  \forall z_i^{r_i} \in \lvar_{c_t}, x_j^{l_j} \in VAR(b) \st
  \flowsto(x_j^{l_j}, z_i^{r_i})
\]
%
Since $x_1^{l_1} \in VAR(b)$  and $x_2^{l_2} \in \lvar_{c_t}$, we know:
%
\[
\flowsto(x_1^{l_1}, x_2^{l_2})
\]
%
i.e.,
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n 
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
\]
%
This case is proved.
\item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_t$:
\begin{enumerate}
 \item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_f$:
 \\
  we have
  \[
    \forall z_i^{r_i} \in \lvar_{c_f}, x_j^{l_j} \in VAR(b) \st
    \flowsto(x_j^{l_j}, z_i^{r_i})
  \]
  %
  and
  %
  \[
  \flowsto(x_1^{l_1}, x_2^{l_2})
  \]
  symmetrically as the case $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_t$.
  This case is proved.
 \item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_f$:
 \\
 Then we know $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$.
 \\
 By
 \[
  c_t;c_2 =_c [\eskip^*]; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
we know:
\[
  c_t = [\eskip^*]; \land c_2 = [\eskip^*]; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
Substituting $c_2$ in the execution in Eq.\ref{eq:m1testif_inv2}, by the restriction:
\[
  \vcounter(\trace_2')l_2 = 0
\]
we have the following execution as the only possible instance of Eq.\ref{eq:m1testif_inv2}.
\[
    \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\eif ([b]^{l_b}, c_t, c_f); {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{if-f} 
  \config{c_f;c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event''} 
  \\
  \qquad \rightarrow^{*} 
  \config{c_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_f}
  \\
  \qquad \rightarrow^{\eskip*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_f}
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_f \cdot \event_2'} 
\end{array}
\]
and \todo{Inversion Lemma, notation $VAR{(\trace)}$ denotes the labeled variables in $\trace$}
\[
  VAR{(\trace_f)} \subseteq \lvar_{c_f}
\]
%
By $\flowsto$ definition, we also have:
\[
  \forall z_i^{r_i} \in \lvar_{c_f}, x_j^{l_j} \in VAR(b) \st
  \flowsto(x_j^{l_j}, z_i^{r_i})
\]
i.e., 
\[
  \bigwedge_{\forall z_i^{r_i} \in \lvar_{c_f}}
  \flowsto(x_1^{l_1}, z_i^{r_i})
\]
%
By Inversion Lemma~\ref{lem:inv_a} on evaluation of expression $\expr_2$ and following: 
\[
  \forall z \in \lvar \setminus (\{x_1^{l_1}\} \cup VAR{(\trace_f)}) \st
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1'\cdot \event'' \cdot \trace_2')(z) 
  = \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1\cdot \event')(z)
\]
%
we have:
\[
  x_1^{l_1} \in VAR(\expr_2) \bigvee_{z_i^{r_i} \in VAR{(\trace_f)}} z_i^{r_i} \in VAR(\expr_2)
\]
%
By $\flowsto$ definition, we have:
\[
   \flowsto(x_1^{l_1}, x_2^{l_2}) \bigvee_{z_i^{r_i} \in VAR{(\trace_f)}} \flowsto(z_i^{r_i}, x_2^{l_2})
\]
%
By $ \bigwedge_{\forall z_i^{r_i} \in \lvar_{c_f}} \flowsto(x_1^{l_1}, z_i^{r_i})$ and $VAR{(\trace_f)} \subseteq \lvar_{c_f}$, we have:
\[
\flowsto(x_1^{l_1}, x_2^{l_2}) \bigvee_{z_i^{r_i} \in VAR{(\trace_f)}} 
(\flowsto(x_1^{l_1}, z_i^{r_i}) \land \flowsto(z_i^{r_i}, x_2^{l_2}))
\]
%
i.e.,
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n 
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
\]
%
This case is proved.
\end{enumerate}
%
\end{enumerate}
%
This case is proved.
\end{subproof}
%
\begin{subproof}[\textbf{subsubsub-case}:] $c_1 =_c \ewhile [b]^{l_b} \edo c_w;{c}_2$ 
%
\\
There are 2 cases:
$$
\Big(\event' = (b, l_b, n_b, \etrue) \land \event'' = (b, l_b, n_b, \efalse) \Big)
\lor 
\Big(\event' = (b, l_b, n_b, \efalse) \land \event'' = (b, l_b, n_b, \etrue) \Big)
$$
%
\textbf{subsubsubsub-case:} $\event' = (b, l_b, n_b, \etrue) \land \event'' = (b, l_b, n_b, \efalse)$
\\
By execution in Eq.~\ref{eq:m1test_inv1} and $\event' = (b, l_b, n_b, \etrue)$, we have:
\[
  \begin{array}{l}   
  \config{{c}, \vtrace_0} \rightarrow^{*} 
  \config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \vtrace_1}  
  \rightarrow^{assn/query}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
  \\
  \qquad \rightarrow^{*} 
  \config{\ewhile [b]^{l_b} \edo c_w;{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{while-t} 
  \config{c_w;\ewhile [b]^{l_b} \edo c_w; c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event'} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event'} 
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event' \cdot \event_2} 
  % 
  \end{array}
\]
% 
\[
  c_1 =_c [\eskip]{}^*; \ewhile [b]^{l_b} \edo c_w;{c}_2
\]
and
\[
  c_w;\ewhile [b]^{l_b} \edo c_w; c_2 =_c [\eskip]{}^*;[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
%
By substituting $c_1'$ with $c_1$ in execution in Eq.~\ref{eq:valdep_inv2} and $\event'' = (b, l_b, n_b, \efalse)$, we have:
 %
  \[
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\ewhile [b]^{l_b} \edo c_w;{c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{while-f} 
  \config{[\eskip]^{l_b};c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event''} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_2'}
  \rightarrow^{assn/query} 
  \config{{c}_4',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_2' \cdot \event_2'} 
\end{array}
 \]
 %
By Inversion Lemma~\ref{lem:inv_b} on evaluation of boolean expression $b$ and following: 
\[
  \forall z \in \lvar \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1')(z) = \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1)(z)
\]
we know:
\[
  x_1^{l_1} \in VAR(b)
\]
%
 By uniqueness of label, we have 2 cases:
 \begin{enumerate}
 \item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w$:
 If $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_2$,
 %
 Then we know $\forall \trace, \trace' \in \mathcal{T}$, there doesn't exist execution
 \[
  \config{[\eskip]^{l_b};c_2, \vtrace} \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', \trace'}
 \]
 This is contradict to the existence of execution in Eq.\ref{eq:m1testif_inv2}.
 \\
  If $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$, there must exist another while command
   in $c_2$ such that 
  $\ewhile [b]^{l_b} \edo c_w \in c_{w2}$ and $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w$.
  \\
  We know $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2}$ will only shows up in $c_w$.
  \\
  By $\flowsto$ definition, we have:
  \[
    \forall z_i^{r_i} \in \lvar_{c_w}, x_j^{l_j} \in VAR(b) \st
    \flowsto(x_j^{l_j}, z_i^{r_i})
  \]
  %
  Since $x_2^{l_2} \in \lvar_{c_w}$ by definition of $\lvar$ and $x_1^{l_1} \in VAR(b)$, we have: 
  \[
    \flowsto(x_1^{l_1}, x_2^{l_2})
  \]
  %
  This case is proved.
  %
 \item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_w$
 By
 \[
  c_w;\ewhile [b]^{l_b} \edo c_w; c_2 =_c [\eskip^*]; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
we know:
\[
  c_w;\ewhile [b]^{l_b} \edo c_w; =_c [\eskip^*]; \land c_2 = [\eskip^*]; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
This is contradict to program equivalence definition, i.e.,
\[
  c_w;\ewhile [b]^{l_b} \edo c_w; \neq_c [\eskip^*]
\]
This case is proved.
%
 \end{enumerate}
%
\textbf{subsubsubsub-case:}$\event' = (b, l_b, n_b, \efalse) \land \event'' = (b, l_b, n_b, \etrue)$
\\
By execution in Eq.~\ref{eq:m1test_inv1} and $\event' = (b, l_b, n_b, \etrue)$, we have:
\[
  \begin{array}{l}   
  \config{{c}, \vtrace_0} \rightarrow^{*} 
  \config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \vtrace_1}  
  \rightarrow^{assn/query}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
  \\
  \qquad \rightarrow^{*} 
  \config{\ewhile [b]^{l_b} \edo c_w;{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{while-f} 
  \config{[\eskip]; c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event'} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event'} 
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event' \cdot \event_2} 
  % 
  \end{array}
\]
%
\[
  c_1 =_c [\eskip]{}^*; \ewhile [b]^{l_b} \edo c_w;{c}_2
\]
% 
\[
  [\eskip]; c_2 =_c [\eskip^*];[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
i.e,
\[
  c_2 =_c [\eskip^*];[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
%
By substituting $c_1'$ with $c_1$ in execution in Eq.~\ref{eq:valdep_inv2} and $\event'' = (b, l_b, n_b, \etrue)$, we have:
 %
  \begin{equation}
  \label{eq:m1testwhile_inv2}
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\ewhile [b]^{l_b} \edo c_w;{c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{while-t} 
  \config{c_w;\ewhile [b]^{l_b} \edo c_w;c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event''} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_3}
  \rightarrow^{assn/query} 
  \config{{c}_4',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_3 \cdot \event_2'} 
\end{array}
\end{equation}
%
If $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w$, by uniqueness of the program label, there must exist another while command in $c_2$, -- i.e., $\ewhile [b_2]^{l_{b2}} \edo c_{w2} \in_c c_2$ --
    such that 
  $\ewhile [b]^{l_b} \edo c_w \in c_{w2}$ and $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w$.
%
Then we know there exists $c_5$ and $c_6$ such that:
\[
  c_2 =_c c_5; \ewhile [b_2]^{l_{b2}} \edo c_{w2};c_6
\]
Which is contradict to $c_2 =_c [\eskip^*];[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4$ by program equality definition.
%
%
Then we know $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_w$.
%
\\
%
Substituting $c_2$ in the execution in Eq.\ref{eq:m1testwhile_inv2}, we have the following execution be the only possible execution satisfying $\vcounter(\trace_2') l_2 = 0$ where $\trace_2' = \event'' \cdot \trace_w$:
\[
    \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\ewhile [b]^{l_b} \edo c_w;{c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{while-t} 
  \config{c_w;\ewhile [b]^{l_b} \edo c_w;c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event''} 
  \\
  \qquad \rightarrow^{*} 
  \config{c_2,\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_w}
  \\
  \qquad \rightarrow^{\eskip*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_w}
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event'' \cdot \trace_w \cdot \event_2'} 
\end{array}
\]
and
\[
  VAR{(\trace_w)} \subseteq \lvar_{c_w}
\]
%
By $\flowsto$ definition, we also have:
\[
  \forall z_i^{r_i} \in \lvar_{c_w}, x_j^{l_j} \in VAR(b) \st
  \flowsto(x_j^{l_j}, z_i^{r_i})
\]
i.e., 
\[
  \bigwedge_{\forall z_i^{r_i} \in \lvar_{c_w}}
  \flowsto(x_1^{l_1}, z_i^{r_i})
\]
%
By Inversion Lemma~\ref{lem:inv_a} on evaluation of expression $\expr_2$ and following: 
\[
  \forall z \in \lvar \setminus \{x_1^{l_1}\} \cup VAR{(\trace_w)} \st
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1'\cdot \event'' \cdot \trace_2')(z) 
  = \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1\cdot \event')(z)
\]
%
we have:
\[
  x_1^{l_1} \in VAR(\expr_2) \bigvee_{z_i^{r_i} \in VAR{(\trace_w)}} z_i^{r_i} \in VAR(\expr_2)
\]
%
\item By $\flowsto$ definition, we have:
\[
   \flowsto(x_1^{l_1}, x_2^{l_2}) \bigvee_{z_i^{r_i} \in VAR{(\trace_w)}} \flowsto(z_i^{r_i}, x_2^{l_2})
\]
%
By $ \bigwedge_{\forall z_i^{r_i} \in \lvar_{c_w}} \flowsto(x_1^{l_1}, z_i^{r_i})$ and $VAR{(\trace_w)} \subseteq \lvar_{c_w}$, we have:
\[
\flowsto(x_1^{l_1}, x_2^{l_2}) \bigvee_{z_i^{r_i} \in VAR{(\trace_w)}} 
(\flowsto(x_1^{l_1}, z_i^{r_i}) \land \flowsto(z_i^{r_i}, x_2^{l_2}))
\]
%
i.e.,
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}}
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
\]
%
This case is proved.
\end{subproof}
%
This case is proved.
%
\\
Then the case $m = 1$ is proved.
%
\caseL{$m = m' + 1, m' \geq 0$}
By induction hypothesis on $1$ and $\vardep(x_1^{l_1}, x_2^{l_2}, c, D)$, 
$\vardep(x_1^{l_1}, z_1^{r_1}, c, D) \land \vardep(z^{l_z}, x_2^{l_2}, c, D)$ respectively, 
we have $\exists z_2^{r_2}, \cdots, z_n^{r_2}, 1 \leq n \leq m'+1$ s.t.:
\[
\begin{array}{ll}
      & \flowsto(x_1^{l_1}, x_2^{l_2}) \\
  \lor  & \flowsto(x_1^{l_1}, z_2^{r_2}) \land \flowsto(z_2^{r_2}, x_2^{l_2})\\
  \lor  & \flowsto(x_1^{l_1}, z_2^{r_2}) \land \flowsto(z_2^{r_2}, z_1^{r_1}) \land \flowsto(z_1^{r_1}, x_2^{l_2}) \\
  \lor  & \flowsto(x_1^{l_1}, z_1^{r_1}) \land \flowsto(z_1^{r_1}, z_2^{r_2}) \land \flowsto(z_2^{r_2}, x_2^{l_2}) \\
  \lor  & \cdots \\
  \lor  & \flowsto(x_1^{l_1}, z_2^{r_2}) \land \cdots \land \flowsto(z_n^{r_n}, z_1^{r_1}) \land \flowsto(z_1^{r_1}, x_2^{l_2}) \\
\end{array}
\]
i.e.,
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st (0 \leq n \leq m )
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
\]
This case is proved.

\caseL{$(b)~\eventdep^{\ctl}(\event_1, \event_2, c, D)$}
Unfolding $\eventdep^{\ctl}(\event_1, \event_2, c, D)$, we have:
%
\[
\exists \vtrace_1, \vtrace_2, \vtrace_2', \vtrace_0 \in \mathcal{T}, 
\event_1' \in \eventset^{\asn}, {c}_1.
\left(
\begin{array}{ll}   
  & \config{{c}, \vtrace_0} \rightarrow^{*} 
    \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
    \config{\eskip,  \vtrace_1 \cdot \event_1 \cdot \vtrace_2} 
  \\ 
  \bigwedge &
  \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{\eskip,  \vtrace_1 \cdot \event_1 \cdot \vtrace_2' } 
  \\
  \bigwedge &
  \event_2 \ismin \vtrace_2 \land \event_2 \notismin \vtrace_2'
\end{array}
\right)
 \]
% %
 By {Inversion Lemma~\ref{lem:inv_ctltotest} and \ref{lem:inv_ctltoevent2}}, we have:
 \[
   \exists \event_b \in \eventset^{\test} \st (\event_b \eventlt \event_2) \land \eventdep^{val}(\event_1, \event_b, c, D)
 \]
 %
 and $\event_2$ in the body command of $\event_b$.
 %
 Unfolding $\eventdep^{val}(\event_1, \event_b, c, D)$ by Definition~\ref{def:event_valdep}, we have:
\[
\exists \vtrace_0, \vtrace_1, \vtrace_b, \vtrace_b' \in \mathcal{T},  \event_b', \event_1' \in \eventset, 
{c}_1, {c}_2, {c}_2 \st
  \left(
  \begin{array}{ll}   
 & \config{{c}, \vtrace_0} \rightarrow^{*} 
  \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{{c}_2,  \vtrace_1 \cdot \event_1 \vtrace_b \cdot \event_b } 
  % 
  \\ 
  \bigwedge &
  \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{{c}_2',  \vtrace_1 \cdot \event_1' \vtrace_b' \cdot \event_b' } 
  \\
  \bigwedge &
   \ismdiff(\event_b,\event_b')
\end{array}
\right)
 \]
Induction on length of $m = |\vtrace_b|$, it is sufficient to show the following proposition:
%
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st (0 \leq n \leq m )
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
\]
%
 Let $\event_b = (b, l_b, n_b, v_b)$, by {Inversion Lemma~\ref{lem:inv_test}},
we know $\exists \vtrace_2, \vtrace_2', {c}_1, {c}_2$
 \[
  \begin{array}{l}   
  \config{{c}, \vtrace_0} 
  \rightarrow^{*} 
  \config{[\assign{{x}_1}{\expr_1~ or ~ \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \vtrace_1}  \rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
  \\ 
  \qquad \rightarrow^{*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; {c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1 \vtrace_b} 
  \rightarrow^{if-b / while-b} 
  \config{{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1 \vtrace_b \cdot \event_b} 
\end{array} ~ (3)
 \]
and 
 \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; {c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1' \vtrace_b'} 
  \rightarrow^{if-b / while-b} 
  \config{{c}_3',  \vtrace_0 \vtrace_1 \cdot \event_1' \vtrace_b' \cdot \event_b'} 
  ~(4)
 \]
 %
 %
 \caseL{$m = 0$}
 By execution $(3)$ and $(4)$, we have:
\[
  \begin{array}{l}   
  \config{{c}, \vtrace_0} 
  \rightarrow^{*} 
  \config{[\assign{{x}_1}{\expr_1~ or ~ \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \vtrace_1}  \rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; {c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{if / while} 
  \config{{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_b} 
\end{array}
 \]
and 
 \[
  \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; {c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1 \vtrace_2'} 
  \rightarrow^{if / while} 
  \config{{c}_2,  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_b'} 
 \]
 By definition of environment, we have:
\[
  \forall u \in \lvar_c \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event'') (u) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event') (u)
\]
%
By {Inversion Lemma~\ref{lem:inv_b}} of boolean expression evaluation, we have since $x$ is the only variable has different value, $x$ can only be in the $VAR(b)$ in order to change value of $\event_b$, i.e.,
 \[
  x_1^{l_1} \in VAR(b)
 \]
 %
 By {Inversion Lemma~\ref{lem:inv_ctltoevent2}}, we know $\event_2$ is generated from the either $c^1$, $c^2$ or $c'$.
 By definition of $\flowsto$, we know
 \[
 \forall z \in VAR(b), \flowsto(z, x_2^{l2})
 \]
 Then, we have
 \[
 \flowsto(x_1^{l_1}, x_2^{l_2})
 \]
 i.e.,
 \[
 \Big( \exists z_1, \cdots, z_n \in \lvar_{{c}}. ~ 0 \leq n \leq 0 \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
 \]
 This case is proved.
%
 \caseL{$m = 1$}
 %
 Let $\vtrace_2 = \cdot \event^2 \cdot$, there are 2 sub cases: 
 \[
 \event' \in \eventset^{\test} \lor \event' \in \eventset^{\asn}
 \]
 %
 This case is proved by splitting the 2 sub cases.
 %
 \subcaseL{$\event^2 \in \eventset^{\test}$}
  %
By execution $(3)$ and $(4)$, and {Inversion Lemma~\ref{lem:inv_test}}, we have:
%
\[
  \begin{array}{l}   
  \config{{c}, \vtrace_0} 
  \rightarrow^{*} 
  \config{[\assign{{x}_1}{\expr_1~ or ~ \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \vtrace_1}  \rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif([b_2]{}^{l_{b_2}}, c^3, c^4) / \ewhile [b_2]{}^{l_{b_2}} \edo c^5; {c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{if / while} 
  \config{{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event^2} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; {c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1\cdot \event^2} 
  \rightarrow^{if / while} 
  \config{{c}_4,  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event^2 \cdot \event_b} 
\end{array}
 \]
and 
 \[
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1'} 
 \rightarrow^{\eskip^*} 
  \config{\eif([b_2]{}^{l_{b_2}}, c^3, c^4) / \ewhile [b_2]{}^{l_{b_2}} \edo c^5; {c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{if / while} 
  \config{{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event^3} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; {c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event^3} 
  \rightarrow^{if / while} 
  \config{{c}_4,  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event^3 \cdot \event_b'} 
\end{array}
 \]
 By definition of environment, we have:
\[
  \forall u \in \lvar_c \setminus \{x_1^{l_1}, z^{l'}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event^3) (u) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event^2) (u)
\]
%
By {Inversion Lemma~\ref{lem:inv_b}} of boolean expression evaluation, we have since $x$ is the only variable has different value, $x$ can only be in the $VAR(b)$ in order to change value of $\event_b$, i.e.,
 \[
  x_1^{l_1} \in VAR(b)
 \]
 %
 Since $\event_2$ is generated from the either $c^1$, $c^2$ or $c'$ by {Inversion Lemma~\ref{lem:inv_ctltoevent2}}
 By definition of $\flowsto$, we know
 \[
 \forall z \in VAR(b), \flowsto(z, x_2^{l2})
 \]
 Then, we have
 \[
 \flowsto(x_1^{l_1}, x_2^{l_2})
 \]
 i.e.,
 \[
 \Big( \exists z_1, \cdots, z_n \in \lvar_{{c}}. ~ 0 \leq n \leq 1 \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
 \]
  This case is proved.
%
\subcaseL{$\event_3 \in \eventset^{\asn}$}
Let $\event_3 = (z, l_3, n_3, v_3)$ or $\event_3 = (z, l_3, n_3, \qval_3, v_3)$, there are 2 cases:
$\eventdep^{val}(\event_1, \event', c D)$ or $\neg \eventdep^{val}(\event_1, \event', c D)$
%
\subsubcaseL{$\eventdep^{val}(\event_1, \event', c D)$}
%
By conclusion from \textbf{case: $\eventdep^{val}(\event_1, \event_2, c, D)$ and $m = 0$}, we know
\[
  \flowsto(x_1^{l_1}, z^{l_3})
\]
%
By execution $(3)$ and $(4)$, we have:
\[
  \begin{array}{l}   
  \config{{c}, \vtrace_0} 
  \rightarrow^{*} 
  \config{[\assign{{x}_1}{\expr_1~ or ~ \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \vtrace_1}  \rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{[\assign{z}{\expr_3~ or ~ \query(\qexpr_3)}]^{l_3}; {c}_2', 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{assn / query} 
  \config{{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_3} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; {c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_3} 
  \rightarrow^{if / while} 
  \config{{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_3 \cdot \event_b} 
\end{array}
 \]
and 
 \[
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{z}{\expr_3~ or ~ \query(\qexpr_3)}]^{l_3}; {c}_2', 
  \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn / query} 
  \config{{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_3'} 
  \\ 
  \qquad \rightarrow^{\eskip^*} 
  \config{\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; {c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_3'} 
  \rightarrow^{if / while} 
  \config{{c}_3,  \vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_3' \cdot \event_b'} 
\end{array}
 \]
 By definition of environment, we have:
\[
  \forall u \in \lvar_c \setminus \{x_1^{l_1}, z^{l'}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_3 ) (u) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_3') (u)
\]
%
By {Inversion Lemma~\ref{lem:inv_b}} of boolean expression evaluation, we have since $x$ is the only variable has different value, $x$ can only be in the $VAR(b)$ in order to change value of $\event_b$, i.e.,
 \[
  x_1^{l_1} \in VAR(b) \lor z \in VAR(b)
 \]
 %
 By {Inversion Lemma~\ref{lem:inv_ctltoevent2}}, we know $\event_2$ is generated from the either $c^1$, $c^2$ or $c'$.
 By definition of $\flowsto$, we know
 \[
 \forall u \in VAR(b), \flowsto(u, x_2^{l2})
 \]
 Then, we have
 \[
  \flowsto(x_1^{l_1}, x_2^{l_2}) \lor 
  \big(\flowsto(x_1^{l_1}, z) \land \flowsto(z, x_2^{l_2}) \big)
 \]
 i.e.,
 \[
 \Big( \exists z_1, \cdots, z_n \in \lvar_{{c}}. ~ 0 \leq n \leq 0 \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
 \]
 This case is proved.
%
%
\subsubcaseL{$\neg \eventdep^{val}(\event_1, \event', c D)$}
By $\neg \eventdep^{val}(\event_1, \event', c D)$ and the definition of environment, we have:
\[
  \forall u \in \lvar_c \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_3 ) (u) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_3') (u)
\]
in execution $(3)$ and $(4)$.
%
Then, we know by conclusion from the case $m = 0$:
\[
  x_1^{l_1} \in VAR(b)
\]
%
By Definition of $\flowsto$, we know
\[
  \flowsto(x_1^{l_1}, x_2^{l_2}) 
\]
this case is proved.
%
In conclusion, we have:
\[
  \Big( \exists z_1, \cdots, z_n \in \lvar_{{c}}. ~ 0 \leq n \leq 1 \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
\]
The case $m = 1$ is proved.
%
\caseL{$m = n + 1, n \geq 0$}
By induction hypothesis on $n$ and $\vardep(x_1^{l_1}, x_2^{l_2}, c, D)$, 
$\vardep(x_1^{l_1}, z_1^{r_1}, c, D) \land \vardep(z^{l_z}, x_2^{l_2}, c, D)$ respectively, 
we have $\exists z_2^{r_2}, \cdots, z_n^{r_2}, 1 \leq n \leq m'+1$ s.t.:
\[
\begin{array}{ll}
      & \flowsto(x_1^{l_1}, x_2^{l_2}) \\
  \lor  & \flowsto(x_1^{l_1}, z_2^{r_2}) \land \flowsto(z_2^{r_2}, x_2^{l_2})\\
  \lor  & \flowsto(x_1^{l_1}, z_2^{r_2}) \land \flowsto(z_2^{r_2}, z_1^{r_1}) \land \flowsto(z_1^{r_1}, x_2^{l_2}) \\
  \lor  & \flowsto(x_1^{l_1}, z_1^{r_1}) \land \flowsto(z_1^{r_1}, z_2^{r_2}) \land \flowsto(z_2^{r_2}, x_2^{l_2}) \\
  \lor  & \cdots \\
  \lor  & \flowsto(x_1^{l_1}, z_2^{r_2}) \land \cdots \land \flowsto(z_n^{r_n}, z_1^{r_1}) \land \flowsto(z_1^{r_1}, x_2^{l_2}) \\
\end{array}
\]This case is proved.
\end{proof}}