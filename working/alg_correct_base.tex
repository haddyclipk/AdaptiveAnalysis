\begin{subproof}
 \todo{change notation for trace}
\label{pf:alg_correct_base}
\\
Unfolding $\eventdep^{val}(\event_1, \event_2, [\event_1; \event_2], c, D)$, 
\begin{equation}
\label{eq:eventdep_def_base}
\exists \vtrace_0,
\vtrace_1, \vtrace' \in \mathcal{T}, \event_2' \in \eventset, \event_1' \in \eventset^{\asn}, {c}_1, {c}_2,  {c}_2' \in \cdom \st
  \left(
  \begin{array}{ll}   
 & \config{{c}, \vtrace_0} \rightarrow^{*} 
\config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
  \config{{c}_2,  \vtrace_1 [\event_1; \event_2] } 
  % 
 \\ 
 \bigwedge &
  \config{{c}_1, \vtrace_1 \tracecat [\event_1]'}  \rightarrow^{*} 
  \config{{c}_2,  \vtrace_1 \tracecat [\event_1']\tracecat \vtrace' \tracecat [\event_2'] } 
\\
\bigwedge &  \pi_1(\event_1) = \pi_1(\event_1') \land \pi_2(\event_1) = \pi_2(\event_1') 
\\
\bigwedge & 
\diff(\event_2,\event_2' ) \land 
\vcounter(\vtrace) ~ \pi_2(\event_2)
= 
\vcounter(\vtrace') ~ \pi_2(\event_2)\\
\end{array}
\right)
\end{equation}
%
Let $\vtrace_0,
\vtrace_1, \vtrace' \in \mathcal{T}, \event_2' \in \eventset, \event_1' \in \eventset^{\asn}, {c}_1, {c}_2,  {c}_2'$ be the traces, events and commands satisfying the executions and restrictions in Eq.~\ref{eq:eventdep_def_base}.
\\
By Inversion Lemma~\ref{lem:inv_event} on 
 $\event_1$, $\event_2$ and the first execution in Eq.~\ref{eq:eventdep_def_base},
 %
 we know $\exists \expr_1$ or $\qexpr_1$, $\exists \expr_2$ or $\qexpr_2$ and following instance of execution:
%
\footnote{
$\assign{x}{\expr / \query(\qexpr)}$ denotes variable $x$ is assigned by either an expression $\expr$ or query $\query(\qexpr)$
}
 %
\begin{equation}
\label{eq:valdep_inv1}
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{x_1}{\expr_1 / \query(\qexpr_1)}]^{\pi_2(\event_1)} ; {c}_1, \vtrace_0 \cdot \vtrace_1}  
\rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]} \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 [\event_1; \event_2]} 
  % 
\end{array}
\end{equation}
%
% \wqside{Some typo in equation 4, but I can follow:-)}
% \jl{thanks}
, where $x_1 = \pi_1(\event_1)$, $l_1 = {\pi_2(\event_1)}$, $x_2 = \pi_1(\event_2)$ and $l_2 = \pi_2(\event_2)$.
%
By Inversion Lemma~\ref{lem:inv_event} on 
$\event_2'$ and the second execution in Eq.~\ref{eq:eventdep_def_base},
% \[
% \config{{c}_1, \vtrace_1 \tracecat [\event_1]'}  \rightarrow^{*} 
%   \config{{c}_2',  \vtrace_1 \tracecat [\event_1']\cdot \vtrace_2' \tracecat [\event_2'] } 
%   \], 
we know there exists $\expr_2'$ or $\qexpr_2'$ and following execution instance,
 \[
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]'} 
  \rightarrow^{*} 
  \config{[\assign{{x}_2'}{\expr_2' / \query(\qexpr_2')}]^{l_2'} ; {c}_2', \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1']\cdot \vtrace'} 
  \rightarrow^{assn/query} 
  \config{{c}_2',  \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1']\cdot \vtrace' \tracecat [\event_2']} 
  % 
\end{array}
 \]
 , where  $x_2' = \pi_1(\event_2')$ and $l_2' = \pi_2(\event_2')$.
%
Unfolding $\diff(\event_2,\event_2')$, we have:
\[
  x_2 = x_2' \land l_2 = l_2' 
\] 
%
Since each command in $c$ has an unique label, we have $\expr_2' = \expr_2$, $\qexpr_2 = \qexpr_2'$, and following execution instance:
\begin{equation}
\label{eq:valdep_inv2}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]'} 
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1']\cdot \vtrace_2'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1']\cdot \vtrace_2' \tracecat [\event_2']} 
\end{equation}
%
From Eq.~\ref{eq:eventdep_def_base}, we also have
\begin{equation}
\label{eq:valdep_invn}
  \vcounter(\vtrace') l_2 = \vcounter( \cdot ) l_2 = 0
\end{equation}
%
%
By Induction on the operational semantics rules on following execution from Eq.~\ref{eq:valdep_inv1}: 
% \wqside{Surprised we do induction here:-)}
 %
 \[\config{c_1, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]}
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]} 
\]
 %
By Inversion Lemma~\ref{lem:inv_skip}, we know:
 \[
 c_1 =_c 
 [\eskip]{}^*;[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2
 \]
 %
By substituting $c_1$ in Eq.~\ref{eq:valdep_inv2}, the following subproof shows there is only 1 possible execution instance of Eq.~\ref{eq:valdep_inv2}.
\begin{subproof}[Subproof]
\label{pf:noiteration_inv2}
There are two possible cases, 
where $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$ 
or $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_2$.
%
\begin{enumerate}
\item{$[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2}\notin_c c_2$}
\\
In this case, we have the following execution instance:
%
\footnote{$\rightarrow^{\eskip^*}$ denotes every evaluation step in this execution is an evaluation of the $[\eskip]{}^*$ command}
 %
  \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \tracecat \vtrace_1 \tracecat [\event_1'; \event_2']} 
 \]
%
\item{$[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$}
\\
By Inversion Lemma~\ref{lem:inv_while}, 
we pick $(\ewhile [b_w]^l_w \edo c_w)$ 
as the while command such that
$(\ewhile [b_w]^l_w \edo c_w) \in_c c_2$ and 
$[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w$.
\\
Then, we have the following possible execution instances:
 %
  \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1']\cdot (x_2, l_2, n_2', v_2')} 
 \]
%
  \[
  \begin{array}{l}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1']\cdot (x_2, l_2, n_2', v_2')} 
  \\ \qquad
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, 
  \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1']\cdot (x_2, l_2, v_2') \cdot \trace_3} 
  \\ \qquad
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1']\cdot (x_2, l_2, n_2', v_2') \cdot \trace_3 \cdot (x_2, l_2, n_2'', v_2'')} 
 \end{array}
 \]
\[
  \cdots
\] 
by iterating the $(\ewhile [b_w]^l_w \edo c_w)$ in $c_2$ $0$ or more times.
%
\\
%
For each execution instance, we have the corresponding instance of $\trace'$ as follows:
\\
$\trace'  = \cdot$
\\
$\trace' = \cdot (x_2, l_2, n_2', v_2') \cdot \trace_3 $
%
\\
$\cdots$
%
\\
%
By Eq.~\ref{eq:valdep_invn}, we know:
%
\[
 \vcounter(\trace') l_2 = 0
\]
%
Only the first execution with 0 iteration of while body in $c_2$ satisfy this restriction, i.e., $\trace' = \cdot$ and $\event_2' = (x_2, l_2, n_2', v_2')$
%
\end{enumerate}
In conclusion, we have the only qualified execution instance as follows where $\trace_2' = \cdot$.
  \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \tracecat [\event_1']\cdot (x_2, l_2, n_2', v_2')} 
 \]
\end{subproof}
%
Then we know the environment only able to obtain different values for variable $x_1$ 
from trace $\vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]$ and 
$\vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]'$, i.e.,
\[
  \forall z^r \in \lvar_c \setminus \{x_1^{l_1}\} ,
  \env(\vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]) (z) =  
  \env(\vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]') (z)
\]
%
By {Inversion Lemma~\ref{lem:inv_expr}} of arithmetic expression evaluation, we have
\[
  x_1 \in VAR(\expr_2 / \qexpr_2) 
\]
Since $\llabel(\vtrace_0 \cdot \vtrace_1 \tracecat [\event_1]) x_1 = l_1$, by Inversion Lemma~\ref{lem:inv_live} we know $x_1^{l_1} \in \live^{l_2}(c)$.
%
\\
%
By $\flowsto$ definition, we have:
%
\[
\flowsto(x_1^{l_1}, {x}_2^{l_2}, c)
\]
i.e.,
%
\[
\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)
 \]
%
This case is proved.
\end{subproof}