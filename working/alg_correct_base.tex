\begin{subproof}[Subproof of Case~\ref{case:alg_correct_base}].
\label{pf:alg_correct_base}
\\
Unfolding $\eventdep^{val}_{\trace}(\event_1, \event_2, \cdot, c, D)$, we have:
\[
\exists \vtrace_0,
\vtrace_1, \vtrace_2' \in \mathcal{T}, \event_2' \in \eventset, \event_1' \in \eventset^{\asn}, {c}_1, {c}_2,  {c}_2'.
  \left(
  \begin{array}{ll}   
 & \config{{c}, \vtrace_0} \rightarrow^{*} 
\config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{{c}_2,  \vtrace_1 \cdot \event_1 \cdot \event_2 } 
  % 
 \\ 
 \bigwedge &
  \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{{c}_2',  \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2' } 
\\
\bigwedge &  \pi_1(\event_1) = \pi_1(\event_2) \land \pi_2(\event_1) = \pi_2(\event_2) \\
\bigwedge & l_1 = \pi_2(\event_1) \land l_2 = \pi_2(\event_2)
\land \vcounter(\vtrace_1 \cdot \event_1) l_1 = \vcounter(\vtrace_1 \cdot \event_1')l_1 
\\
\bigwedge & 
\diff(\event_2,\event_2' ) \land 
\vcounter(\vtrace_1 \cdot \event_1 \cdot \event_2) l_2
= 
\vcounter(\vtrace_1 \cdot \event_1' \cdot \vtrace_2'\cdot \event_2') l_2\\
\end{array}
\right)
\]
By Inversion Lemma~\ref{lem:inv_asn} on 
 $\event_1$, $\event_2$ and following execution from $\eventdep^{val}_{\trace}(\event_1, \event_2, \cdot, c, D)$:
 %
 \[
 \config{{c}, \vtrace_0} \rightarrow^{*} 
\config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{{c}_2,  \vtrace_1 \cdot \event_1 \cdot \event_2 } 
 \]
 %
 we know $\exists \expr_1$ or $\qexpr_1$, $\exists \expr_2$ or $\qexpr_2$ and following instance of execution:
 \\
 \todo{notation $\assign{x}{\expr / \query(\qexpr)}$ denotes variable $x$ is assigned by either an expression $\expr$ or query $\query(\qexpr)$}
 %
\begin{equation}
\label{eq:valdep_inv1}
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \cdot \vtrace_1}  
\rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_2} 
  % 
\end{array}
\end{equation}
%
%
By Inversion Lemma~\ref{lem:inv_asn} on 
$\event_2'$ and following execution from $\eventdep^{val}_{\trace}(\event_1, \event_2, \cdot, c, D)$,
\[
\config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{{c}_2',  \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2' } 
  \], we know $\exists \expr_2'$ or $\qexpr_2'$
 \[
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{[\assign{{x}_2'}{\expr_2' / \query(\qexpr_2')}]^{l_2'} ; {c}_2', \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \vtrace_2'} 
  \rightarrow^{assn/query} 
  \config{{c}_2',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2'} 
  % 
\end{array}
 \]
%
Unfolding $\diff(\event_2,\event_2')$, we have:
\[
  x_2 = x_2' \land l_2 = l_2' 
\] 
%
Then, we have:
\begin{equation}
\label{eq:valdep_inv2}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2' / \query(\qexpr_2')}]^{l_2} ; {c}_2', \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \vtrace_2'} 
  \rightarrow^{assn/query} 
  \config{{c}_2',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2'} 
\end{equation}
%
From the $\eventdep^{val}_{\trace}(\event_1, \event_2, \cdot, c, D)$ definition, we also have:
\[
  \vcounter(\vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_2) l_2 = 
  \vcounter(\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2') l_2'
  \land 
  \pi_2(\event_1) = \pi_2(\event_1')
\] 
Then, we have:
\begin{equation}
\label{eq:valdep_invn}
  \vcounter(\vtrace_2') l_2 = 0
\end{equation}
%
 %
%
%
 By Induction on the operational semantics rules on following execution from Eq.~\ref{eq:valdep_inv1}:
 %
 \[\config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1}
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1} \]
 %
 we know by  \todo{Inversion Lemma: no event generated, iff the program is $\eskip$}, \todo{notation $[\eskip]{}^*$}:
 \[
 c_1 =_c 
 [\eskip]{}^*;[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2
 \]
 %
 %
The following subproof shows there is only 1 possible execution instance of Eq.~\ref{eq:valdep_inv2}.
\begin{subproof}[Subproof]
\label{pf:noiteration_inv2}
There are two possible cases, 
where $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$ 
or $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_2$.
%
\begin{enumerate}
\item{$[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2}\notin_c c_2$}
\\
By substituting $c_1$ in the execution in Eq.~\ref{eq:valdep_inv2}, we have 
\todo{notation $\rightarrow^{\eskip^*}$ denotes evaluations of $\eskip$ command 0 for more times}
 %
  \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_2'} 
 \]
%
\item{$[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$}
\\
\todo{Inversion lemma}, it must be in a while body.
\\
 By substituting $c_1$ in the execution in Eq.~\ref{eq:valdep_inv2}, we have following possible execution instances:
 %
  \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, n_2', v_2')} 
 \]
%
  \[
  \begin{array}{l}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, n_2', v_2')} 
  \\ \qquad
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, v_2') \cdot \trace_3} 
  \\ \qquad
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, n_2', v_2') \cdot \trace_3 \cdot (x_2, l_2, n_2'', v_2'')} 
 \end{array}
 \]
\[
  \cdots
\] 
with iterations of the while body in $c_2$ $0$ or more times.
%
\\
%
For each execution instance, we have the corresponding instance of $\trace_2'$ as follows:
\\
  $\trace_2'  = \cdot$
\\
$\trace_2' = \cdot (x_2, l_2, n_2', v_2') \cdot \trace_3 $
%
\\
$\cdots$
%
\\
%
By Eq.~\ref{eq:valdep_invn}, we know:
%
\[
 \vcounter(\trace_2') l_2 = 0
\]
%
Only the first execution with 0 iteration of while body in $c_2$ satisfy this restriction, i.e., $\trace_2' = \cdot$ and $\event_2' = (x_2, l_2, n_2', v_2')$
%
\end{enumerate}
In conclusion, we have the execution instance of \ref{eq:valdep_inv2}  as follows and $\trace_2' = \cdot$.
  \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, n_2', v_2')} 
 \]
\end{subproof}
%
By $\eventdep^{val}(\event_1, \event_2, c)$, and definition of environment, 
the environment only able to obtain different values for variable $x_1$ 
from trace $\vtrace_0 \cdot \vtrace_1 \cdot \event_1$ and 
$\vtrace_0 \cdot \vtrace_1 \cdot \event_1'$, i.e.,
\[
  \forall z^r \in \lvar_c \setminus \{x_1^{l_1}\} ,
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1) (z) =  
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1') (z)
\]
%
By {Inversion Lemma~\ref{lem:inv_a}} of arithmetic expression evaluation, and Inversion Lemma~\ref{lem:inv_live}, we have 
\[
  x_1 \in VAR(\expr_2 / \qexpr_2) 
  \land x_1^{l_1} \in \live^{l_2}(c)
\]
%
By $\flowsto$ definition, we have:
%
\[
\flowsto(x_1^{l_1}, {x}_2^{l_2}, c)
\]
i.e.,
%
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st (0 \leq n )
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
 \]
%
This case is proved.
\end{subproof}