\clearpage
\section{Labeled SSA Language}
%
%
\subsection{SSA form Language}
\[
\begin{array}{llll}
 \mbox{Arithmetic Operators} 
& \oplus_a & ::= & + ~|~ - ~|~ \times 
%
~|~ \div \\  
\mbox{Boolean Operators} 
& \oplus_b & ::= & \lor ~|~ \land
\\
  %
\mbox{Relational Operators} 
& \sim & ::= & < ~|~ \leq ~|~ == 
\\  
%
\mbox{Label} 
& l & := & \mathbb{N} 
\\ 
%
\mbox{SSA Arithmetic Expression} 
& \saexpr & ::= & 
n ~|~ \ssa{x} ~|~ \saexpr \oplus_a \saexpr  
\\
%
\mbox{SSA Boolean Expression} & \sbexpr & ::= & 
	%
	\etrue ~|~ \efalse  ~|~ \neg \sbexpr
	 ~|~ \sbexpr \oplus_b \sbexpr
	%
	~|~ \saexpr \sim \saexpr 
	\\
%
\mbox{SSA Query Expression} 
& \ssa{\qexpr} & ::= 
& { \qval ~|~ \saexpr ~|~ \qexpr \oplus_a \qexpr} 
\\
%
\mbox{Query Value} & \qval & ::= 
& {n ~|~ \chi[n] ~|~ \chi[n] \oplus_a  \chi[n] ~|~ n \oplus_a  \chi[n]
~|~ \chi[n] \oplus_a  n}
\\
%
\mbox{Value} 
& v & ::= & { n \sep \etrue \sep \efalse ~|~ [] ~|~ [v, \dots, v]}  
\\
%
\mbox{SSA Expression} & \sexpr & ::= & v ~|~ \saexpr \sep \sbexpr ~|~ [\expr, \dots, \expr]
\\	
%
\mbox{Labeled SSA Command} 
& \ssa{c} & ::= &   [\assign {\ssa{x}}{ \ssa{\expr}}]^{l} ~|~  [\assign {\ssa{x} } {\ssa{\query(\qexpr)}}]^{l}
%
~|~  {{\eifvar(\bar{\ssa{x}}, \bar{\ssa{x}}')}} 
%
\\ 
&&& 
{\ewhile ~ [ \sbexpr ]^{l} , n,
~ 
[\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}] 
~ \edo ~  \ssa{c} }
\\
&&&
~|~ \ssa{c};\ssa{c}  
~|~ [\eif(\sbexpr, [\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}] , \ssa{c}, \ssa{c})]^l 
~|~ [\eskip]^{l} 
\\
%
\mbox{Event} 
& \event & ::= & 
      (\ssa{x}, l, n, v)   \mbox{Assignment Event} \\
&&& | (\ssa{x}, l, n, \qval, v) \\
&&& | (\sbexpr, l, n, v) \mbox{Testing Event}
\\
%
\mbox{Trace} & \vtrace
& ::= & | \vtrace \cdot \event
\\
%
\mbox{Event Signature} & \sig
& ::= & (x, l, n) | (x, l, n, \query) | (b, l, n)
% \\
% %
% \mbox{Environment} 
% & \env & ::= & \vtrace \to \mathcal{SVAR} \to v \cup \{\bot\}
% \\
% %
% \mbox{Query Environment} 
% & \qenv & ::= & \vtrace \to \mathcal{SVAR} \to \qval \cup \{\bot\}
\end{array}
\]
We use following notations to represent the set of corresponding terms:
\[
\begin{array}{lll}
\mathcal{SVAR} & : & \mbox{Set of Variables}  
\\ 
%
\mathcal{VAL} & : & \mbox{Set of Values} 
\\ 
%
%
\eventset  & : & \mbox{Set of Events}  
\\
%
%
\eventset^{\asn}  & : & \mbox{Set of Assignment Events}  
\\
%
\eventset^{\test}  & : & \mbox{Set of Testing Events}  
\\
%
%
\eventset  & : & \mbox{Set of Events}  
\\
%
\dbdom  & : & \mbox{{Set of Databases}} 
\\
%
\qdom = {[-1,1]} & : & \mbox{{Domain of Query Results}}
\end{array}
\]
%
%
%
Environment $ \env : \vtrace \to \mathcal{SVAR} \to \mathcal{VAL} \cup \{\bot\}$
\[
\begin{array}{ll}
\env(\vtrace \cdot (x, l, n, v)) x \triangleq v
&
\env(\vtrace \cdot (x, l, n, \qval, v)) x \triangleq v
\\
\env(\vtrace \cdot (y, l, n, v)) x \triangleq \env(\vtrace) x
&
\env() x \triangleq \bot
\end{array}
\]
%
%
Query Environment $\qenv: \vtrace \to \mathcal{SVAR} \to \qval \cup \{\bot\}$
\[
\begin{array}{ll}
\qenv(\vtrace \cdot (x, l, n, v)) x \triangleq \qenv(\vtrace) x
&
\qenv(\vtrace \cdot (x, l, n, \qval, v)) x \triangleq \qval
\\
\qenv(\vtrace \cdot (y, l, n, v)) x \triangleq \qenv(\vtrace) x
&
\qenv() x \triangleq \bot
\end{array}
\]
%
Counter $\vcounter : \trace \to \mathbb{N} \to \mathbb{N}$
\[
\begin{array}{ll}
\vcounter(\vtrace \cdot (x, l, n, v)) l \triangleq n
&
\vcounter() l \triangleq 0
\end{array}
\]
%
\subsection{Trace-based Operational Semantics for SSA Language}
%
%
%
{
\begin{mathpar}
\boxed{ \config{\trace,\aexpr} \aarrow v \, : \, Trace  \times AExpr \Rightarrow Value }
\\
\boxed{ \config{\trace, \bexpr} \barrow v \, : \, Trace \times BExpr \Rightarrow Value }
\\
\boxed{ \config{\trace, \qexpr} \qarrow \qval \, : \, Trace  \times QExpr \qarrow QValue }
  \\
  \inferrule{ 
    \config{\trace, \qexpr_1} \qarrow \qval_1
    \and
    \config{m, \qexpr_2} \qarrow \qval_2
  }{
   \config{\trace,  \qexpr_1 \oplus_a \qexpr_2} 
   \qarrow n'
  }
  \and
  \inferrule{ 
    \config{m, \aexpr} \aarrow v
  }{
   \config{m,  \chi[\aexpr]} \qarrow \chi[v]
  }
  \end{mathpar}
%
The trace based operational semantics are defined in Figure \ref{fig:os_ssa}.
%
\begin{figure}
\jl{
  \begin{mathpar}
  \boxed{
  Command \times Trace
  \xrightarrow{}
  Command \times Trace
  }
  \\
  \boxed{\config{\ssa{c, \vtrace}}
  \xrightarrow{} 
  \config{\ssa{c',  \vtrace'}}
  }
  \\
  %
  \inferrule
  {
  \event = (\ssa{x}, l, \vcounter(\vtrace) l + 1, v)
  }
  {
  \config{[\assign{\ssa{x}}{\saexpr}]^{l},  \vtrace } 
  \xrightarrow{} 
  \config{[\eskip]^{l}, \vtrace \cdot \event}
  }
  ~\textbf{assn}
  %
  \and
  %
  \inferrule
  {
   \vtrace, b \barrow \etrue
   \and 
   \event = (b, l, \vcounter(\vtrace) l + 1, \etrue)
  }
  {
  \config{\ssa{\ewhile ~ [b]^{l}, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}] ~ \edo ~ c, \vtrace}}
  \\
  \xrightarrow{} 
  \config{\ssa{
  c[\bar{x_i}/\bar{x'}]; \ewhile ~ [b]^{l}, (n + 1), [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}]  ~ \edo ~ c,  \eskip),
  \vtrace\cdot \event}}
  }
  ~\textbf{ssa-while-t}
  %
  %
    \and
  %
  \inferrule
  {
   \vtrace, b \barrow \efalse
   \and 
   \event = (b, l, \vcounter(\vtrace) l + 1, \efalse)
  }
  {
  \config{\ssa{\ewhile ~ [b]^{l}, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}] ~ \edo ~ c, \vtrace}}
  \\
  \xrightarrow{} 
  \config{\ssa{
  [\eskip]^l ,
  \vtrace \cdot \event}}
  }
  ~\textbf{ssa-while-f}
  %
  \and
  %
  {
  \inferrule
  {
   \vtrace, \qexpr \qarrow \qval
   \and 
  \query(\qval) = v
  \and 
  \event = (\ssa{x}, l, \vcounter(\vtrace) l + 1, \qval, v)
  }
  {
  \config{\ssa{[\assign{x}{\query(\qexpr)}]^l, \vtrace}}
  \xrightarrow{} 
  \config{\ssa{\eskip,  \vtrace \cdot \event} }
  }
  ~\textbf{ssa-query}
  }
  %
  \and
  %
  %
  \inferrule
  {
  \config{\ssa{c_1, \vtrace}}
  \xrightarrow{}
  \config{\ssa{c_1',  \vtrace'}}
  }
  {
  \config{\ssa{c_1; c_2, \vtrace}} 
  \xrightarrow{} 
  \config{\ssa{c_1'; c_2, \vtrace'}}
  }
  ~\textbf{ssa-seq1}
  %
  ~~~~~~~
  %
  \inferrule
  {
    \config{\ssa{c_2, \vtrace}}
  \xrightarrow{}
  \config{\ssa{c_2',  \vtrace'}}
  }
  {
  \config{\ssa{[\eskip]^{l} ; c_2, \vtrace}} \xrightarrow{} \config{\ssa{ c_2', \vtrace'}}
  }
  ~\textbf{ssa-seq2}
  %
  \and
  %
  %
  \inferrule
  {
     \vtrace, b \barrow \etrue
   \and 
   \event = (b, l, \vcounter(\vtrace) l + 1, \etrue)
  }
  {
  \config{\ssa{
  \eif([\etrue]^{l}, [\bar{{x}}, \bar{{x_1}}, \bar{{x_2}}],
  [\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}],
  [\bar{\ssa{z}},\bar{\ssa{z_1}}, \bar{\ssa{z_2}}], c_1, c_2), 
  \vtrace}}
  \\
  \xrightarrow{} 
  \config{\ssa{ 
  c_1; 
  \eifvar(\bar{\ssa{x}},\bar{\ssa{x_2}}); 
  \eifvar(\bar{\ssa{y}},\bar{\ssa{y_1}});
  \eifvar(\bar{\ssa{z}},\bar{\ssa{z_2}}), 
  \vtrace \cdot \event}}
  }
  ~\textbf{ssa-if-t}
  %
  \and
  %
  \inferrule
  {
   \vtrace, b \barrow \efalse
   \and 
   \event = (b, l, \vcounter(\vtrace) l + 1, \efalse)
  }
  {
  \config{\ssa{
  \eif([\efalse]^{l},[\bar{{x}}, \bar{{x_1}}, \bar{{x_2}}],
  [\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}],
  [\bar{\ssa{z}},\bar{\ssa{z_1}}, \bar{\ssa{z_2}}], c_1, c_2), \vtrace}}
  \\
  \xrightarrow{} 
  \config{\ssa{
  c_2;
  \eifvar(\bar{\ssa{x}},\bar{\ssa{x_2}}); 
  \eifvar(\bar{\ssa{y}},\bar{\ssa{y_1}});
  \eifvar(\bar{\ssa{z}},\bar{\ssa{z_2}}), 
  \vtrace \cdot \event}}
  }
  ~\textbf{ssa-if-f}
  %
  \and
  %
  \inferrule
  {
  }
  {
   \config{\eifvar(\ssa{\bar{x}, \bar{x}'}), \ssa{\vtrace}} 
   \to 
   \config{\ssa{\eskip, \vtrace}}
  }~\textbf{ssa-\eifvar}
  % %
  %
  %
  \end{mathpar}
}
  % \end{subfigure}
      \caption{Trace-based Operational Semantics for SSA Language.}
      \label{fig:os_ssa}
  \end{figure}
  %
%
%
%
%
%
%
\clearpage
%
%
% \subsection{SSA Transformation and Soundness of Transformation}
% in File {\tt ``ssa\_transform\_sound.tex''}
% \input{ssa_transform_sound}
%
\clearpage