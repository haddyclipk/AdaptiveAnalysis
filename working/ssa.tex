\section{Labeled SSA Language}
%
%
\subsection{SSA form Language}
\[
\begin{array}{llll}
 \mbox{Arithmetic Operators} 
& \oplus_a & ::= & + ~|~ - ~|~ \times 
%
~|~ \div \\  
\mbox{Boolean Operators} 
& \oplus_b & ::= & \lor ~|~ \land
\\
  %
\mbox{Relational Operators} 
& \sim & ::= & < ~|~ \leq ~|~ == 
\\  
%
\mbox{Label} 
& l & := & \mathbb{N} 
\\ 
%
\mbox{SSA Arithmetic Expression} 
& \saexpr & ::= & 
n ~|~ \ssa{x} ~|~ \saexpr \oplus_a \saexpr  
\\
%
\mbox{SSA Boolean Expression} & \sbexpr & ::= & 
	%
	\etrue ~|~ \efalse  ~|~ \neg \sbexpr
	 ~|~ \sbexpr \oplus_b \sbexpr
	%
	~|~ \saexpr \sim \saexpr 
	\\
%
\mbox{SSA Query Expression} 
& \ssa{\qexpr} & ::= 
& { \qval ~|~ \saexpr ~|~ \qexpr \oplus_a \qexpr} 
\\
%
\mbox{Query Value} & \qval & ::= 
& {n ~|~ \chi[n] ~|~ \chi[n] \oplus_a  \chi[n] ~|~ n \oplus_a  \chi[n]
~|~ \chi[n] \oplus_a  n}
\\
%
\mbox{Value} 
& v & ::= & { n \sep \etrue \sep \efalse ~|~ [] ~|~ [v, \dots, v]}  
\\
%
\mbox{SSA Expression} & \sexpr & ::= & v ~|~ \saexpr \sep \sbexpr ~|~ [\expr, \dots, \expr]
\\	
%
\mbox{Labeled SSA Command} 
& \ssa{c} & ::= &   [\assign {\ssa{x}}{ \ssa{\expr}}]^{l} ~|~  [\assign {\ssa{x} } {\ssa{\query(\qexpr)}}]^{l}
%
~|~  {{\eifvar(\bar{\ssa{x}}, \bar{\ssa{x}}')}} 
%
\\ 
&&& 
{\ewhile ~ [ \sbexpr ]^{l} , n,
~ 
[\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}] 
~ \edo ~  \ssa{c} }
\\
&&&
~|~ \ssa{c};\ssa{c}  
~|~ [\eif(\sbexpr, [\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}] , \ssa{c}, \ssa{c})]^l 
~|~ [\eskip]^{l} 
\\
%
\mbox{Event} 
& \event & ::= & (\ssa{x}, v, l, n) | (\ssa{x}, \qval, v, l, n) | (\sbexpr, v, l, n)
\\
%
\mbox{Trace} & \vtrace
& ::= & \dot | \vtrace \cdot \event
\\
%
\mbox{Environment} 
& \env & ::= & \vtrace \to v \cup \{\bot\}
\\
%
\mbox{Query Environment} 
& \qenv & ::= & \vtrace \to \qval \cup \{\bot\}
\\
%
\mbox{Variable Counter} & \vcounter
& ::= & \mathcal{SVAR} \to \mathbb{N}
\end{array}
\]
We use following notations to represent the set of corresponding terms:
\[
\begin{array}{lll}
\mathcal{SVAR} & : & \mbox{Set of Variables}  
\\ 
%
\mathcal{VAL} & : & \mbox{Set of Values} 
\\ 
%
%
 \eventset  & : & \mbox{Set of Events}  
\\
%
\mathcal{SM}  & : & \mbox{{Set of SSA Memories}} 
\\
%
\dbdom  & : & \mbox{{Set of Databases}} 
\\
%
\qdom = {[-1,1]} & : & \mbox{{Domain of Query Results}}
\end{array}
\]
%
%
Environment :
\[
\env(\vtrace \cdot (x, v, l, n)) x \triangleq v
~~
\env(\vtrace \cdot (y, v, l, n)) x \triangleq \env(\vtrace) x
~~
\env(\cdot) x \triangleq \bot
\]
%
% The concatenation operation between 2 traces $t_1$ and $t_2$, i.e., $t_1 ++ t_2$ is the standard list concatenation operation as follows:
% \begin{equation}
%     t_1 ++ t_2  
%     \triangleq \left\{
%     \begin{array}{ll} 
%       t_2         & t_1 = []\\
%       \event::(t_1' ++ t_2)  & t_1 = \event::t_1'
%     \end{array}
%     \right.
%   \end{equation}
% %
% %
% The subtraction operation between 2 traces $t_1$ and $t_2$, i.e., $t_1 - t_2$ is defined as follows:
% \begin{equation}
%     t_1 - t_2  
%     \triangleq t_3 ~ s.t., t_2 ++ t_3 = t_1
%   \end{equation}
%
%
\subsection{Trace-based Operational Semantics for SSA Language}
%
%
%
{
\begin{mathpar}
\boxed{ \config{\trace,\aexpr} \aarrow v \, : \, Trace  \times AExpr \Rightarrow Value }
\\
\boxed{ \config{\trace, \bexpr} \barrow v \, : \, Trace \times BExpr \Rightarrow Value }
\end{mathpar}
}
%
Given the evaluation for the arithmetic and boolean expression, we defined the evaluation rules for query expression $\qexpr$ correspondingly as follows:
  \begin{mathpar}
  \boxed{ \config{\trace, \qexpr} \qarrow \qval \, : \, Trace  \times QExpr \qarrow QValue }
  \\
  \inferrule{ 
    \config{\trace, \qexpr_1} \qarrow \qval_1
    \and
    \config{m, \qexpr_2} \qarrow \qval_2
  }{
   \config{\trace,  \qexpr_1 \oplus_a \qexpr_2} 
   \qarrow n'
  }
  \and
  \inferrule{ 
    \config{m, \aexpr} \aarrow v
  }{
   \config{m,  \chi[\aexpr]} \qarrow \chi[v]
  }
  \end{mathpar}
%
%
\begin{figure}
\jl{
  \begin{mathpar}
  \boxed{
  Command \times Trace \times VCounter
  \xrightarrow{}
  Command \times Trace \times VCounter
  }
  \\
  \boxed{\config{\ssa{c, \vtrace, \vcounter}}
  \xrightarrow{} 
  \config{\ssa{c',  \vtrace', \vcounter'}}
  }
  \\
  %
  \inferrule
  {
  \vcounter'(\ssa{x}) = \vcounter(\ssa{x}) + 1
  \and 
  \event = (\ssa{x}, l, \vcounter'(\ssa{x}), v)
  }
  {
  \config{[\assign{\ssa{x}}{\saexpr}]^{l},  \vtrace, \vcounter} 
  \xrightarrow{} 
  \config{[\eskip]^{l}, \vtrace \cdot \event, \vcounter'}
  }
  ~\textbf{assn}
  %
  \and
  %
  \inferrule
  {
   \vtrace, b \barrow \etrue
   \and 
   \event = (b, \etrue, l, \vcounter(l))
   \and 
   \vcounter'(l) = \vcounter(l) + 1
  }
  {
  \config{\ssa{\ewhile ~ [b]^{l}, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}] ~ \edo ~ c, \vtrace, \vcounter}}
  \\
  \xrightarrow{} 
  \config{\ssa{ m, 
  c[\bar{x_i}/\bar{x'}]; \ewhile ~ [b]^{l}, (n + 1), [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}]  ~ \edo ~ c,  \eskip),
  \vtrace\cdot \event, \vcounter'}}
  }
  ~\textbf{ssa-while-t}
  %
  %
    \and
  %
  \inferrule
  {
   \vtrace, b \barrow \efalse
   \and 
   \event = (b, \efalse, l, \vcounter(l))
   \and 
   \vcounter'(l) = \vcounter(l) + 1
  }
  {
  \config{\ssa{\ewhile ~ [b]^{l}, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}] ~ \edo ~ c, \vtrace, \vcounter}}
  \\
  \xrightarrow{} 
  \config{\ssa{ m, 
  [\eskip]^l  \eskip),
  \vtrace \cdot \event, \vcounter'}}
  }
  ~\textbf{ssa-while-f}
  %
  \and
  %
 \inferrule
  {
   \vtrace, b \barrow \efalse
   \and 
   \event = (b, \efalse, l, \vcounter(l))
   \and 
   \vcounter'(l) = \vcounter(l) + 1  }
  {
  \config{
  \ssa{
  \eif ([b]^l, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}], n,  
  c; \ssa{\ewhile ~ [b]^{l}, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}]  ~ \edo ~ c},
  \eskip), \vtrace, \vcounter
  }}
  \\
  \xrightarrow{} 
  \config{
  \ssa{m, 
  {
  c; \ssa{\ewhile ~ [b]^{l}, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}]  ~ \edo ~ c},
  }
  }
  \vtrace, \vcounter}
  }
  ~\textbf{ssa-if-true}
  %
  %
  \and
  {
  \inferrule
  {
  \query(\qval) = v
  \and
  \vcounter'[\ssa{x}] = \vcounter[\ssa{x}] + 1
  \and 
  \event = (\ssa{x}, \qval, l, \vcounter'[\ssa{x}])
  }
  {
  \config{\ssa{m, [\assign{x}{\query(\qexpr)}]^l, \vtrace, \vcounter}}
  \xrightarrow{} 
  \config{\ssa{m[v/ x], \eskip,  \vtrace ++ [\event], \vcounter'} }
  }
  ~\textbf{ssa-query}
  }
  %
  \and
  %
  %
  \inferrule
  {
  \config{\ssa{m, c_1, \vtrace, \vcounter}}
  \xrightarrow{}
  \config{\ssa{m', c_1',  \vtrace', \vcounter'}}
  }
  {
  \config{\ssa{m, c_1; c_2, \vtrace, \vcounter}} 
  \xrightarrow{} 
  \config{\ssa{m', c_1'; c_2, \vtrace', \vcounter'}}
  }
  ~\textbf{ssa-seq1}
  %
  ~~~~~~~
  %
  \inferrule
  {
  }
  {
  \config{\ssa{m, [\eskip]^{l} ; c_2, \vtrace, \vcounter}} \xrightarrow{} \config{\ssa{m, c_2, \vtrace, \vcounter}}
  }
  ~\textbf{ssa-seq2}
  %
  \and
  %
  %
  \inferrule
  {
     \vtrace, b \barrow \etrue
   \and 
   \event = (b, \etrue, l, \vcounter(l))
   \and 
   \vcounter'(l) = \vcounter(l) + 1 
  }
  {
  \config{\ssa{
  \eif([\etrue]^{l}, [\bar{{x}}, \bar{{x_1}}, \bar{{x_2}}],
  [\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}],
  [\bar{\ssa{z}},\bar{\ssa{z_1}}, \bar{\ssa{z_2}}], c_1, c_2), 
  \vtrace, \vcounter}}
  \\
  \xrightarrow{} 
  \config{\ssa{ 
  c_1; 
  \eifvar(\bar{\ssa{x}},\bar{\ssa{x_2}}); 
  \eifvar(\bar{\ssa{y}},\bar{\ssa{y_1}});
  \eifvar(\bar{\ssa{z}},\bar{\ssa{z_2}}), 
  \vtrace \cdot \event, \vcounter'}}
  }
  ~\textbf{ssa-if-t}
  %
  \and
  %
  \inferrule
  {
   \vtrace, b \barrow \efalse
   \and 
   \event = (b, \efalse, l, \vcounter(l))
   \and 
   \vcounter'(l) = \vcounter(l) + 1 
  }
  {
  \config{\ssa{
  \eif([\efalse]^{l},[\bar{{x}}, \bar{{x_1}}, \bar{{x_2}}],
  [\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}],
  [\bar{\ssa{z}},\bar{\ssa{z_1}}, \bar{\ssa{z_2}}], c_1, c_2), \vtrace, \vcounter}}
  \\
  \xrightarrow{} 
  \config{\ssa{m, 
  c_2;
  \eifvar(\bar{\ssa{x}},\bar{\ssa{x_2}}); 
  \eifvar(\bar{\ssa{y}},\bar{\ssa{y_1}});
  \eifvar(\bar{\ssa{z}},\bar{\ssa{z_2}}), 
  \vtrace \cdot \event, \vcounter'}}
  }
  ~\textbf{ssa-if-f}
  %
  \and
  %
  \inferrule
  {
  }
  {
   \config{\ssa{m}, \eifvar(\ssa{\bar{x}, \bar{x}'}), \ssa{\vtrace, \vcounter}} 
   \to 
   \config{\ssa{(\bar{x} \to m(\bar{x}'))::m, \eskip, \vtrace, \vcounter}}
  }~\textbf{ssa-\eifvar}
  % %
  %
  %
  \end{mathpar}
}
  % \end{subfigure}
      \caption{Trace-based Operational Semantics for SSA Language.}
      \label{fig:os_ssa}
  \end{figure}
  %
%
%
\subsection{Event and Trace}
%
%
Events preserve the order of execution. The order relation is defined in Definition~\ref{def:query_dir}.
%
\begin{defn}[Order of Annotated Variables / Events].
\label{def:query_dir}
\\
Given 2 annotated queries 
$\event_1 = (x_1, v_1, l_1, n_1), 
\event_2 = (x_2, v_2, l_2, n_2)$
:
%
\[
\event_1 \eventlt \event_2
 \triangleq 
 \left\{
 \begin{array}{ll}
    n_1 < n_2  
    & l_1 = l_2
    \\
    w_1 <_w w_2 & o.w.
\end{array}  
\right.
\]
%
$\event_1 \eventgeq \event_2$  is defined vice versa.
\end{defn}
%
%
%
Given the evaluation rules for query expression, we define its equivalence relation in Definition~\ref{def:query_equal}.
%
\begin{defn}[Equivalence of Query].
%
\label{def:query_equal}
 Given a memory $m$ and 2 query expressions $\qexpr_1$, $\qexpr_2$ s.t., $FV(\qexpr_1) \in \dom(m)$ and $FV(\qexpr_2) \in \dom(m)$:
$$
\qexpr_1 =_{q}^{m} \qexpr_2 \triangleq
\left\{
    \begin{array}{ll} 
      \etrue      
      & 
    \exists \qval_1, \qval_2.
    \begin{array}{l} 
      (\config{m,  \qexpr_1} \qarrow \qval_1 \land \config{m,  \qexpr_2 } \qarrow \qval_2) 
      \\
      \land (\forall r \in \qdom. \exists v. ~ s.t., ~ 
            \config{m, \qval_1[r/\chi]} \aarrow v \land \config{m,  \qval_2[r/\chi] } \aarrow v)  
    \end{array}\\
      \efalse         
      & \text{o.w.} 
    \end{array}
    \right.
$$
%
, where $FV(\qexpr)$ is the set of free variables in the query expression $\qexpr$.
$\qexpr_1 \neq_{q}^{m} \qexpr_2$  is defined vice versa.
%
We use $=_{q}$  and $\neq_{q}$ as the shorthands for $=_{q}^{[]}$ and $\neq^{[]}_{q}$.
\end{defn}
%
Then, we have the corresponding equivalence relation between 2 annotated queries defined in Definition~\ref{def:av_equal}:
%
\begin{defn}[Equivalence of Events]
%
\label{def:av_equal}
Given 2 annotated queries 
$ \event_1 = (x_1, v_1, l_1, n_1), 
\event_2 = (x_2, v_2, l_2, n_2)$
:
%
\[
\event_1 \eventeq \event_2
 \triangleq (l_1 = l_2 \land  w_1 =_w w_2 \land 
 \qval_1 =_q \qval_2) 
\]
%
$\event_1 \eventneq \event_2$  is defined vice versa.
%
\end{defn}
%
%
%
\todo{
Given an annotated variable $\event$ and a trace $t$,
the appending operation $\event :: t$ is 
the standard list appending operation, appends $\event$ to the head of trace $t$.
%
The concatenation operation between 2 traces $t_1$ and $t_2$, i.e., $t_1 ++ t_2$ is the standard list concatenation operation as follows:
\begin{equation}
    t_1 ++ t_2  
    \triangleq \left\{
    \begin{array}{ll} 
      t_2         & t_1 = []\\
      \event::(t_1' ++ t_2)  & t_1 = \event::t_1'
    \end{array}
    \right.
  \end{equation}
%
%
The subtraction operation between 2 traces $t_1$ and $t_2$, i.e., $t_1 - t_2$ is defined as follows:
\begin{equation}
    t_1 - t_2  
    \triangleq t_3 ~ s.t., t_2 ++ t_3 = t_1
  \end{equation}
%
Given an annotated query $\event$, $\event$ belongs to a trace $t$, i.e., $\event \eventin t$ are defined as follows:
    %
\begin{equation}
    \event \eventin t  
    \triangleq \left\{
    \begin{array}{ll} 
      \efalse       & t = []      \\
      \etrue        & t = \event'::t'  \quad \event \eventeq \event'\\ 
      \event \in t'      & t = \event'::t'  \quad \event \eventneq \event'
    \end{array}
    \right.
  \end{equation}
  %
  %
}
%
\begin{defn}[Equivalence of Program]
%
\label{def:aq_prog}
Given 2 programs $c_1$ and $c_2$:
\[
c_1 =_{c} c_2
 \triangleq 
 \left\{
    \begin{array}{ll} 
      \etrue        
      & c_1 = \eskip \land c_2 = \eskip
      \\ 
      \forall m. \exists v. ~ \config{m, \expr_1} \aarrow^{*} v \land \config{m, \expr_1} \aarrow^{*} v     
      & c_1 = \assign{x}{\expr_1} \land c_2 = \assign{x}{\expr_2} 
      \\ 
      \qexpr_1 =_{q} \qexpr_2       
      & c_1 = \assign{x}{\query(\qexpr_1)} \land c_1 = \assign{x}{\query(\qexpr_2)} 
      \\
      c_1^f =_{c} c_2^f \land c_1^t =_{c} c_2^t
      & c_1 = \eif(b, c_1^t, c_1^f) \land c_2 = \eif(b, c_2^t, c_2^f)
      \\ 
      c_1' =_{c} c_2'         
      & c_1 = \ewhile b \edo c_1' \land c_2 = \ewhile b \edo c_2'
      \\ 
      c_1^h =_{c} c_2^h \land c_1^t =_{c} c_2^t
      & c_1 = c_1^h;c_1^t \land c_2 = c_2^h;c_2^t 
    \end{array}
    \right.
\]
%
$c_1 \neq_{c} c_2$  is defined vice versa.
%
\end{defn}
%
Given 2 programs $c$ and $c'$, $c'$ is a sub-program of$c$, i.e., $c' \in_{c} c$ is defined as:
\begin{equation}
c' \in_{c} c \triangleq \exists c_1, c_2, c''. ~ s.t.,~
c =_{c} c_1; c''; c_2 \land c' =_{c} c''
\end{equation} 
%
\begin{defn}[Assigned Variables ($\avar$)]
Given a program $\ssa{c}$, its assigned variables $\avar$ is a vector containing all variables newly assigned in the program preserving the order. 
It is defined as follows:
$$
  \avar_{\ssa{c}} \triangleq
  \left\{
  \begin{array}{ll}
      [\ssa{x}]                   
      & \ssa{c} = [\ssa{\assign x e}]^{(l, w)} 
      \\
      \left[ \ssa{x} \right]                  
      & \ssa{c} = [\ssa{\assign x \query(\qexpr)}]^{(l, w)} 
      \\
      \avar_{\ssa{c_1}} ++ \avar_{\ssa{c_2}}  
      & \ssa{c} = \ssa{c_1};\ssa{c_2}
      \\
      \avar_{\ssa{c_1}} ++ \avar_{\ssa{c_2}} ++ \ssa{[\bar{x}, \bar{y}, \bar{z}]} 
      & \ssa{c} =\eif([\sbexpr]^{(l, w)} , \ssa{[\bar{x}, \bar{x_2}, \bar{x_2}], 
      [\bar{y}, \bar{y_2}, \bar{y_3}], 
      [\bar{z}, \bar{z_2}, \bar{z_3}], c_1, c_2}) 
      \\
      \avar_{\ssa{c}'} ++ [\ssa{\bar{x}}]
      & \ssa{c}   = \ewhile ([\sbexpr]^{(l, w)}, [\ssa{\bar{x}, \bar{x_2}, \bar{x_2}}], \ssa{c}')
\end{array}
\right.
$$
\end{defn}
%
\begin{defn}[Query Variables ($\qvar$)].
\\
Given a program $c$, its query variables $\qvar$ is a vector containing all variables newly assigned by a query in the programm, $\qvar \subset \mathcal{VAR}$.
It is defined as follows:
$$
  \qvar_{\ssa{c}} \triangleq
  \left\{
  \begin{array}{ll}
      []                  
      & \ssa{c} = [\ssa{\assign x e}]^{(l, w)} 
      \\
      \left[ \ssa{x} \right]                  
      & \ssa{c} = [\ssa{\assign x \query(\qexpr)}]^{(l, w)} 
      \\
      \avar_{\ssa{c_1}} ++ \avar_{\ssa{c_2}}  
      & \ssa{c} = \ssa{c_1};\ssa{c_2}
      \\
      \avar_{\ssa{c_1}} ++ \avar_{\ssa{c_2}} ++ \ssa{[\bar{x}, \bar{y}, \bar{z}]} 
      & \ssa{c} =\eif([\sbexpr]^{(l, w)} , \ssa{[\bar{x}, \bar{x_2}, \bar{x_2}], 
      [\bar{y}, \bar{y_2}, \bar{y_3}], 
      [\bar{z}, \bar{z_2}, \bar{z_3}], c_1, c_2}) 
      \\
      \avar_{\ssa{c}'} ++ [\ssa{\bar{x}}]
      & \ssa{c}   = \ewhile ([\sbexpr]^{(l, w)}, [\ssa{\bar{x}, \bar{x_2}, \bar{x_2}}], \ssa{c}')
\end{array}
\right.
$$
\end{defn}
%
We are abusing the notations and operators from list here. 
The notation $[]$ represents an empty vector
and $x::A$ represents add an element $x$ to the head of the vector $A$.
The concatenation operation between 2 vectors $A_1$ and $A_2$, i.e., $A_1 ++ A_2$ is mimic the standard list concatenation operations as follows:
%
\begin{equation}
    A_1 ++ A_2  
    \triangleq \left\{
    \begin{array}{ll} 
      A_2         & A_1 = []\\
      x::(A_1' ++ A_2)  & A_1 = x::A_1'
    \end{array}
    \right.
\end{equation}
%
We use index within parenthesis to denote the access to the element of corresponding location,
$A(i)$ denotes the element at location $i$ in the vector $A$ and 
$M(i, j)$ denotes the element at location $i$-th raw, $i$-th column in the matrix $M$. 
%
%
%
\begin{defn}[Initial Variable Counter $\vcounter^0_{c}$]
Given a program $c$ with its assigned variables $\avar_{c}$ of length $N$, its initial variable counter $\vcounter^0_{c}$ maps all the variable to $0$, i.e.:
\[
  \vcounter^0_{c}(x) = 0, x = \avar_{c}(i) \forall i = 1, \ldots, N 
\]
\end{defn}
%
%
\subsection{ Trace-based Adaptivity}
%
%
% 
%
%
%
\begin{defn}
[Events May Dependency]
\label{def:event_dep}.
\\
One event $\event_2$ may depend on another one  $\event_1$in a program $\ssa{c}$,
with a starting memory $\ssa{m}$ and hidden database $D$, denoted as 
%
$\eventdep(\event_1, \event_2, c, \ssa{m}, D)$ is defined below. 
%
\[
\begin{array}{ll}
\begin{array}{l}
\exists \ssa{m}, \ssa{m}_1, \ssa{m}_2, \ssa{m}_3, \ssa{m}_2', \ssa{m}_3', 
\vtrace_1, \vtrace_2, \vtrace_2', t_1, t_2, t_2', \ssa{c}_1, \ssa{c}_2, v_1', \sexpr_2.
\\
  \left(
  \begin{array}{l}   
\config{\ssa{m}, \ssa{c}, []} \rightarrow^{*} 
\config{\ssa{m}_1, [\assign{\ssa{x}_1}{v_1}]^{l_1} ; \ssa{c}_1, \vtrace_1, t_1} 
\\ 
 \bigwedge
 \config{\ssa{m}_1[v_1/\ssa{x}_1], c_1, \vtrace_1 ++ [\event_1], t_1[\ssa{x}_1]++} 
 \\
  \qquad \rightarrow^{*} 
  \config{\ssa{m}_2, [\assign{\ssa{x}_2}{\sexpr_2}]^{l_2} ; \ssa{c}_2, \vtrace_2, t_2} 
  \\
  \qquad \rightarrow^{*} 
  \config{\ssa{m}_3, \ssa{c}_2,  \vtrace_2 ++ [\event_2], t_2[\ssa{x}_2]++} 
  % 
 \\ 
 \bigwedge
 \config{\ssa{m}_1[v_1'/\ssa{x}_1], \ssa{c}_1, \vtrace_1, t_1} 
\rightarrow^{*} 
\config{\ssa{m}_2', \ssa{c}_2,  \vtrace_2', t_2'}
\\
\bigwedge
\qenv(\event_2) \neq \qenv(\event'_2)
\end{array}
\right)
\end{array} 
&
\begin{array}{l}
\event_1 = (\ssa{x}_1, v_1, l_1, n_1) 
\text{or} \\
\event_1 = (\ssa{x}_1, \qval_1, v_1, l_1, n_1) 
\end{array}
\\
\begin{array}{l}
\exists \ssa{m}, \ssa{m}_1, \ssa{m}_2, \ssa{m}_3, \ssa{m}_2', \ssa{m}_3', 
\vtrace_1, \vtrace_2, \vtrace_2', t_1, t_2, t_2', \ssa{c}_1, \ssa{c}_2, v_1', {\qexpr}_2.
\\
  \left(
  \begin{array}{l}   
\config{\ssa{m}, \ssa{c}, []} \rightarrow^{*} 
\config{\ssa{m}_1, [\assign{\ssa{x}_1}{\query({\qval}_1)}]^{l_1} ; \ssa{c}_1, \vtrace_1, t_1} 
\\ 
 \bigwedge
 \config{\ssa{m}_1[v_1/\ssa{x}_1], c_1, \vtrace_1 ++ [\event_1], t_1[\ssa{x}_1]++} 
 \\
\qquad \rightarrow^{*} 
\config{\ssa{m}_2, [\assign{\ssa{x}_2}{\query({\qexpr}_2)}]^{l_2} ; \ssa{c}_2, \vtrace_2, t_2} 
\\
\qquad \rightarrow^{*} 
\config{\ssa{m}_3, \ssa{c}_2,  \vtrace_2 ++ [\event_2], t_2[\ssa{x}_2]++} 
  % 
 \\ 
 \bigwedge
 \config{\ssa{m}_1[v_1'/\ssa{x}_1], \ssa{c}_1, \vtrace_1, t_1} 
\rightarrow^{*} 
\config{\ssa{m}_2', \ssa{c}_2,  \vtrace_2', t_2'}
\\
\bigwedge
\event_2 \notin \vtrace_2'
\end{array}
\right)
\end{array} 
&
\begin{array}{l}
\event_1 = (\ssa{b}_1, v_1, l_1, n_1)
\end{array}
\end{array}
 \]
%
\end{defn}
%
\begin{defn}[Variable May Dependency].
\label{def:var_dep}
\\
Given a program $\ssa{c}$ with its assigned variables $\avar_{\ssa{c}}$, 
one variable $\ssa{x}_2 \in \avar_{\ssa{c}}$ may depend on another variable 
$\ssa{x}_1 \in \avar_{\ssa{c}}$ in $\ssa{c}$ denoted as 
%
$\vardep(\ssa{x}_1, \ssa{x}_2, \ssa{c})$ is defined below.
%
\[
\exists \event_1, \event_2, \ssa{m}, D. ~
\projl{\event_1} = \ssa{x}_1
\land
\projl{\event_2} = \ssa{x}_2
\land 
\eventdep(\event_1, \event_2, c, \ssa{m}, D)
\] 
%
%
\end{defn}
%
%
\begin{defn}[Execution Based Dependency Graph].
\\
Given a program $\ssa{c}$, a database $D$, a starting memory $\ssa{m}$ with its assigned variables $\avar_c$ and initial variable counter $\vcounter^0_{c}$ with its corresponding execution:
$\config{\ssa{m}, \ssa{c}, [], \vcounter^0_{\ssa{c}}} 
\to^{*}
\config{\ssa{m'}, \eskip, \vtrace, \vcounter}$,
the dependency graph $\traceG(\ssa{c}, \ssa{m}, D) = (\vertxs, \edges, \weights, \qflag)$ is defined as:
%
\[
\begin{array}{rlcl}
  \text{Vertices} &
  \vertxs & := & \left\{ 
  x \in \mathcal{VAR}
  ~ \middle\vert ~
  x = \avar_{\ssa{c}}(i); i = 0, \ldots, |\avar_{\ssa{c}}| 
  \right\}
  \\
  \text{Directed Edges} &
  \edges & := & 
  \left\{ 
  (x, x') \in \mathcal{VAR} \times \mathcal{VAR}
  ~ \middle\vert ~
  \vardep(x, x', c); 
  x = \avar_{\ssa{c}}(i); x' = \avar_{\ssa{c}}(j); i,j = 0, \ldots, |\avar_{\ssa{c}}| 
  \right\}
  \\
  \text{Weights} &
  \weights & := & 
  \left\{ 
  (x, n) \in \mathcal{VAR} \times \mathbb{N}
  ~ \middle\vert ~
  n = \vcounter(x); x = \avar_{\ssa{c}}(i); i = 0, \ldots, |\avar_{\ssa{c}}|
  \right\}
  \\
  \text{Query Flags} &
  \qflag & := & 
  \left\{(x, n)  \in \vertxs \times \{0, 1\} 
  ~ \middle\vert ~
  \left\{
  \begin{array}{ll}
  n = 1 & x \in \qvar_{\ssa{c}} \\ 
  n = 0 & o.w.
  \end{array}
  \right\};
  x = \avar_{\ssa{c}}(i); i = 0, \ldots, |\avar_{\ssa{c}}|
  \right\}
\end{array}
\]
\end{defn}
%
%
\begin{defn}[Finite Walk ($k$)].
\label{def:finitewalk}
\\
Given a labeled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, a \emph{finite walk} $k$ in $G$ is a sequence of edges $(e_1 \ldots e_{n - 1})$ 
for which there is a sequence of vertices $(v_1, \ldots, v_{n})$ such that:
\begin{itemize}
    \item $e_i = (v_{i},v_{i + 1})$ for every $1 \leq i < n$.
    \item every vertex $v \in \vertxs$ appears in this vertices sequence $(v_1, \ldots, v_{n})$ of $k$ at most $W(v)$ times.  
\end{itemize}
$(v_1, \ldots, v_{n})$ is the vertex sequence of this walk.
\\
%
Length of this finite walk $k$ is the number of vertices in its vertex sequence, i.e., $\len(k) = n$.
\end{defn}
%
Given a labeled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, 
we use $\walks(G)$ to denote a set containing all finite walks $k$ in $G$;
and $k_{v_1 \to v_2} \in \walks(G)$where $v_1, v_2 \in \vertxs$ denotes the walk from vertex $v_1$ to $v_2$ .
%
%
\begin{defn}[Length of Finite Walk w.r.t. Query ($\qlen$)].
\label{def:qlen}
\\
Given a labeled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$ and a \emph{finite walk} $k$ in $G$ with its vertex sequence $(v_1, \ldots, v_{n})$, the length of $k$ w.r.t query is defined as:
\[
  \qlen(k) = \len\big(
  v \mid v \in (v_1, \ldots, v_{n}) \land \flag(v) = 1 \big)
\]
, where $\big(v \mid v \in (v_1, \ldots, v_{n}) \land \flag(v) = 1 \big)$ is a subsequence of $k$'s vertex sequence.
\end{defn}
%
Given a program $c$ with a starting memory $m$ and database $D$, we generate its program-based graph 
$\traceG(\ssa{c, m}, D) = (\vertxs, \edges, \weights, \qflag)$.
%
Then the adaptivity bound based on program analysis for $\ssa{c}$ is the number of query vertices on a finite walk in $\progG(\ssa{c})$. This finite walk satisfies:
%
\begin{itemize}
\item the number of query vertices on this walk is maximum
\item the visiting times of each vertex $v$ on this walk is bound by its weight $\weights(v)$.
\end{itemize}
%
It is formally defined in \ref{def:trace_adapt}.
%
\begin{defn}
[Adaptivity of A Program].
\label{def:trace_adapt}
\\
Given a program $\ssa{c}$ in SSA language, 
its adaptivity is defined for all possible starting SSA memory $\ssa{m}$ and database $D$ as follows:
%
$$
A(c) = \max \big 
\{ \qlen(k) \mid D \in \dbdom , k \in \walks(\traceG(c, m, D) \big \} 
$$
\end{defn}
%
%
%
%
\todo{
The following lemma describes a property of the trace-based dependency graph.
For any program $c$ with a database $D$ and a starting memory $m$,
the directed edges in its trace-based dependency graph can only be constructed from nodes representing 
smaller annotated queries to annotated queries of greater order.
There doesn't exist backward edges with direction from greater annotated queries to smaller ones.
}
\begin{lem}
\label{lem:edgeforwarding}
[Edges are Forwarding Only].
\\
%
Given a program $c$, a database $D$, a starting memory $m$ and the corresponding trace-based dependency graph $G(c,D,m) = (\vertxs, \edges)$, 
for any directed edge $(\event', \event) \in \edges$, 
this is not the case that:
%
$$\event' \eventgeq \event$$
%
\end{lem}
%
\begin{proof}
Proof in File: {\tt ``edge\_forward.tex''}.
% \input{edge_forward}
\end{proof}
%
%
%
\begin{lem}
\label{lem:DAG}
[Trace-based Dependency Graph is Directed Acyclic].
\\
%
{
Every trace-based dependency graph is a directed acyclic graph.
}
\end{lem}
%
{
\begin{proof}
Proof is obvious based on the Lemma \ref{lem:edgeforwarding}.
\end{proof}
}
%
\begin{lem}
[Adaptivity is Bounded].
\\
{
Given the program $c$ with a certain database $D$ and starting memory $m$, the $A(c)$ w.r.t. the $D$ and $m$ is bounded, i.e.,:
%
\[
\config{m, c, [], []} 
\rightarrow^{*} 
\config{m', \eskip, t', w'} 
\implies
A_{D, m}(c) \leq |t'|
\]
}
\end{lem}
%
\begin{proof}
{
Proof is obvious based on the Lemma \ref{lem:DAG}.
}
\end{proof}
%
%
\clearpage
%
%
\subsection{SSA Transformation and Soundness of Transformation}
in File {\tt ``ssa\_transform\_sound.tex''}
% \input{ssa_transform_sound}
%
\clearpage