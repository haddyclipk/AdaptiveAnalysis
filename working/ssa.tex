\section{Labeled SSA Language}
%
%
\subsection{SSA form Language}
\[
\begin{array}{llll}
 \mbox{Arithmetic Operators} 
& \oplus_a & ::= & + ~|~ - ~|~ \times 
%
~|~ \div \\  
\mbox{Boolean Operators} 
& \oplus_b & ::= & \lor ~|~ \land
\\
  %
\mbox{Relational Operators} 
& \sim & ::= & < ~|~ \leq ~|~ == 
\\  
%
\mbox{Label} 
& l & := & \mathbb{N} 
\\ 
%
\mbox{SSA Arithmetic Expression} 
& \saexpr & ::= & 
n ~|~ \ssa{x} ~|~ \saexpr \oplus_a \saexpr  
\\
%
\mbox{SSA Boolean Expression} & \sbexpr & ::= & 
	%
	\etrue ~|~ \efalse  ~|~ \neg \sbexpr
	 ~|~ \sbexpr \oplus_b \sbexpr
	%
	~|~ \saexpr \sim \saexpr 
	\\
%
\mbox{SSA Query Expression} 
& \ssa{\qexpr} & ::= 
& { \qval ~|~ \saexpr ~|~ \qexpr \oplus_a \qexpr} 
\\
%
\mbox{Query Value} & \qval & ::= 
& {n ~|~ \chi[n] ~|~ \chi[n] \oplus_a  \chi[n] ~|~ n \oplus_a  \chi[n]
~|~ \chi[n] \oplus_a  n}
\\
%
\mbox{Value} 
& v & ::= & { n \sep \etrue \sep \efalse ~|~ [] ~|~ [v, \dots, v]}  
\\
%
\mbox{SSA Expression} & \sexpr & ::= & v ~|~ \saexpr \sep \sbexpr ~|~ [\expr, \dots, \expr]
\\	
%
\mbox{Labeled SSA Command} 
& \ssa{c} & ::= &   [\assign {\ssa{x}}{ \ssa{\expr}}]^{l} ~|~  [\assign {\ssa{x} } {\ssa{\query(\qexpr)}}]^{l}
%
~|~  {{\eifvar(\bar{\ssa{x}}, \bar{\ssa{x}}')}} 
%
\\ 
&&& 
{\ewhile ~ [ \sbexpr ]^{l} , n,
~ 
[\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}] 
~ \edo ~  \ssa{c} }
\\
&&&
~|~ \ssa{c};\ssa{c}  
~|~ [\eif(\sbexpr, [\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}] , \ssa{c}, \ssa{c})]^l 
~|~ [\eskip]^{l} 
\\
%
\mbox{Event} 
& \event & ::= & 
      (\ssa{x}, l, n, v)   \mbox{Assignment Event} \\
&&& | (\ssa{x}, l, n, \qval, v) \\
&&& | (\sbexpr, l, n, v) \mbox{Testing Event}
\\
%
\mbox{Trace} & \vtrace
& ::= & | \vtrace \cdot \event
\\
%
\mbox{Event Signature} & \sig
& ::= & (x, l, n) | (x, l, n, \query) | (b, l, n)
% \\
% %
% \mbox{Environment} 
% & \env & ::= & \vtrace \to \mathcal{SVAR} \to v \cup \{\bot\}
% \\
% %
% \mbox{Query Environment} 
% & \qenv & ::= & \vtrace \to \mathcal{SVAR} \to \qval \cup \{\bot\}
\end{array}
\]
We use following notations to represent the set of corresponding terms:
\[
\begin{array}{lll}
\mathcal{SVAR} & : & \mbox{Set of Variables}  
\\ 
%
\mathcal{VAL} & : & \mbox{Set of Values} 
\\ 
%
%
\eventset  & : & \mbox{Set of Events}  
\\
%
%
\eventset^{\asn}  & : & \mbox{Set of Assignment Events}  
\\
%
\eventset^{\test}  & : & \mbox{Set of Testing Events}  
\\
%
%
\eventset  & : & \mbox{Set of Events}  
\\
%
\dbdom  & : & \mbox{{Set of Databases}} 
\\
%
\qdom = {[-1,1]} & : & \mbox{{Domain of Query Results}}
\end{array}
\]
%
%
%
Environment $ \env : \vtrace \to \mathcal{SVAR} \to \mathcal{VAL} \cup \{\bot\}$
\[
\begin{array}{ll}
\env(\vtrace \cdot (x, l, n, v)) x \triangleq v
&
\env(\vtrace \cdot (x, l, n, \qval, v)) x \triangleq v
\\
\env(\vtrace \cdot (y, l, n, v)) x \triangleq \env(\vtrace) x
&
\env() x \triangleq \bot
\end{array}
\]
%
Counter $\vcounter : \trace \to \mathbb{N} \to \mathbb{N}$
\[
\begin{array}{ll}
\vcounter(\vtrace \cdot (x, l, n, v)) l \triangleq n
&
\vcounter() l \triangleq 0
\end{array}
\]
%
\subsection{Trace-based Operational Semantics for SSA Language}
%
%
%
{
\begin{mathpar}
\boxed{ \config{\trace,\aexpr} \aarrow v \, : \, Trace  \times AExpr \Rightarrow Value }
\\
\boxed{ \config{\trace, \bexpr} \barrow v \, : \, Trace \times BExpr \Rightarrow Value }
\\
\boxed{ \config{\trace, \qexpr} \qarrow \qval \, : \, Trace  \times QExpr \qarrow QValue }
  \\
  \inferrule{ 
    \config{\trace, \qexpr_1} \qarrow \qval_1
    \and
    \config{m, \qexpr_2} \qarrow \qval_2
  }{
   \config{\trace,  \qexpr_1 \oplus_a \qexpr_2} 
   \qarrow n'
  }
  \and
  \inferrule{ 
    \config{m, \aexpr} \aarrow v
  }{
   \config{m,  \chi[\aexpr]} \qarrow \chi[v]
  }
  \end{mathpar}
%
The trace based operational semantics are defined in Figure \ref{fig:os_ssa}.
%
\begin{figure}
\jl{
  \begin{mathpar}
  \boxed{
  Command \times Trace
  \xrightarrow{}
  Command \times Trace
  }
  \\
  \boxed{\config{\ssa{c, \vtrace}}
  \xrightarrow{} 
  \config{\ssa{c',  \vtrace'}}
  }
  \\
  %
  \inferrule
  {
  \event = (\ssa{x}, l, \vcounter(\vtrace) l + 1, v)
  }
  {
  \config{[\assign{\ssa{x}}{\saexpr}]^{l},  \vtrace } 
  \xrightarrow{} 
  \config{[\eskip]^{l}, \vtrace \cdot \event}
  }
  ~\textbf{assn}
  %
  \and
  %
  \inferrule
  {
   \vtrace, b \barrow \etrue
   \and 
   \event = (b, l, \vcounter(\vtrace) l + 1, \etrue)
  }
  {
  \config{\ssa{\ewhile ~ [b]^{l}, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}] ~ \edo ~ c, \vtrace}}
  \\
  \xrightarrow{} 
  \config{\ssa{
  c[\bar{x_i}/\bar{x'}]; \ewhile ~ [b]^{l}, (n + 1), [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}]  ~ \edo ~ c,  \eskip),
  \vtrace\cdot \event}}
  }
  ~\textbf{ssa-while-t}
  %
  %
    \and
  %
  \inferrule
  {
   \vtrace, b \barrow \efalse
   \and 
   \event = (b, l, \vcounter(\vtrace) l + 1, \efalse)
  }
  {
  \config{\ssa{\ewhile ~ [b]^{l}, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}] ~ \edo ~ c, \vtrace}}
  \\
  \xrightarrow{} 
  \config{\ssa{
  [\eskip]^l ,
  \vtrace \cdot \event}}
  }
  ~\textbf{ssa-while-f}
  %
  \and
  %
  {
  \inferrule
  {
   \vtrace, \qexpr \qarrow \qval
   \and 
  \query(\qval) = v
  \and 
  \event = (\ssa{x}, l, \vcounter(\vtrace) l + 1, \qval, v)
  }
  {
  \config{\ssa{[\assign{x}{\query(\qexpr)}]^l, \vtrace}}
  \xrightarrow{} 
  \config{\ssa{\eskip,  \vtrace \cdot \event} }
  }
  ~\textbf{ssa-query}
  }
  %
  \and
  %
  %
  \inferrule
  {
  \config{\ssa{c_1, \vtrace}}
  \xrightarrow{}
  \config{\ssa{c_1',  \vtrace'}}
  }
  {
  \config{\ssa{c_1; c_2, \vtrace}} 
  \xrightarrow{} 
  \config{\ssa{c_1'; c_2, \vtrace'}}
  }
  ~\textbf{ssa-seq1}
  %
  ~~~~~~~
  %
  \inferrule
  {
    \config{\ssa{c_2, \vtrace}}
  \xrightarrow{}
  \config{\ssa{c_2',  \vtrace'}}
  }
  {
  \config{\ssa{[\eskip]^{l} ; c_2, \vtrace}} \xrightarrow{} \config{\ssa{ c_2', \vtrace'}}
  }
  ~\textbf{ssa-seq2}
  %
  \and
  %
  %
  \inferrule
  {
     \vtrace, b \barrow \etrue
   \and 
   \event = (b, l, \vcounter(\vtrace) l + 1, \etrue)
  }
  {
  \config{\ssa{
  \eif([\etrue]^{l}, [\bar{{x}}, \bar{{x_1}}, \bar{{x_2}}],
  [\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}],
  [\bar{\ssa{z}},\bar{\ssa{z_1}}, \bar{\ssa{z_2}}], c_1, c_2), 
  \vtrace}}
  \\
  \xrightarrow{} 
  \config{\ssa{ 
  c_1; 
  \eifvar(\bar{\ssa{x}},\bar{\ssa{x_2}}); 
  \eifvar(\bar{\ssa{y}},\bar{\ssa{y_1}});
  \eifvar(\bar{\ssa{z}},\bar{\ssa{z_2}}), 
  \vtrace \cdot \event}}
  }
  ~\textbf{ssa-if-t}
  %
  \and
  %
  \inferrule
  {
   \vtrace, b \barrow \efalse
   \and 
   \event = (b, l, \vcounter(\vtrace) l + 1, \efalse)
  }
  {
  \config{\ssa{
  \eif([\efalse]^{l},[\bar{{x}}, \bar{{x_1}}, \bar{{x_2}}],
  [\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}],
  [\bar{\ssa{z}},\bar{\ssa{z_1}}, \bar{\ssa{z_2}}], c_1, c_2), \vtrace}}
  \\
  \xrightarrow{} 
  \config{\ssa{
  c_2;
  \eifvar(\bar{\ssa{x}},\bar{\ssa{x_2}}); 
  \eifvar(\bar{\ssa{y}},\bar{\ssa{y_1}});
  \eifvar(\bar{\ssa{z}},\bar{\ssa{z_2}}), 
  \vtrace \cdot \event}}
  }
  ~\textbf{ssa-if-f}
  %
  \and
  %
  \inferrule
  {
  }
  {
   \config{\eifvar(\ssa{\bar{x}, \bar{x}'}), \ssa{\vtrace}} 
   \to 
   \config{\ssa{\eskip, \vtrace}}
  }~\textbf{ssa-\eifvar}
  % %
  %
  %
  \end{mathpar}
}
  % \end{subfigure}
      \caption{Trace-based Operational Semantics for SSA Language.}
      \label{fig:os_ssa}
  \end{figure}
  %
%
%
\subsection{Event and Trace}
%
%
Environment $ \env : \vtrace \to \mathcal{SVAR} \to \mathcal{VAL} \cup \{\bot\}$
\[
\begin{array}{ll}
\env(\vtrace \cdot (x, l, n, v)) x \triangleq v
&
\env(\vtrace \cdot (x, l, n, \qval, v)) x \triangleq v
\\
\env(\vtrace \cdot (y, l, n, v)) x \triangleq \env(\vtrace) x
&
\env() x \triangleq \bot
\end{array}
\]

%
Query Environment $\qenv: \vtrace \to \mathcal{SVAR} \to \qval \cup \{\bot\}$
\[
\begin{array}{ll}
\qenv(\vtrace \cdot (x, l, n, v)) x \triangleq \qenv(\vtrace) x
&
\qenv(\vtrace \cdot (x, l, n, \qval, v)) x \triangleq \qval
\\
\qenv(\vtrace \cdot (y, l, n, v)) x \triangleq \qenv(\vtrace) x
&
\qenv() x \triangleq \bot
\end{array}
\]
%
Event Value : $\pi_v : \eventset \to \mathcal{VAL}$
\[
\begin{array}{ll}
\pi_v((x, l, n, v)) \triangleq v
&
\pi_v (x, l, n, \qval, v) \triangleq v
\\
\pi_v (b, l, n, v)  \triangleq v
&
\end{array}
\]
%
Event Query Value : $\pi_{q} : \eventset \to \mathcal{VAL}$
\[
\begin{array}{ll}
\pi_{q} (x, l, n, v) \triangleq v
&
\pi_{q} (x, l, n, \qval, v) \triangleq \qval
\\
\pi_{q} (b, l, n, v)  \triangleq v
&
\end{array}
\]%
% 
Event Signature : $\pi_{\sig} : \eventset \to \mathcal{VAL}$
\[
\begin{array}{ll}
\pi_{\sig} (x, l, n, v) \triangleq (x, l, n)
&
\pi_{\sig} (x, l, n, \qval, v) \triangleq (x, l, n, \query)
\\
\pi_{\sig} (b, l, n, v)  \triangleq (b, l, n)
&
\end{array}
\]
%
Equivalence of 2 events : $\event_1 \eventeq \event_2$
\[
\event_1 \sigeq \event_2 \triangleq
\left\{
\begin{array}{ll}
\etrue & \event_1 = (x, l, n, v) \land \event_2 = (x, l, n, v) \\
\etrue & \event_1 = (x, l, n, \qval_1, v) \land \event_2 = (x, l, n, \qval', v)  
\land \qval_1 =_{q} \qval_2\\
\etrue & \event_1 = (b, l, n, v) \land \event_2 = (b, l, n, v) \\
\efalse & o.w.
\end{array}
\right.
\]

Signature Equivalence of 2 events : $\event_1 \sigeq \event_2$
\[
\event_1 \sigeq \event_2 \triangleq
\left\{
\begin{array}{ll}
\etrue & \event_1 = (x, l, n, v) \land \event_2 = (x, l, n, v') \\
\etrue & \event_1 = (x, l, n, \qval, v) \land \event_2 = (x, l, n, \qval', v') \\
\etrue & \event_1 = (b, l, n, v) \land \event_2 = (b, l, n, v') \\
\efalse & o.w.
\end{array}
\right.
\]
%
%
\begin{defn}[Equivalence of Query].
%
\label{def:query_equal}
Given a trace $\trace$ and 2 query expressions $\qexpr_1$, $\qexpr_2$:
$$
\qexpr_1 =_{q}^{\trace} \qexpr_2 \triangleq
\left\{
    \begin{array}{ll} 
      \etrue      
      & 
    \exists \qval_1, \qval_2.
    \begin{array}{l} 
      (\config{\trace,  \qexpr_1} \qarrow \qval_1 \land \config{\trace,  \qexpr_2 } \qarrow \qval_2) 
      \\
      \land (\forall r \in \qdom. \exists v. ~ s.t., ~ 
            \config{\trace, \qval_1[r/\chi]} \aarrow v \land \config{\trace,  \qval_2[r/\chi] } \aarrow v)  
    \end{array}\\
      \efalse         
      & \text{o.w.} 
    \end{array}
    \right.
$$
%
, where $FV(\qexpr)$ is the set of free variables in the query expression $\qexpr$.
$\qexpr_1 \neq_{q}^{\trace} \qexpr_2$  is defined vice versa.
%
We use $=_{q}$  and $\neq_{q}$ as the shorthands when $\trace$ is empty.
\end{defn}
%
\begin{defn}[Order of Events].
\label{def:query_dir}
\\
Given 2 events 
$\event_1 = (x_1, l_1, n_1), 
\event_2 = (x_2, l_2, n_2)$
:
%
\[
\event_1 \eventlt \event_2
 \triangleq 
 \left\{
 \begin{array}{ll}
    l_1 < l_2 & n_1 = n_2
    \\
    n_1 < n_2  & o.w.
\end{array}  
\right.
\]
%
$\event_1 \eventgeq \event_2$  is defined vice versa.
\end{defn}
%
%
%
%
%
%
Given an annotated query $\event$, $\event$ belongs to a trace $\trace$, i.e., $\event \eventin \trace$ are defined as follows:
    %
\begin{equation}
    \event \eventin \trace  
    \triangleq \left\{
    \begin{array}{ll} 
      \etrue                  & \trace =  (\trace' \cdot \event') \land (\event \eventeq \event') \\
      \event \eventin \trace' & \trace =  (\trace' \cdot \event') \land (\event \eventneq \event') \\ 
      \efalse                 & o.w.
    \end{array}
    \right.
  \end{equation}
  %
Given an event $\event$, $\event$ signature belongs to a trace $\trace$, i.e., $\event \sigin \trace$ are defined as follows:
    %
\begin{equation}
    \event \sigin \trace  
    \triangleq \left\{
    \begin{array}{ll} 
      \etrue                  & \trace =  (\trace' \cdot \event') \land (\event \sigeq \event') \\
      \event \sigin \trace'   & \trace =  (\trace' \cdot \event') \land (\event \signeq \event') \\ 
      \efalse                 & o.w.
    \end{array}
    \right.
  \end{equation}
  %
  %
%
\begin{defn}[Equivalence of Program]
%
\label{def:aq_prog}
Given 2 programs $c_1$ and $c_2$:
\[
c_1 =_{c} c_2
 \triangleq 
 \left\{
    \begin{array}{ll} 
      \etrue        
      & c_1 = \eskip \land c_2 = \eskip
      \\ 
      \forall m. \exists v. ~ \config{m, \expr_1} \aarrow^{*} v \land \config{m, \expr_1} \aarrow^{*} v     
      & c_1 = \assign{x}{\expr_1} \land c_2 = \assign{x}{\expr_2} 
      \\ 
      \qexpr_1 =_{q} \qexpr_2       
      & c_1 = \assign{x}{\query(\qexpr_1)} \land c_1 = \assign{x}{\query(\qexpr_2)} 
      \\
      c_1^f =_{c} c_2^f \land c_1^t =_{c} c_2^t
      & c_1 = \eif(b, c_1^t, c_1^f) \land c_2 = \eif(b, c_2^t, c_2^f)
      \\ 
      c_1' =_{c} c_2'         
      & c_1 = \ewhile b \edo c_1' \land c_2 = \ewhile b \edo c_2'
      \\ 
      c_1^h =_{c} c_2^h \land c_1^t =_{c} c_2^t
      & c_1 = c_1^h;c_1^t \land c_2 = c_2^h;c_2^t 
    \end{array}
    \right.
\]
%
$c_1 \neq_{c} c_2$  is defined vice versa.
%
\end{defn}
%
Given 2 programs $c$ and $c'$, $c'$ is a sub-program of$c$, i.e., $c' \in_{c} c$ is defined as:
\begin{equation}
c' \in_{c} c \triangleq \exists c_1, c_2, c''. ~ s.t.,~
c =_{c} c_1; c''; c_2 \land c' =_{c} c''
\end{equation} 
%

\begin{defn}[Labeled Variables ($\lvar_{c} \subseteq \mathcal{VAR} \times \mathbb{N}$ or 
$\lvar : c \to \mathcal{P}(\mathcal{VAR} \times \mathbb{N})$]
$$
  \lvar_{c} \triangleq
  \left\{
  \begin{array}{ll}
      \{\ssa{x}^l\}                   
      & \ssa{c} = [\ssa{\assign x e}]^{l} 
      \\
      \{\ssa{x}^l\}                   
      & \ssa{c} = [\ssa{\assign x \query(\qexpr)}]^{l} 
      \\
      \lvar_{\ssa{c_1}} \cup \lvar{(\ssa{c_2})}  
      & \ssa{c} = \ssa{c_1};\ssa{c_2}
      \\
      \lvar_{\ssa{c}} \cup \lvar_{\ssa{c_2}} \cup \ssa{\{\bar{x}, \bar{y}, \bar{z}\}} 
      & \ssa{c} =\eif([\sbexpr]^{l} , \ssa{[\bar{x}, \bar{x_2}, \bar{x_2}], 
      [\bar{y}, \bar{y_2}, \bar{y_3}], 
      [\bar{z}, \bar{z_2}, \bar{z_3}], c_1, c_2}) 
      \\
      \lvar_{\ssa{c}'} \cup \{\ssa{\bar{x}}\}
      & \ssa{c}   = \ewhile ([\sbexpr]^{l}, [\ssa{\bar{x}, \bar{x_2}, \bar{x_2}}], \ssa{c}')
\end{array}
\right.
$$
\end{defn}
%
\begin{defn}[Query Variables ($\qvar_{c} \subseteq \mathcal{VAR} \times \mathbb{N}$)].
\\
Given a program $c$, its query variables $\qvar$ is a vector containing all variables newly assigned by a query in the programm, $\qvar \subset \mathcal{VAR}$.
It is defined as follows:
$$
  \qvar_{\ssa{c}} \triangleq
  \left\{
  \begin{array}{ll}
      \{\}                  
      & \ssa{c} = [\ssa{\assign x e}]^{(l, w)} 
      \\
      \{\ssa{x}^l\}                  
      & \ssa{c} = [\ssa{\assign x \query(\qexpr)}]^{(l, w)} 
      \\
      \qvar_{\ssa{c_1}} \cup \qvar_{\ssa{c_2}}  
      & \ssa{c} = \ssa{c_1};\ssa{c_2}
      \\
      \qvar_{\ssa{c_1}} \cup \qvar_{\ssa{c_2}} \cup \{\ssa{\bar{x}, \bar{y}, \bar{z}}\} 
      & \ssa{c} =\eif([\sbexpr]^{l} , \ssa{[\bar{x}, \bar{x_2}, \bar{x_2}], 
      [\bar{y}, \bar{y_2}, \bar{y_3}], 
      [\bar{z}, \bar{z_2}, \bar{z_3}], c_1, c_2}) 
      \\
      \qvar_{\ssa{c}'} \cup \{\ssa{\bar{x}}\}
      & \ssa{c}   = \ewhile ([\sbexpr]^{l}, [\ssa{\bar{x}, \bar{x_2}, \bar{x_2}}], \ssa{c}')
\end{array}
\right.
$$
\end{defn}
%
%
%
\subsection{ Trace-based Adaptivity}
%
%
% 
%
%
%
\begin{defn}
[Value Dependency of Events]
\label{def:event_valdep}.
\\
One event $\event_2$ may have a value dependency on an assignment event $\event_1$ or 
in a program $\ssa{c}$
with hidden database $D$, denoted as 
%
$\eventdep^{val}(\event_1, \event_2, c, D)$, where $\event_1 = (\ssa{x}_1, l_1, n_1, v_1) $ or 
$\event_1 = (\ssa{x}_1, \qval_1, v_1, l_1, n_1)$
%
\[
\exists \vtrace_0,
\vtrace_1, \vtrace_2, \vtrace_2', \ssa{c}_1, \ssa{c}_2.
  \left(
  \begin{array}{l}   
\config{\ssa{c}, \vtrace_0} \rightarrow^{*} 
\config{\ssa{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{\ssa{c}_2,  \vtrace_1 \cdot \event_1 \vtrace_2 \cdot \event_2 } 
  % 
 \\ 
 \bigwedge
  \config{\ssa{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{\ssa{c}_2,  \vtrace_1 \cdot \event_1 \vtrace_2' \cdot \event_2' } 
\\
\bigwedge
\event_2 \eventneq \event_2' \land \event_2 \sigeq \event_2'
\end{array}
\right)
 \]
%
\end{defn}
%
\begin{defn}
[Testing Dependency of Events]
\label{def:event_testdep}.
\\
One event $\event_2$ may have a testing dependency on a testing event $\event_1 = (\ssa{b}_1, l_1, n_1, v_1)$
in a program $\ssa{c}$, with a hidden database $D$, 
denoted as 
%
$\eventdep^{test}(\event_1, \event_2, c, D)$, is defined as follows: 
%
\[
\exists \vtrace_0,
\vtrace_1, \vtrace_2, \vtrace_2', \ssa{c}_1, \ssa{c}_2.
  \left(
  \begin{array}{l}   
\config{\ssa{c}, \vtrace_0} \rightarrow^{*} 
\config{\ssa{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{\ssa{c}_2,  \vtrace_1 \cdot \event_1 \vtrace_2 \cdot \event_2 } 
  % 
 \\ 
 \bigwedge
  \config{\ssa{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{\ssa{c}_2,  \vtrace_1 \cdot \event_1 \vtrace_2' } 
\\
\bigwedge
\event_2 \signeq \event_2'
\end{array}
\right)
 \]
%
\end{defn}
%
%
\begin{defn}[Event May Dependency].
\label{def:event_dep}
\\
One assignment event $\event_2$ may depend on another assignment event $\event_1$
in a program $\ssa{c}$, with a hidden database $D$, denoted as 
%
$\eventdep(\event_1, \event_2, c, D)$, is defined as follows: 
%
\[
\eventdep^{val}(\event_1, \event_2, c, D) 
\lor
\Big(
\exists \event_b \in \eventset^{test}. ~ \eventdep^{val}(\event_1, \event_b, c, D) 
\land \eventdep^{test}(\event_b, \event_2, c, D) 
\Big)
\] 
%
%
\end{defn}
%
\begin{defn}[Variable May Dependency].
\label{def:var_dep}
\\
Given a program $\ssa{c}$, 
one variable $\ssa{x}_2^{l_2} \in \lvar_{\ssa{c}}$ may depend on another variable 
$\ssa{x}_1^{l_1} \in \lvar_{\ssa{c}}$ in $\ssa{c}$ denoted as 
%
$\vardep(\ssa{x}_1^{l_1}, \ssa{x}_2^{l_2}, \ssa{c})$ is defined below.
%
\[
\exists \event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom. ~
\projl{\event_1} = (\ssa{x}_1, l_1)
\land
\projl{\event_2} = (\ssa{x}_2, l_2)
\land 
\eventdep(\event_1, \event_2, c, D)
\] 
%
%
\end{defn}
%
%
\begin{defn}[Execution Based Dependency Graph].
\\
Given a program $\ssa{c}$ with its assigned variables $\lvar_c$ 
the dependency graph $\traceG(\ssa{c}, D) = (\vertxs, \edges, \weights, \qflag)$ is defined as:
%
\[
\begin{array}{rlcl}
  \text{Vertices} &
  \vertxs & := & \left\{ 
  x^l \in \mathcal{VAR} \times \mathbb{N}
  ~ \middle\vert ~
  x^l \in \lvar({\ssa{c}})
  \right\}
  \\
  \text{Directed Edges} &
  \edges & := & 
  \left\{ 
  (x^l, x'^{l'}) \in (\mathcal{VAR} \times \mathbb{N}) \times (\mathcal{VAR} \times \mathbb{N})
  ~ \middle\vert ~
  \vardep(x^l, x'^{l'}, c) \land
  x^l, x'^{l'} \in \lvar({\ssa{c}})
  \right\}
  \\
  \text{Weights} &
  \weights & := & 
  \left\{ 
  (x^l, n) \in \mathcal{VAR} \times \mathbb{N}
  ~ \middle\vert ~ 
  x^l \in \lvar({\ssa{c}}) 
  \forall \vtrace, s.t.,
  \config{\ssa{c}, } \to^{*} \config{\eskip, \vtrace},
  n = \max_{\vtrace}\vcounter(\vtrace)l; 
  \right\}
  \\
  \text{Query Flags} &
  \qflag & := & 
  \left\{(x^l, n)  \in \vertxs \times \{0, 1\} 
  ~ \middle\vert ~
  \left\{
  \begin{array}{ll}
  n = 1 & x^l \in \qvar({\ssa{c}}) \\ 
  n = 0 & o.w.
  \end{array}
  \right\};
  x^l \in \lvar({\ssa{c}})
  \right\}
\end{array}
\]
\end{defn}
%
%
\begin{defn}[Finite Walk ($k$)].
\label{def:finitewalk}
\\
Given a labeled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, a \emph{finite walk} $k$ in $G$ is a sequence of edges $(e_1 \ldots e_{n - 1})$ 
for which there is a sequence of vertices $(v_1, \ldots, v_{n})$ such that:
\begin{itemize}
    \item $e_i = (v_{i},v_{i + 1})$ for every $1 \leq i < n$.
    \item every vertex $v \in \vertxs$ appears in this vertices sequence $(v_1, \ldots, v_{n})$ of $k$ at most $W(v)$ times.  
\end{itemize}
$(v_1, \ldots, v_{n})$ is the vertex sequence of this walk.
\\
%
Length of this finite walk $k$ is the number of vertices in its vertex sequence, i.e., $\len(k) = n$.
\end{defn}
%
Given a labeled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, 
we use $\walks(G)$ to denote a set containing all finite walks $k$ in $G$;
and $k_{v_1 \to v_2} \in \walks(G)$where $v_1, v_2 \in \vertxs$ denotes the walk from vertex $v_1$ to $v_2$ .
%
%
\begin{defn}[Length of Finite Walk w.r.t. Query ($\qlen$)].
\label{def:qlen}
\\
Given a labeled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$ and a \emph{finite walk} $k$ in $G$ with its vertex sequence $(v_1, \ldots, v_{n})$, the length of $k$ w.r.t query is defined as:
\[
  \qlen(k) = \len\big(
  v \mid v \in (v_1, \ldots, v_{n}) \land \flag(v) = 1 \big)
\]
, where $\big(v \mid v \in (v_1, \ldots, v_{n}) \land \flag(v) = 1 \big)$ is a subsequence of $k$'s vertex sequence.
\end{defn}
%
Given a program $c$ with a database $D$, we generate its program-based graph 
$\traceG(\ssa{c}, D) = (\vertxs, \edges, \weights, \qflag)$.
%
Then the adaptivity bound based on program analysis for $\ssa{c}$ is the number of query vertices on a finite walk in $\progG(\ssa{c})$. This finite walk satisfies:
%
\begin{itemize}
\item the number of query vertices on this walk is maximum
\item the visiting times of each vertex $v$ on this walk is bound by its weight $\weights(v)$.
\end{itemize}
%
It is formally defined in \ref{def:trace_adapt}.
%
\begin{defn}
[Adaptivity of A Program].
\label{def:trace_adapt}
\\
Given a program $\ssa{c}$ in SSA language, 
its adaptivity is defined for all possible starting SSA memory $\ssa{m}$ and database $D$ as follows:
%
$$
A(c) = \max \big 
\{ \qlen(k) \mid D \in \dbdom , k \in \walks(\traceG(c, D) \big \} 
$$
\end{defn}
%
%
%
%
\todo{
The following lemma describes a property of the trace-based dependency graph.
For any program $c$ with a database $D$ and a starting memory $m$,
the directed edges in its trace-based dependency graph can only be constructed from nodes representing 
smaller annotated queries to annotated queries of greater order.
There doesn't exist backward edges with direction from greater annotated queries to smaller ones.
}
\begin{lem}
\label{lem:edgeforwarding}
[Edges are Forwarding Only].
\\
%
Given a program $c$, a database $D$, a starting memory $m$ and the corresponding trace-based dependency graph $G(c,D) = (\vertxs, \edges)$, 
for any directed edge $(\event', \event) \in \edges$, 
this is not the case that:
%
$$\event' \eventgeq \event$$
%
\end{lem}
%
\begin{proof}
Proof in File: {\tt ``edge\_forward.tex''}.
% \input{edge_forward}
\end{proof}
%
%
%
\begin{lem}
\label{lem:DAG}
[Trace-based Dependency Graph is Directed Acyclic].
\\
%
{
Every trace-based dependency graph is a directed acyclic graph.
}
\end{lem}
%
{
\begin{proof}
Proof is obvious based on the Lemma \ref{lem:edgeforwarding}.
\end{proof}
}
%
\begin{lem}
[Adaptivity is Bounded].
\\
{
Given the program $c$ with a certain database $D$ and starting memory $m$, the $A(c)$ w.r.t. the $D$ and $m$ is bounded, i.e.,:
%
\[
\config{m, c, [], []} 
\rightarrow^{*} 
\config{m', \eskip, t', w'} 
\implies
A_{D, m}(c) \leq |t'|
\]
}
\end{lem}
%
\begin{proof}
{
Proof is obvious based on the Lemma \ref{lem:DAG}.
}
\end{proof}
%
%
\clearpage
%
%
% \subsection{SSA Transformation and Soundness of Transformation}
% in File {\tt ``ssa\_transform\_sound.tex''}
% \input{ssa_transform_sound}
%
\clearpage