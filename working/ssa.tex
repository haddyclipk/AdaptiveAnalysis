%
%
\subsection{Labeled Language}
\[
\begin{array}{llll}
\mbox{Arithmetic Operators} 
& \oplus_a & ::= & + ~|~ - ~|~ \times 
%
~|~ \div \\  
\mbox{Boolean Operators} 
& \oplus_b & ::= & \lor ~|~ \land
\\
%
\mbox{Relational Operators} 
& \sim & ::= & < ~|~ \leq ~|~ == 
\\  
%
\mbox{Label} 
& l & := & \mathbb{N} 
\\ 
%
\mbox{Arithmetic Expression} 
& \aexpr & ::= & 
n ~|~ {x} ~|~ \aexpr \oplus_a \aexpr  
\\
%
\mbox{Boolean Expression} & \bexpr & ::= & 
%
\etrue ~|~ \efalse  ~|~ \neg \bexpr
 ~|~ \bexpr \oplus_b \bexpr
%
~|~ \aexpr \sim \aexpr 
\\
%
\mbox{Expression} & \expr & ::= & v ~|~ \aexpr \sep \bexpr ~|~ [\expr, \dots, \expr]
\\  
%
\mbox{Value} 
& v & ::= & { n \sep \etrue \sep \efalse ~|~ [] ~|~ [v, \dots, v]}  
\\
%
\mbox{Query Expression} 
& {\qexpr} & ::= 
& { \qval ~|~ \aexpr ~|~ \qexpr \oplus_a \qexpr ~|~ \chi[\aexpr]} 
\\
%
\mbox{Query Value} & \qval & ::= 
& {n ~|~ \chi[n] ~|~ \chi[n] \oplus_a  \chi[n] ~|~ n \oplus_a  \chi[n]
~|~ \chi[n] \oplus_a  n}
\\
%
\mbox{Labeled Command} 
& {c} & ::= &   [\assign {{x}}{ {\expr}}]^{l} ~|~  [\assign {{x} } {{\query(\qexpr)}}]^{l}
~|~ {\ewhile [ \bexpr ]^{l} \edo {c} }
\\
&&&
~|~ {c};{c}  
~|~ \eif([\bexpr]{}^l , {c}, {c}) 
~|~ [\eskip]^{l} 
\\
%
\mbox{Event} 
& \event & ::= & 
    ({x}, l, n, v) | ({x}, l, n, \qval, v)  ~~~~~~~ \mbox{Assignment Event} \\
&&& | (\bexpr, l, n, v)   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \mbox{Testing Event}
\\
%
\mbox{Trace} & \vtrace
& ::= & \cdot | \vtrace \cdot \event
% \\
% %
% \mbox{Event Signature} & \sig
% & ::= & (x, l, n) | (x, l, n, \query) | (b, l, n)
% \\
% %
\end{array}
\]
We use following notations to represent the set of corresponding terms:
\[
\begin{array}{lll}
\mathcal{SVAR} & : & \mbox{Set of Variables}  
\\ 
%
\mathcal{VAL} & : & \mbox{Set of Values} 
\\ 
%
\mathcal{QVAL} & : & \mbox{Set of Query Values} 
\\ 
%
\mathcal{SIG} & : & \mbox{Set of Event Signature} 
\\ 
%
\eventset  & : & \mbox{Set of Events}  
\\
%
%
\eventset^{\asn}  & : & \mbox{Set of Assignment Events}  
\\
%
\eventset^{\test}  & : & \mbox{Set of Testing Events}  
\\
%
%%
\dbdom  & : & \mbox{{Set of Databases}} 
\\
%
\qdom = {[-1,1]} & : & \mbox{{Domain of Query Results}}
\\
%
\mathcal{T} & : & \mbox{Set of Well-formed Traces (in Definition~\ref{def:wf_trace})}
\end{array}
\]
%
%
%
Environment $ \env : \mathcal{T}  \to \mathcal{SVAR} \to \mathcal{VAL} \cup \{\bot\}$
\[
\begin{array}{lll}
\env(\vtrace  \cdot (x, l, n, v)) x \triangleq v
&
\env(\vtrace \cdot (x, l, n, \qval, v)) x \triangleq v
&
\env(\vtrace \cdot (y, l, n, v)) x \triangleq \env(\vtrace) x
\\
\env(\vtrace \cdot (b, l, n, v)) x \triangleq \env(\vtrace) x
&
\env(\cdot ) x \triangleq \bot
&
\end{array}
\]
%
%
Query Environment $\qenv: \mathcal{T}  \to \mathcal{SVAR} \to \mathcal{QVAL} \cup \{\bot\}$
\[
\begin{array}{lll}
\qenv(\vtrace \cdot (x, l, n, v) ) x \triangleq \qenv(\vtrace) x
&
\qenv(\vtrace \cdot (x, l, n, \qval, v) ) x \triangleq \qval
&
\qenv(\vtrace \cdot (y, l, n, v)) x \triangleq \env(\vtrace) x
\\
\qenv(\vtrace \cdot (b, l, n, v)) x \triangleq \env(\vtrace) x
&
\qenv(\cdot ) x \triangleq \bot
&
\end{array}
\]
%

%
\subsection{Trace-based Operational Semantics for Language}
%
%
%
{
\begin{mathpar}
\boxed{ \config{\trace,\aexpr} \aarrow v \, : \, \mbox{Trace  $\times$ Arithmetic Expr $\Rightarrow$ Arithmetic Value} }
\\
\boxed{ \config{\trace, \bexpr} \barrow v \, : \, \mbox{Trace $\times$ Boolean Expr $\Rightarrow$ Boolean Value} }
\\
\boxed{ \config{\trace, \expr} \earrow v \, : \, \mbox{Trace $\times$ Expression $\Rightarrow$ Value} }
\\
\inferrule{ 
  \config{\trace, \aexpr} \aarrow v
}{
 \config{\trace,  \aexpr} 
 \earrow v
}
\and
\inferrule{ 
  \config{\trace, \bexpr} \barrow v
}{
 \config{\trace,  \bexpr} 
 \earrow v
}
\and
\inferrule{ 
  \config{\trace, \expr_1} \earrow v_1
  \cdots
  \config{\trace, \expr_n} \earrow v_n
}{
 \config{\trace,  [\expr_1, \cdots, \expr_n]} 
 \earrow [v_1, \cdots, v_n]
}
\and
\inferrule{ 
  \empty
}{
 \config{\trace,  v} 
 \earrow v
}
\\
\boxed{ \config{\trace, \qexpr} \qarrow \qval \, : \, \mbox{Trace  $\times$ Query Expr $\Rightarrow$ Query Value} }
\\
\inferrule{ 
  \config{\trace, \aexpr} \aarrow n
}{
 \config{\trace,  \aexpr} 
 \qarrow n
}
\and
\inferrule{ 
  \config{\trace, \qexpr_1} \qarrow \qval_1
  \and
  \config{\trace, \qexpr_2} \qarrow \qval_2
}{
 \config{\trace,  \qexpr_1 \oplus_a \qexpr_2} 
 \qarrow \qval_1 \oplus_a \qval_2
}
\and
\inferrule{ 
  \config{\trace, \aexpr} \aarrow n
}{
 \config{\trace, \chi[\aexpr]} \qarrow \chi[n]
}
\and
\inferrule{ 
  \empty
}{
 \config{\trace,  \qval} 
 \qarrow \qval
}
 \end{mathpar}
%
The trace based operational semantics are defined in Figure \ref{fig:os_ssa}.
%
\begin{figure}
{
\begin{mathpar}
\boxed{
\mbox{Command $\times$ Trace}
\xrightarrow{}
\mbox{Command $\times$ Trace}
}
\and
\boxed{\config{{c, \vtrace}}
\xrightarrow{} 
\config{{c',  \vtrace'}}
}
\\
%
\inferrule
{
\event = ({x}, l, \vcounter(\vtrace) l + 1, v)
}
{
\config{[\assign{{x}}{\aexpr}]^{l},  \vtrace } 
\xrightarrow{} 
\config{[\eskip]^{l}, \vtrace \cdot \event }
}
~\textbf{assn}
%
\and
%
{
\inferrule
{
 \vtrace, \qexpr \qarrow \qval
 \and 
\query(\qval) = v
\and 
\event = ({x}, l, \vcounter(\vtrace) l + 1, \qval, v)
}
{
\config{{[\assign{x}{\query(\qexpr)}]^l, \vtrace}}
\xrightarrow{} 
\config{{\eskip,  \vtrace \cdot \event} }
}
~\textbf{query}
}
%
\and
%
\inferrule
{
 \vtrace, b \barrow \etrue
 \and 
 \event = (b, l, \vcounter(\vtrace) l + 1, \etrue)
}
{
\config{{\ewhile [b]^{l} \edo c, \vtrace}}
\xrightarrow{} 
\config{{
c[\bar{x_i}/\bar{x'}]; \ewhile [b]^{l} \edo c,  \eskip),
\vtrace \cdot \event}}
}
~\textbf{while-t}
%
%
\and
%
\inferrule
{
 \vtrace, b \barrow \efalse
 \and 
 \event = (b, l, \vcounter(\vtrace) l + 1, \efalse)
}
{
\config{{\ewhile [b]^{l}, \edo c, \vtrace}}
\xrightarrow{} 
\config{{
[\eskip]^l ,
\vtrace \cdot \event}}
}
~\textbf{while-f}
%
%
\and
%
%
\inferrule
{
\config{{c_1, \vtrace}}
\xrightarrow{}
\config{{c_1',  \vtrace'}}
}
{
\config{{c_1; c_2, \vtrace}} 
\xrightarrow{} 
\config{{c_1'; c_2, \vtrace'}}
}
~\textbf{seq1}
%
\and
%
\inferrule
{
  \config{{c_2, \vtrace}}
  \xrightarrow{}
  \config{{c_2',  \vtrace'}}
}
{
\config{{[\eskip]^{l} ; c_2, \vtrace}} \xrightarrow{} \config{{ c_2', \vtrace'}}
}
~\textbf{seq2}
%
\and
%
%
\inferrule
{
   \vtrace, b \barrow \etrue
 \and 
 \event = (b, l, \vcounter(\vtrace) l + 1, \etrue)
}
{
\config{{
\eif([\etrue]^{l}, c_1, c_2), 
\vtrace}}
\xrightarrow{} 
\config{{c_1, \vtrace \cdot \event}}
}
~\textbf{if-t}
%
\and
%
\inferrule
{
 \vtrace, b \barrow \efalse
 \and 
 \event = (b, l, \vcounter(\vtrace) l + 1, \efalse)
}
{
\config{{\eif([\efalse]^{l}, c_1, c_2), \vtrace}}
\xrightarrow{} 
\config{{c_2, \vtrace \cdot \event}}
}
~\textbf{if-f}
% %
%
%
\end{mathpar}
}
% \end{subfigure}
    \caption{Trace-based Operational Semantics for Language.}
    \label{fig:os_ssa}
\end{figure}
%
%
%
%
%
%
%
\clearpage