
%
\section{Event and Trace}
%
%
Environment $ \env : \vtrace \to \mathcal{SVAR} \to \mathcal{VAL} \cup \{\bot\}$
\[
\begin{array}{ll}
\env(\vtrace \cdot (x, l, n, v)) x \triangleq v
&
\env(\vtrace \cdot (x, l, n, \qval, v)) x \triangleq v
\\
\env(\vtrace \cdot (y, l, n, v)) x \triangleq \env(\vtrace) x
&
\env() x \triangleq \bot
\end{array}
\]
%
Query Environment $\qenv: \vtrace \to \mathcal{SVAR} \to \qval \cup \{\bot\}$
\[
\begin{array}{ll}
\qenv(\vtrace \cdot (x, l, n, v)) x \triangleq \qenv(\vtrace) x
&
\qenv(\vtrace \cdot (x, l, n, \qval, v)) x \triangleq \qval
\\
\qenv(\vtrace \cdot (y, l, n, v)) x \triangleq \qenv(\vtrace) x
&
\qenv() x \triangleq \bot
\end{array}
\]
%
Event Value : $\pi_v : \eventset \to \mathcal{VAL}$
\[
\begin{array}{ll}
\pi_v((x, l, n, v)) \triangleq v
&
\pi_v (x, l, n, \qval, v) \triangleq v
\\
\pi_v (b, l, n, v)  \triangleq v
&
\end{array}
\]
%
Event Query Value : $\pi_{q} : \eventset \to \mathcal{VAL}$
\[
\begin{array}{ll}
\pi_{q} (x, l, n, v) \triangleq v
&
\pi_{q} (x, l, n, \qval, v) \triangleq \qval
\\
\pi_{q} (b, l, n, v)  \triangleq v
&
\end{array}
\]%
% 
Event Signature : $\pi_{\sig} : \eventset \to \mathcal{VAL}$
\[
\begin{array}{ll}
\pi_{\sig} (x, l, n, v) \triangleq (x, l, n)
&
\pi_{\sig} (x, l, n, \qval, v) \triangleq (x, l, n, \query)
\\
\pi_{\sig} (b, l, n, v)  \triangleq (b, l, n)
&
\end{array}
\]
%
Equivalence of 2 events : $\event_1 \eventeq \event_2$
\[
\event_1 \eventeq \event_2 \triangleq
\left\{
\begin{array}{ll}
\etrue & \event_1 = (x, l, n, v) \land \event_2 = (x, l, n, v) \\
\etrue & \event_1 = (x, l, n, \qval_1, v) \land \event_2 = (x, l, n, \qval_2, v)  
\land \qval_1 =_{q} \qval_2\\
\etrue & \event_1 = (b, l, n, v) \land \event_2 = (b, l, n, v) \\
\efalse & o.w.
\end{array}
\right.
\]
%
Signature Equivalence of 2 events : $\event_1 \sigeq \event_2$
\[
\event_1 \sigeq \event_2 \triangleq
\left\{
\begin{array}{ll}
\etrue & \event_1 = (x, l, n, v) \land \event_2 = (x, l, n, v') \\
\etrue & \event_1 = (x, l, n, \qval, v) \land \event_2 = (x, l, n, \qval', v') \\
\etrue & \event_1 = (b, l, n, v) \land \event_2 = (b, l, n, v') \\
\efalse & o.w.
\end{array}
\right.
\]
%
%
\begin{defn}[Equivalence of Query].
%
\label{def:query_equal}
Given a trace $\trace$ and 2 query expressions $\qexpr_1$, $\qexpr_2$:
$$
\qexpr_1 =_{q}^{\trace} \qexpr_2 \triangleq
\left\{
    \begin{array}{ll} 
      \etrue      
      & 
    \exists \qval_1, \qval_2.
    \begin{array}{l} 
      (\config{\trace,  \qexpr_1} \qarrow \qval_1 \land \config{\trace,  \qexpr_2 } \qarrow \qval_2) 
      \\
      \land (\forall r \in \qdom. \exists v. ~ s.t., ~ 
            \config{\trace, \qval_1[r/\chi]} \aarrow v \land \config{\trace,  \qval_2[r/\chi] } \aarrow v)  
    \end{array}\\
      \efalse         
      & \text{o.w.} 
    \end{array}
    \right.
$$
%
, where $FV(\qexpr)$ is the set of free variables in the query expression $\qexpr$.
$\qexpr_1 \neq_{q}^{\trace} \qexpr_2$  is defined vice versa.
%
We use $=_{q}$  and $\neq_{q}$ as the shorthands when $\trace$ is empty.
\end{defn}
%
\begin{defn}[Order of Events].
\label{def:query_dir}
\\
Given 2 events 
$\event_1 = (x_1, l_1, n_1), 
\event_2 = (x_2, l_2, n_2)$
:
%
\[
\event_1 \eventlt \event_2
 \triangleq 
 \left\{
 \begin{array}{ll}
    l_1 < l_2 & n_1 = n_2
    \\
    n_1 < n_2  & o.w.
\end{array}  
\right.
\]
%
$\event_1 \eventgeq \event_2$  is defined vice versa.
\end{defn}
%
%
%
%
%
%
Given an annotated query $\event$, $\event$ belongs to a trace $\trace$, i.e., $\event \eventin \trace$ are defined as follows:
    %
\begin{equation}
    \event \eventin \trace  
    \triangleq \left\{
    \begin{array}{ll} 
      \etrue                  & \trace =  (\trace' \cdot \event') \land (\event \eventeq \event') \\
      \event \eventin \trace' & \trace =  (\trace' \cdot \event') \land (\event \eventneq \event') \\ 
      \efalse                 & o.w.
    \end{array}
    \right.
  \end{equation}
  %
Given an event $\event$, $\event$ signature belongs to a trace $\trace$, i.e., $\event \sigin \trace$ are defined as follows:
    %
\begin{equation}
    \event \sigin \trace  
    \triangleq \left\{
    \begin{array}{ll} 
      \etrue                  & \trace =  (\trace' \cdot \event') \land (\event \sigeq \event') \\
      \event \sigin \trace'   & \trace =  (\trace' \cdot \event') \land (\event \signeq \event') \\ 
      \efalse                 & o.w.
    \end{array}
    \right.
  \end{equation}
  %
  %
%
\begin{defn}[Equivalence of Program]
%
\label{def:aq_prog}
Given 2 programs $c_1$ and $c_2$:
\[
c_1 =_{c} c_2
 \triangleq 
 \left\{
    \begin{array}{ll} 
      \etrue        
      & c_1 = \eskip \land c_2 = \eskip
      \\ 
      \forall m. \exists v. ~ \config{m, \expr_1} \aarrow^{*} v \land \config{m, \expr_1} \aarrow^{*} v     
      & c_1 = \assign{x}{\expr_1} \land c_2 = \assign{x}{\expr_2} 
      \\ 
      \qexpr_1 =_{q} \qexpr_2       
      & c_1 = \assign{x}{\query(\qexpr_1)} \land c_1 = \assign{x}{\query(\qexpr_2)} 
      \\
      c_1^f =_{c} c_2^f \land c_1^t =_{c} c_2^t
      & c_1 = \eif(b, c_1^t, c_1^f) \land c_2 = \eif(b, c_2^t, c_2^f)
      \\ 
      c_1' =_{c} c_2'         
      & c_1 = \ewhile b \edo c_1' \land c_2 = \ewhile b \edo c_2'
      \\ 
      c_1^h =_{c} c_2^h \land c_1^t =_{c} c_2^t
      & c_1 = c_1^h;c_1^t \land c_2 = c_2^h;c_2^t 
    \end{array}
    \right.
\]
%
$c_1 \neq_{c} c_2$  is defined vice versa.
%
\end{defn}
%
Given 2 programs $c$ and $c'$, $c'$ is a sub-program of$c$, i.e., $c' \in_{c} c$ is defined as:
\begin{equation}
c' \in_{c} c \triangleq \exists c_1, c_2, c''. ~ s.t.,~
c =_{c} c_1; c''; c_2 \land c' =_{c} c''
\end{equation} 
%
\todo{
\begin{defn}[Well-formed Trace]
\label{def:wf_trace}
A trace $\trace$ is well formed, i.e., $\trace \in \mathbb{T}$ if and only if it preserves the following two properties:
\begin{itemize}
  \item{\emph{(Uniqueness)}} $\forall \event_1, \event_2 \eventin \trace. ~ (\event_1 \eventneq \event_2)$
  %
  \item{\emph{(Ordering)}} $\forall \event_1, \event_2 \eventin \trace. ~ 
  (\event_1 \eventlt \event_2) \Longleftrightarrow
  \exists \trace_1, \trace_2, \trace_3 \in \mathbb{T},
   \event_1', \event_2' \in \eventset. ~ s.t.,~ 
  (\event_1 \eventeq \event_1') \land (\event_2 \eventeq \event_2') \land t_1 \cdot \event_1' \cdot t_2 \cdot \event_2' \cdot \trace_3 = \trace$
\end{itemize}
\end{defn}
}
\\
\todo{
\begin{thm}[Trace Generated from Operational Semantics is Well-formed].
\label{thm:os_wf_trace}
\\
Given a program $c$ with arbitrary initial trace $\vtrace \in \mathbb{T}$,
if $\config{c, \vtrace} \to^{*} 
\config{m', \eskip, \vtrace'}$, then $(\vtrace' - \vtrace)$ is a well formed trace with respect to program $c$ and $w$, denoted as $c \vDash \vtrace' - \vtrace$.
% \wq{ we call a trace $t$ satisfies the program $c$ in the memory $m$, denoted as $m, c \vDash t$, if
% there exists the evaluation 
% $\config{m, c, [], []} \to^{*} \config{m', \eskip, t, w}$, and
% $t$ is well-formed. }
\end{thm}
\begin{proof}
Proof in File: {\tt ``thm\_os\_wf\_trace.tex''}.
% \input{thm_os_wf_trace}
\end{proof}
}
%
% \\
%
%
\todo{
\begin{lem}[While Map Remains Unchanged (Invariant)]
\label{lem:wunchange}
Given a program $c$ with a starting memory $m$, trace $t$ and while map $w$, s.t.,
$\config{m, c, t, w} \to^{*} \config{m', \eskip, t', w'}$ and $Labels(c) \cap Keys(w) = \emptyset$, then 
\[
  w = w'
\]
\end{lem}
\begin{subproof}[Proof of Lemma~\ref{lem:wunchange}]
%
Proof in File: {\tt ``lem\_wunchange.tex''}
% \input{lem_wunchange}
%
\end{subproof}
}
%
\todo{
\begin{lem}[Trace is Written Only]
\label{lem:twriteonly}
Given a program $c$ with starting trace $t_1$ and $t_2$,
for arbitrary starting memory $m$ and while map $w$,
if there exist evaluations
$$\config{m, c, t_1, w} \to^{*} \config{m_1', \eskip, t_1', w_1'}$$
% 
$$\config{m, c, t_2, w} \to^{*} \config{m_2', \eskip, t_2', w_2'}$$
%
then:
%
\[
  m_1' = m_2' \land w_1' = w_2'
\]
\end{lem}
%
\begin{subproof}[Proof of Lemma~\ref{lem:twriteonly}]
%
Proof in File: {\tt ``lem\_twriteonly.tex''}
% \input{lem_twriteonly}
\end{subproof}
}
%
\todo{
\begin{lem}[Trace Uniqueness]
\label{lem:tunique}
Given a program $c$ with a starting memory $m$, \wq{a while map w,}
for any starting trace $t_1$ and $t_2$, if there exist evaluations
$$\config{m, c, t_1, w} \to^{*} \config{m_1', \eskip, t_1', w_1'}$$
% 
$$\config{m, c, t_2, w} \to^{*} \config{m_2', \eskip, t_2', w_2'}$$
%
then:
%
\[
  t_1' - t_1 = t_2' - t_2
\]
\end{lem}
%
\begin{subproof}[Proof of Lemma~\ref{lem:tunique}]
%
Proof in File: {\tt ``lem\_tunique.tex''}
% \input{lem_tunique}
\end{subproof}
}
%
\todo{
\begin{coro}
\label{coro:aqintrace}
\[
\event \eventin t \implies \exists t_1, t_2, \event'. ~ s.t., ~ (\event \eventeq \event') \land t_1 \cdot [\event'] \cdot t_2 = t  
\]
\end{coro}
\begin{subproof}
Proof in File: {\tt ``coro\_aqintrace.tex''}
% \input{coro_aqintrace}
%
\end{subproof}
}
%
\begin{lem}
[Trace Non-Decreasing].
\\
\jl{
For any program $c$ with a starting memory $m$, trace $t$ and while map $w$: 
$$
\config{m, c, t, w} 
\rightarrow
\config{m, c', t', w'} \implies \exists ~ t'', ~ s.t., ~ t \cdot t'' = t'
$$
}
\end{lem}
%
\begin{proof}
{
Proof is obvious by induction on the operational semantic rules applied in the transition 
.
\\
By induction on the operational semantic rules applied in the transition $\config{m, c, t, w} 
\rightarrow
\config{m, c', t', w'}$, 
we have cases for each rule.
By observation on the rules, 
the trace $t$ remains unchanged in all the rules except the only one \textbf{query-v}.
So, the rule \textbf{query-v} is the only interesting case to be discussed as following.
\begin{itemize}
\caseL{
\[
  \inferrule
  {
  \query(\qval) = v
  }
  {
  \config{m, [\assign{x}{\query(\qval)}]^l, t, w} \xrightarrow{}  
  \config{m, \eskip, t \cdot [(\qval, l, w)], w}
  }
  ~\textbf{query-v}
\]
}
%
In this case, we have $c' = \eskip$, 
$t' = t \cdot [(\qval, l, w)]$, $m' = m[v/x]$ and $w' = w$.
\\
Let $t'' = [(\qval, l, w)]$, we have $t \cdot [(\qval, l, w)] = t'$,
i.e., $t \cdot t'' = t'$. This case is proved.
\end{itemize}
}
\end{proof}
%
}
%
%
\clearpage
%
%
% \subsection{SSA Transformation and Soundness of Transformation}
% in File {\tt ``ssa\_transform\_sound.tex''}
% \input{ssa_transform_sound}
%
\clearpage