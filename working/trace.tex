%
\subsection{Trace}
Trace appending:
\[
  \trace \cdot \event \triangleq
  \left\{
  \begin{array}{ll} 
    {} \cdot \event           & \trace =  \cdot \\
    \trace \cdot \event    & \trace =  \trace' \cdot \event\\ 
  \end{array}
  \right.
\]
%
Trace concatenation:
\[
  \trace_1 \cdot \trace_2 \triangleq
  \left\{
  \begin{array}{ll} 
    \trace_1                                  & \trace_2 =  \cdot \\
    (\trace_1 \cdot \event) \cdot \trace_2'    & \trace_2 =  {} \cdot \event \cdot \trace_2'\\ 
  \end{array}
  \right.
\]
%
An event $\event \in \eventset$ belongs to a trace $\trace$, i.e., $\event \eventin \trace$ are defined as follows:
%
\begin{equation}
  \event \eventin \trace  
  \triangleq \left\{
  \begin{array}{ll} 
    \etrue                  & \trace =  (\trace' \cdot \event') \land (\event \eventeq \event') \\
    \event \eventin \trace' & \trace =  (\trace' \cdot \event') \land (\event \eventneq \event') \\ 
    \efalse                 & o.w.
  \end{array}
  \right.
\end{equation}
%
A well-formed event $\event \in \eventset$ belongs to a trace $\trace$ in signature, 
i.e., $\event \sigin \trace$ are defined as follows:
  %
\begin{equation}
  \event \sigin \trace  
  \triangleq \left\{
  \begin{array}{ll} 
    \etrue                  & \trace =  (\trace' \cdot \event') \land (\event \sigeq \event') \\
    \event \sigin \trace'   & \trace =  (\trace' \cdot \event') \land (\event \signeq \event') \\ 
    \efalse                 & o.w.
  \end{array}
  \right.
\end{equation}
%
%
%
\begin{defn}[Equivalence of Program]
%
\label{def:aq_prog}
Given 2 programs $c_1$ and $c_2$:
\[
c_1 =_{c} c_2
\triangleq 
\left\{
  \begin{array}{ll} 
    \etrue        
    & c_1 = \eskip \land c_2 = \eskip
    \\ 
    \forall \trace \in \mathcal{T} \st \exists v \in \mathcal{VAL}
    \st \config{ \trace, \expr_1} \aarrow v \land \config{ \trace, \expr_1} \aarrow v     
    & c_1 = \assign{x}{\expr_1} \land c_2 = \assign{x}{\expr_2} 
    \\ 
    \qexpr_1 =_{q} \qexpr_2       
    & c_1 = \assign{x}{\query(\qexpr_1)} \land c_1 = \assign{x}{\query(\qexpr_2)} 
    \\
    c_1^f =_{c} c_2^f \land c_1^t =_{c} c_2^t
    & c_1 = \eif(b, c_1^t, c_1^f) \land c_2 = \eif(b, c_2^t, c_2^f)
    \\ 
    c_1' =_{c} c_2'         
    & c_1 = \ewhile b \edo c_1' \land c_2 = \ewhile b \edo c_2'
    \\ 
    c_1^h =_{c} c_2^h \land c_1^t =_{c} c_2^t
    & c_1 = c_1^h;c_1^t \land c_2 = c_2^h;c_2^t 
  \end{array}
  \right.
\]
%
$c_1 \neq_{c} c_2$  is defined vice versa.
%
\end{defn}
%
Given 2 programs $c$ and $c'$, $c'$ is a sub-program of$c$, i.e., $c' \in_{c} c$ is defined as:
\begin{equation}
c' \in_{c} c \triangleq \exists c_1, c_2, c''. ~ s.t.,~
c =_{c} c_1; c''; c_2 \land c' =_{c} c''
\end{equation} 
%
%
\todo{
\[
\mbox{Post-Processed Trace} \qquad \posttrace \qquad ::= \qquad \cdot | \posttrace \cdot \event
% %
\]
%
Counter $\vcounter : \mathcal{T} \to \mathbb{N} \to \mathbb{N}$
\[
\begin{array}{lll}
\vcounter(\trace \cdot (x, l, v) ) l \triangleq \vcounter(\trace) l + 1
&
\vcounter(\trace \cdot (b, l, v)) l \triangleq \vcounter(\trace) l + 1
&
\vcounter(\trace \cdot (x, l, \qval, v)) l \triangleq \vcounter(\trace) l + 1
\\
\vcounter(\trace  \cdot (x, l', v)) l \triangleq \vcounter(\trace ) l
&
\vcounter(\trace \cdot (b, l', v)) l \triangleq \vcounter(\trace ) l
&
\vcounter(\trace \cdot (x, l', \qval, v)) l \triangleq \vcounter(\trace ) l
\\
\vcounter(\cdot) l \triangleq 0
&&
\end{array}
\]
%
Given a trace $\trace$, its post-processed trace $\posttrace$ is computed by a function $p : \trace \to \posttrace$ as follows:
\[
  \posttrace \triangleq
  \left\{
  \begin{array}{ll} 
  p(\trace' \cdot (x, l, v)) & = p(\trace') \cdot (x, l, \vcounter(\trace') l + 1, v) \\
  p(\trace' \cdot (b, l, v)) & = p(\trace') \cdot (b, l, \vcounter(\trace') l + 1, v) \\
  p(\trace' \cdot (x, l, \qval, v)) & = p(\trace') \cdot (x, l, \vcounter(\trace') l + 1, \qval, v) \\
  p(\cdot) & = \cdot
  \end{array}
  \right.
\]
A post-processed event $\postevent \in \eventset$ belongs to a post-processed trace $\posttrace$, i.e., $\event \eventin \trace$ are defined as follows:
%
\begin{equation}
  \postevent \eventin \posttrace  
  \triangleq \left\{
  \begin{array}{ll} 
    \etrue                  & \posttrace =  (\posttrace' \cdot \event') \land (\postevent \eventeq \event') \\
    \postevent \eventin \trace' & \posttrace =  (\posttrace' \cdot \event') \land (\postevent \eventneq \postevent') \\ 
    \efalse                 & o.w.
  \end{array}
  \right.
\end{equation}
%
A post-processed event $\event \in \eventset$ belongs to a post-processed trace $\trace$ in signature, 
i.e., $\event \sigin \trace$ are defined as follows:
  %
\begin{equation}
  \event \sigin \trace  
  \triangleq \left\{
  \begin{array}{ll} 
    \etrue                  & \trace =  (\trace' \cdot \event') \land (\event \sigeq \event') \\
    \event \sigin \trace'   & \trace =  (\trace' \cdot \event') \land (\event \signeq \event') \\ 
    \efalse                 & o.w.
  \end{array}
  \right.
\end{equation}
}
%
% $\mathcal{T}$ : Set of Well-formed Traces (in Definition~\ref{def:wf_trace})
%
%
% \\
%
\begin{defn}[Well-formed Trace $\mathcal{T^{p}}$]
\label{def:wf_trace}
A post-processed trace $\posttrace$ is well formed, i.e., $\trace \in \mathcal{T}$ if and only if it preserves the following two properties:
\begin{itemize}
\item{\emph{(Uniqueness)}} 
$\forall \event_1, \event_2 \eventin \trace \st \event_1 \signeq \event_2$
%
\item{\emph{(Ordering)}} $\forall \event_1, \event_2 \eventin \trace \st 
(\event_1 \eventlt \event_2) \Longleftrightarrow
\exists \trace_1, \trace_2, \trace_3 \in \mathbb{T},
 \event_1', \event_2' \in \eventset \st
(\event_1 \eventeq \event_1') \land (\event_2 \eventeq \event_2')
\land \trace_1 \cdot \event_1' \cdot \trace_2 \cdot \event_2' \cdot \trace_3 = \trace$
\end{itemize}
\end{defn}
%
%
\begin{thm}[Trace Generated from Operational Semantics after Post Processing is Well-formed $c \vDash \trace$].
\label{thm:os_wf_trace}
\\
\[
\forall \trace \in \mathcal{T}, c \st
\config{c, \vtrace} \to^{*} \config{\eskip, \trace \cdot \trace'} \land \trace' = p(\trace')
\implies
\vtrace' \in \mathcal{T}
\]
%
\end{thm}
\begin{proof}
Proof in File: {\tt ``thm\_os\_wf\_trace.tex''}.
% \input{thm_os_wf_trace}
\end{proof}
%
\begin{lem}
[Trace Non-Decreasing].
\\
$$
\forall \trace \in \mathcal{T}, c \st
\config{c, \trace} \rightarrow^{*} \config{\eskip, \trace'} 
\implies \exists \trace'' \in \mathcal{T} \st \trace \cdot \trace'' = \trace'
$$
\end{lem}
%
\begin{coro}
\label{coro:aqintrace}
\[
\event \eventin \trace \implies \exists \trace_1, \trace_2 \in \mathcal{T}, 
\event' \in \eventset \st (\event \eventeq \event') \land \trace_1 \cdot \event' \cdot \trace_2 = t  
\]
\end{coro}
\begin{subproof}
Proof in File: {\tt ``coro\_aqintrace.tex''}
% \input{coro_aqintrace}
%
\end{subproof}
% \\
%
%
% \todo{
% \begin{lem}[While Map Remains Unchanged (Invariant)]
% \label{lem:wunchange}
% Given a program $c$ with a starting memory $m$, trace $t$ and while map $w$, s.t.,
% $\config{m, c, t, w} \to^{*} \config{m', \eskip, t', w'}$ and $Labels(c) \cap Keys(w) = \emptyset$, then 
% \[
%   w = w'
% \]
% \end{lem}
% \begin{subproof}[Proof of Lemma~\ref{lem:wunchange}]
% %
% Proof in File: {\tt ``lem\_wunchange.tex''}
% % \input{lem_wunchange}
% %
% \end{subproof}
% }
%
% \todo{
% \begin{lem}[Trace is Written Only]
% \label{lem:twriteonly}
% Given a program $c$ with starting trace $t_1$ and $t_2$,
% for arbitrary starting memory $m$ and while map $w$,
% if there exist evaluations
% $$\config{m, c, t_1, w} \to^{*} \config{m_1', \eskip, t_1', w_1'}$$
% % 
% $$\config{m, c, t_2, w} \to^{*} \config{m_2', \eskip, t_2', w_2'}$$
% %
% then:
% %
% \[
%   m_1' = m_2' \land w_1' = w_2'
% \]
% \end{lem}
% %
% \begin{subproof}[Proof of Lemma~\ref{lem:twriteonly}]
% %
% Proof in File: {\tt ``lem\_twriteonly.tex''}
% % \input{lem_twriteonly}
% \end{subproof}
% }
%
% \todo{
% \begin{lem}[Trace Uniqueness]
% \label{lem:tunique}
% Given a program $c$ with a starting memory $m$, \wq{a while map w,}
% for any starting trace $t_1$ and $t_2$, if there exist evaluations
% $$\config{m, c, t_1, w} \to^{*} \config{m_1', \eskip, t_1', w_1'}$$
% % 
% $$\config{m, c, t_2, w} \to^{*} \config{m_2', \eskip, t_2', w_2'}$$
% %
% then:
% %
% \[
% t_1' - t_1 = t_2' - t_2
% \]
% \end{lem}
% %
% \begin{subproof}[Proof of Lemma~\ref{lem:tunique}]
% %
% Proof in File: {\tt ``lem\_tunique.tex''}
% % \input{lem_tunique}
% \end{subproof}
% }
%

%
%
%
%
%
%
%
% \subsection{SSA Transformation and Soundness of Transformation}
% in File {\tt ``ssa\_transform\_sound.tex''}
% \input{ssa_transform_sound}
%
\clearpage