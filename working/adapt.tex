%
\subsection{Trace-based Adaptivity}
% \subsection{Trace-based Adaptivity}
% \mg{This description is confusing. It is repeting something that was said before, e.g. ``the visiting times of each vertex $v$ on this walk is bound by its weight $\weights(v)$.'' buit it also say something new. Also it talks about program analysis which has not been defined, yet. I think it needs more work.}
% Given a program $c$, we generate its program-based graph 
% $\traceG({c}) = (\vertxs, \edges, \weights, \qflag)$.
% %
% Then the adaptivity bound based on program analysis for ${c}$ is the number of query vertices on a finite walk in $\traceG({c})$. This finite walk satisfies:
% %
% \begin{itemize}
% \item the number of query vertices on this walk is maximum
% \item the visiting times of each vertex $v$ on this walk is bound by its weight $\weights(v)$.
% \end{itemize}
% %
% It is formally defined in \ref{def:trace_adapt}.
% %
% \mg{This definition doesn't make sense, it refers to an old version probably.}
% \begin{defn}
% [Adaptivity of A Program].
% \label{def:trace_adapt}
% \\
% Given a program ${c}$ in SSA language, 
% its adaptivity is defined for all possible starting SSA memory ${m}$ and database $D$ as follows:
% %
% $$
% A(c) = \max \big 
% \{ \qlen(k) \mid k \in \walks(\traceG(c) \big \} 
% $$
% \end{defn}
% \mg{We need to make more explicit that $\traceG(c)$ considers all the possible traces.}
\jl{Revised but need to be More explicit}
% \mg{This description is confusing. It is repeting something that was said before, e.g. ``the visiting times of each vertex $v$ on this walk is bound by its weight $\weights(v)$.'' buit it also say something new. Also it talks about program analysis which has not been defined, yet. I think it needs more work.}
Given a program $c$, we generate its execution-based graph 
$\traceG({c}) = (\vertxs, \edges, \weights, \qflag)$, by considering all possible traces.
%
% Then the adaptivity bound based on program analysis for ${c}$ is the number of query vertices on a finite walk in $\traceG({c})$. This finite walk satisfies:
Then the program's adaptivity is the maximum query length over all finite walks in $\walks(\traceG({c}))$.
% number of query vertices being visited on a finite walk in $\traceG({c})$. 
% This finite walk satisfies:
% %
% \begin{itemize}
% \item the number of query vertices being visited on this walk is maximum
% \item the visiting times of each vertex $v$ on this walk is bound by its weight $\weights(v)$.
% \end{itemize}
%
It is formally defined in \ref{def:trace_adapt}.
%
\begin{defn}
    [Adaptivity of a Program].
    \label{def:trace_adapt}
    \\
    Given a program ${c}$, 
    its adaptivity is defined as follows:
    %
    $$
    A(c) = \max \big 
    \{ \qlen(k) \mid k \in \walks(\traceG(c) \big \} 
    $$
    \end{defn}
%
{\footnotesize
\begin{figure}
 \centering
%}
\quad
\begin{subfigure}{.4\textwidth}
\begin{centering}
$
    \begin{array}{l}
           \clabel{ \assign{y}{0}}^{0} ; 
            \clabel{\assign{i}{0} }^{1} ;             
            \clabel{\assign{w}{0} }^{2} ; \\
            \eif(\clabel{ x = 0}^{3}, \clabel{ \assign{y}{\query(z)}}^{3}; ,\eskip);\\
            \ewhile ~ \clabel{i \neq x}^{2} ~ \edo ~ \\
            \Big(
             \clabel{\assign{w}{\query(\chi[y]+w)} }^{3}  ; \\
             \clabel{\assign{j}{j-1}}^{4} ;\\
                        \eif(\clabel{ x = 0}^{3}, \clabel{ \assign{y}{\query(z)}}^{3}; ,\eskip)
     \Big);\\
        \end{array}
$
\caption{}
\end{centering}
\end{subfigure}
\begin{subfigure}{.5\textwidth}
    \begin{centering}
    \begin{tikzpicture}[scale=\textwidth/18cm,samples=200]
% Variables Initialization
\draw[] (-5, 1) circle (0pt) node{{ $I^1: {}^1_{0}$}};
\draw[] (-5, 7) circle (0pt) node{{$ns^2: {}^{1}_{0}$}};
\draw[] (-5, 4) circle (0pt) node{{ $cs^3: {}^{1}_{0}$}};
% Variables Inside the Loop
 \draw[] (0, 10) circle (0pt) node{{ $a^6: {}^{k}_{1}$}};
 \draw[] (0, 7) circle (0pt) node{{ $ns^7: {}^{k}_{0}$}};
 \draw[] (0, 4) circle (0pt) node{{ $cs^8: {}^{k}_{0}$}};
 \draw[] (0, 1) circle (0pt) node{{ $I^9: {}^{k}_{0}$}};
 % Counter Variables
 \draw[] (5, 9) circle (0pt) node {{$j^0: {}^{1}_{0}$}};
 \draw[] (5, 6) circle (0pt) node {{ $j^5: {}^{k}_{0}$}};
 %
 % Value Dependency Edges:
 \draw[ thick, -latex,] (0, 1.5)  -- (0, 3.5) ;
 \draw[ ultra thick, -latex, densely dotted,] (0, 7.5)  -- (0, 9.5) ;
 \draw[ thick, -Straight Barb] (1.5, 3.5) arc (120:-200:1);
 \draw[ thick, -Straight Barb] (6.5, 6.5) arc (150:-150:1);
 \draw[ thick, -Straight Barb] (1, 7.2) arc (220:-100:1);
 \draw[ thick, -latex] (5, 6.5)  -- (5, 8.5) ;
 % Value Dependency Edges on Initial Values:
 \draw[ thick, -latex,] (-0.5, 1)  -- (-4.5, 1) ;
 \draw[ thick, -latex,] (-0.5, 4)  -- (-4.5, 4) ;
 \draw[ thick, -latex,] (-0.5, 7)  -- (-4.5, 7) ;
 %
 \draw[ ultra thick, -latex, densely dotted,] (-0.5, 10)  to  [out=-130,in=130]  (-0.5, 1);
 \draw[ ultra thick, -latex, densely dotted,] (-0.5, 1.5)  to  [out=-250,in=250]  (-0.5, 7);
 % Control Dependency
%  \draw[ thick,-latex] (1.5, 7)  -- (4, 9) ;
%  \draw[ thick,-latex] (1.5, 4)  -- (4, 9) ;
 \draw[ thick,-latex] (1.5, 7)  -- (4, 6) ;
 \draw[ thick,-latex] (1.5, 4)  -- (4, 6) ;
 \draw[ thick,-latex] (1.5, 1)  -- (4, 6) ;
 \draw[ thick,-latex] (1.5, 10)  -- (4, 6) ;
 \end{tikzpicture}
 \caption{}
    \end{centering}
    \end{subfigure}
% \end{wrapfigure}
% \end{equation*}
\vspace{-0.4cm}
 \caption{(a) Example of a program where this definition is untight (c) The corresponding adaptivity through the trace-based dependency graph.}
\label{fig:simpl-two-round-graph}
\vspace{-0.5cm}
\end{figure}
}