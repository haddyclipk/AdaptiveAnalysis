%
%
%
\subsection{Events Dependency}
%
%
\begin{defn}
[Value Dependency of Events]
\label{def:event_valdep}.
\\
An event $\event_2$ is in the \emph{value may-dependency} relation with an assignment
event $\event_1 \in \eventset^{\asn}$ in a program $\ssa{c}$
with hidden database $D$, denoted as 
%
$\eventdep^{val}(\event_1, \event_2, c, D)$, if and only if
%
\[
\exists \vtrace_0,
\vtrace_1, \vtrace_2, \vtrace_2' \in \mathcal{T}, \event_2' \in \eventset, \event_1' \in \eventset^{\asn}, \ssa{c}_1, \ssa{c}_2,  \ssa{c}_2'.
  \left(
  \begin{array}{ll}   
 & \config{\ssa{c}, \vtrace_0} \rightarrow^{*} 
\config{\ssa{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{\ssa{c}_2,  \vtrace_1 \cdot \event_1 \cdot \vtrace_2 \cdot \event_2 } 
  % 
 \\ 
 \bigwedge &
  \config{\ssa{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{\ssa{c}_2',  \vtrace_1 \cdot \event_1  \cdot \vtrace_2' \cdot \event_2' } 
\\
\bigwedge & \ismdiff(\event_2,\event_2')
\end{array}
\right)
 \]
%
\end{defn}
%
% \begin{defn}
% [Testing Dependency of Events]
% \label{def:event_testdep}.
% \\
% One event $\event_2$ may have a testing dependency on a testing event $\event_1 = (\ssa{b}_1, l_1, n_1, v_1)$
% in a program $\ssa{c}$, with a hidden database $D$, 
% denoted as 
% %
% $\eventdep^{\ctl}(\event_1, \event_2, c, D)$, is defined as follows: 
% %
% \[
% \exists \event_1' \in \eventset^{\test}, \vtrace_0,
% \vtrace_1, \vtrace_2, \vtrace_2', \ssa{c}_1.
%   \left(
%   \begin{array}{ll}   
%   & \config{\ssa{c}, \vtrace_0} \rightarrow^{*} 
%     \config{\ssa{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
%     \config{\eskip,  \vtrace_1 \cdot \event_1 \vtrace_2} 
%   \\ 
%   \bigwedge &
%   \config{\ssa{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
%   \config{\eskip,  \vtrace_1 \cdot \event_1 \vtrace_2' } 
%   \\
%   \bigwedge &
%   \event_2 \sigin \vtrace_2 \land \event_2 \notsigin \vtrace_2'
% \end{array}
% \right)
%  \]
% %
% \end{defn}
%
\begin{defn}
[Control Dependency of Events]
\label{def:event_ctldep}.
\\
An event $\event_2$ is in the \emph{control may-dependency} relation with an assignment
event $\event_1 \in \eventset^{\asn}$ in a program $\ssa{c}$
with hidden database $D$, denoted as 
%
$\eventdep^{\ctl}(\event_1, \event_2, c, D)$, if and only if: 
%
\[
\exists \vtrace_1, \vtrace_2, \vtrace_2', \vtrace_0 \in \mathcal{T}, 
\event_1' \in \eventset^{\asn}, \ssa{c}_1.
\left(
\begin{array}{ll}   
  & \config{\ssa{c}, \vtrace_0} \rightarrow^{*} 
    \config{\ssa{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
    \config{\eskip,  \vtrace_1 \cdot \event_1 \cdot \vtrace_2} 
  \\ 
  \bigwedge &
  \config{\ssa{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{\eskip,  \vtrace_1 \cdot \event_1 \cdot \vtrace_2' } 
  \\
  \bigwedge &
  \event_2 \ismin \vtrace_2 \land \event_2 \notismin \vtrace_2'
\end{array}
\right)
 \]
%
\end{defn}
%
%
\begin{defn}[Event May Dependency].
\label{def:event_dep}
\\ 
An event $\event_2 \in \eventset^{\asn}$ is in the \emph{may-dependency} relation with another
event $\event_1 \in \eventset^{\asn}$ in a program $\ssa{c}$ with a hidden database $D$, denoted as $\eventdep(\event_1, \event_2, c, D)$,
if and only if
\[
\eventdep^{val}(\event_1, \event_2, c, D) 
\lor
\eventdep^{\ctl}(\event_1, \event_2, c, D) 
\] %
%
\end{defn}
%
\begin{defn}[Variable May Dependency].
\label{def:var_dep}
\\
An variable $\ssa{x}_2^{l_2} \in \lvar_{\ssa{c}}$ is in the \emph{variable may-dependency} relation with another
variable $\ssa{x}_1^{l_1} \in \lvar_{\ssa{c}}$ in a program $\ssa{c}$, denoted as 
%
$\vardep(\ssa{x}_1^{l_1}, \ssa{x}_2^{l_2}, \ssa{c})$, if an only if.
%
\[
\exists \event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom. ~
\projl{\event_1} = (\ssa{x}_1, l_1)
\land
\projl{\event_2} = (\ssa{x}_2, l_2)
\land 
\eventdep(\event_1, \event_2, c, D)
\] 
%
%
\end{defn}
%
\begin{defn}[Labeled Variables ($\lvar_{c} \subseteq \mathcal{VAR} \times \mathbb{N}$ or 
$\lvar : c \to \mathcal{P}(\mathcal{VAR} \times \mathbb{N})$]
$$
  \lvar_{c} \triangleq
  \left\{
  \begin{array}{ll}
      \{\ssa{x}^l\}                   
      & \ssa{c} = [\ssa{\assign x e}]^{l} 
      \\
      \{\ssa{x}^l\}                   
      & \ssa{c} = [\ssa{\assign x \query(\qexpr)}]^{l} 
      \\
      \lvar_{\ssa{c_1}} \cup \lvar{(\ssa{c_2})}  
      & \ssa{c} = \ssa{c_1};\ssa{c_2}
      \\
      \lvar_{\ssa{c}} \cup \lvar_{\ssa{c_2}} \cup \ssa{\{\bar{x}, \bar{y}, \bar{z}\}} 
      & \ssa{c} =\eif([\sbexpr]^{l} , \ssa{[\bar{x}, \bar{x_2}, \bar{x_2}], 
      [\bar{y}, \bar{y_2}, \bar{y_3}], 
      [\bar{z}, \bar{z_2}, \bar{z_3}], c_1, c_2}) 
      \\
      \lvar_{\ssa{c}'} \cup \{\ssa{\bar{x}}\}
      & \ssa{c}   = \ewhile ([\sbexpr]^{l}, [\ssa{\bar{x}, \bar{x_2}, \bar{x_2}}], \ssa{c}')
\end{array}
\right.
$$
\end{defn}
%
\begin{defn}[Query Variables ($\qvar_{c} \subseteq \mathcal{VAR} \times \mathbb{N}$)].
\\
Given a program $c$, its query variables $\qvar$ is a vector containing all variables newly assigned by a query in the programm, $\qvar \subset \mathcal{VAR}$.
It is defined as follows:
$$
  \qvar_{\ssa{c}} \triangleq
  \left\{
  \begin{array}{ll}
      \{\}                  
      & \ssa{c} = [\ssa{\assign x e}]^{(l, w)} 
      \\
      \{\ssa{x}^l\}                  
      & \ssa{c} = [\ssa{\assign x \query(\qexpr)}]^{(l, w)} 
      \\
      \qvar_{\ssa{c_1}} \cup \qvar_{\ssa{c_2}}  
      & \ssa{c} = \ssa{c_1};\ssa{c_2}
      \\
      \qvar_{\ssa{c_1}} \cup \qvar_{\ssa{c_2}} 
      & \ssa{c} =\eif([\sbexpr]^{l} , \ssa{[\bar{x}, \bar{x_2}, \bar{x_2}], 
      [\bar{y}, \bar{y_2}, \bar{y_3}], 
      [\bar{z}, \bar{z_2}, \bar{z_3}], c_1, c_2}) 
      \\
      \qvar_{\ssa{c}'}
      & \ssa{c}   = \ewhile ([\sbexpr]^{l}, [\ssa{\bar{x}, \bar{x_2}, \bar{x_2}}], \ssa{c}')
\end{array}
\right.
$$
\end{defn}
%
%
\begin{defn}[Execution Based Dependency Graph].
\\
Given a program $\ssa{c}$ with its assigned variables $\lvar_c$ 
the dependency graph $\traceG(\ssa{c}, D) = (\vertxs, \edges, \weights, \qflag)$ is defined as:
%
\[
\begin{array}{rlcl}
  \text{Vertices} &
  \vertxs & := & \left\{ 
  x^l \in \mathcal{VAR} \times \mathbb{N}
  ~ \middle\vert ~
  x^l \in \lvar({\ssa{c}})
  \right\}
  \\
  \text{Directed Edges} &
  \edges & := & 
  \left\{ 
  (\ssa{x}_1^{l_1}, \ssa{x}_2^{l_2}) \in \mathcal{VAR} \times \mathbb{N} \times (\mathcal{VAR} \times \mathbb{N})
  ~ \middle\vert ~
  \vardep(\ssa{x}_1^{l_1}, \ssa{x}_2^{l_2}, c) \land
  \ssa{x}_1^{l_1}, \ssa{x}_2^{l_2} \in \lvar_{\ssa{c}}
  \right\}
  \\
  \text{Weights} &
  \weights & := & 
  \left\{ 
  (x^l, n) \in \mathcal{VAR} \times \mathbb{N} \times \mathbb{N}
  ~ \middle\vert ~ 
  n = \max \left\{ \vcounter(\vtrace')l | \vtrace \in \mathcal{T} \st 
   \config{\ssa{c}, \trace} \to^{*} \config{\eskip, \vtrace'}  
   \land x^l \in \lvar({\ssa{c}}) 
   \right\}
  \right\}
  \\
  \text{Query Flags} &
  \qflag & := & 
  \left\{(x^l, n)  \in \mathcal{VAR} \times \mathbb{N}  \times \{0, 1\} 
  ~ \middle\vert ~
  \left\{
  \begin{array}{ll}
  n = 1 & x^l \in \qvar({\ssa{c}}) \\ 
  n = 0 & o.w.
  \end{array}
  \right\};
  x^l \in \lvar({\ssa{c}})
  \right\}
\end{array}
\]
\end{defn}
%
%
\begin{defn}[Finite Walk ($k$)].
\label{def:finitewalk}
\\
Given a labeled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, a \emph{finite walk} $k$ in $G$ is a sequence of edges $(e_1 \ldots e_{n - 1})$ 
for which there is a sequence of vertices $(v_1, \ldots, v_{n})$ such that:
\begin{itemize}
    \item $e_i = (v_{i},v_{i + 1})$ for every $1 \leq i < n$.
    \item every vertex $v \in \vertxs$ appears in this vertices sequence $(v_1, \ldots, v_{n})$ of $k$ at most $W(v)$ times.  
\end{itemize}
$(v_1, \ldots, v_{n})$ is the vertex sequence of this walk.
\\
%
Length of this finite walk $k$ is the number of vertices in its vertex sequence, i.e., $\len(k) = n$.
\end{defn}
%
Given a labeled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, 
we use $\walks(G)$ to denote a set containing all finite walks $k$ in $G$;
and $k_{v_1 \to v_2} \in \walks(G)$where $v_1, v_2 \in \vertxs$ denotes the walk from vertex $v_1$ to $v_2$ .
%
%
\begin{defn}[Length of Finite Walk w.r.t. Query ($\qlen$)].
\label{def:qlen}
\\
Given a labeled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$ and a \emph{finite walk} $k$ in $G$ with its vertex sequence $(v_1, \ldots, v_{n})$, the length of $k$ w.r.t query is defined as:
\[
  \qlen(k) = \len\big(
  v \mid v \in (v_1, \ldots, v_{n}) \land \flag(v) = 1 \big)
\]
, where $\big(v \mid v \in (v_1, \ldots, v_{n}) \land \flag(v) = 1 \big)$ is a subsequence of $k$'s vertex sequence.
\end{defn}
%
%
% \subsection{SSA Transformation and Soundness of Transformation}
% in File {\tt ``ssa\_transform\_sound.tex''}
% \input{ssa_transform_sound}
%
\todo{The following lemma describes a property of the trace-based dependency graph.
For any program $c$ with a database $D$ and a initial trace $\trace$,
the directed edges in its trace-based dependency graph can only be constructed from variable with  
smaller labels variables of greater ones.
There doesn't exist backward edges with direction from greater labeled variables to smaller ones.
\begin{lem}
\label{lem:edgeforwarding}
[Edges are Forwarding Only].
\\
%
%
$$
\forall \trace \in \mathcal{T}, D \in \dbdom \st G(c, D) =  (\vertxs, \edges, \weights, \qflag) 
\implies
\forall (\event', \event) \in \edges \st \event' \eventleq \event
$$
%
\end{lem}
%
\begin{proof}
Proof in File: {\tt ``edge\_forward.tex''}.
% \input{edge_forward}
\end{proof}
%
%
%
\begin{lem}
\label{lem:DAG}
[Trace-based Dependency Graph is Directed Acyclic].
\\
%
$\forall \trace \in \mathcal{T}, D \in \dbdom $, $G(c, D)$ is a directed acyclic graph.
\end{lem}
}
%