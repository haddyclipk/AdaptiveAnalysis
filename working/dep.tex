%
%
%
\subsection{Dependency}
We first show a definition of event \emph{May-Dependency}, which is the foundation of our variable may-dependency.
Then we give a formal definition of variable \emph{May-Dependency} 
%  based on the trace-based operational semantics,
by considering all the possible execution traces.
%
% \mg{I don't think labeled variables were defined before. Also the set of labeled variables was not defined.}\\
% \jl{it is defined above in Definition~\ref{def:avar} and Definition~\ref{def:lvar}}\\
% \mg{Also, I already pointed out that here there is an inconsistency between labeled variables and pairs of variable and label. We need to resolve this inconsistency. Either we use everywhere labeled variables, or we use pairs variable and label.}\\
% \jl{I agree, yes, I need to think. I will use the labeled variable, but I need to think how to fix it in the event}
% \\
% \jl{TODO: unify labeled variables and pairs of variable and label into labeled variables}
% \\
% \mg{Another issue, it is not a good norm to define something using a definition that will follow. So, first we define the dependency over events and then the one over variables.}
% \jl{fixed}
% \mg{I think this definition is too cryptic. We should try to massage it a bit to make it more understandable. Here few suggestion. First, let's use names that are easier to memorize. For example, instead of  $\vcounter(\vtrace) ~ \pi_2(\event_2)$ we could write ${\tt count}({\tt label}(\event_2), \vtrace)$.}
\jl{TODO: Simplify notations and add description}
% \\
% \mg{Also, is $\event_2$ or $\event_2'$ in the last line of the first block?}
% \jl{$\event_2'$, fixed}
\begin{defn}[Event May-Dependency].
\label{def:event_dep}
\\ 
  An event $\event_2$ is in the \emph{event may-dependency} relation with an assignment
  event $\event_1 \in \eventset^{\asn}$ in a program ${c}$
  with a hidden database $D$ and a trace $\trace \in \mathcal{T}$ denoted as 
  %
  $\eventdep(\event_1, \event_2, [\event_1 ] \tracecat \trace \tracecat [\event_2], c, D)$, if and only if
  %
  \[
    \begin{array}{l}
  \exists \vtrace_0,
  \vtrace_1, \vtrace' \in \mathcal{T},\event_1' \in \eventset^{\asn}, {c}_1, {c}_2  \in \cdom  \st
  \diff(\event_1, \event_1') \land 
      \\ \quad
      (
        \exists  \event_2' \in \eventset \st 
    \left(
    \begin{array}{ll}   
   & \config{{c}, \vtrace_0} \rightarrow^{*} 
  \config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
    \config{{c}_2,  \vtrace_1 \tracecat [\event_1] \tracecat \vtrace \tracecat [\event_2] } 
    % 
   \\ 
   \bigwedge &
    \config{{c}_1, \vtrace_1 \tracecat [\event_1']}  \rightarrow^{*} 
    \config{{c}_2,  \vtrace_1 \tracecat[ \event_1'] \tracecat \vtrace' \tracecat [\event_2'] } 
  \\
  \bigwedge & 
  \diff(\event_2,\event_2' ) \land 
  \vcounter(\vtrace, \pi_2(\event_2))
  = 
  \vcounter(\vtrace', \pi_2(\event_2'))\\
  \end{array}
  \right)
  \\ \quad
  \lor 
  \exists \vtrace_3, \vtrace_3'  \in \mathcal{T}, \event_b \in \eventset^{\test} \st 
  \left(
  \begin{array}{ll}   
    & \config{{c}, \vtrace_0} \rightarrow^{*} 
      \config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
      \config{c_2,  \vtrace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b] \tracecat  \trace_3} 
    \\ 
    \bigwedge &
    \config{{c}_1, \vtrace_1 \tracecat [\event_1']}  \rightarrow^{*} 
    \config{c_2,  \vtrace_1 \tracecat [\event_1'] \tracecat \trace' \tracecat [(\neg \event_b)] \tracecat \trace_3'} 
    \\
    \bigwedge &  \tlabel_{\trace_3} \cap \tlabel_{\trace_3'} = \emptyset
     \land \vcounter(\trace', \pi_2(\event_b)) = \vcounter(\trace, \pi_2(\event_b)) 
    %   \land \event_2 \eventin \trace_3
    % \land \event_2 \not\eventin \trace_3'
    \land \event_2 \in \trace_3
    \land \event_2 \not\in \trace_3'
  \end{array}
  \right)
  )
\end{array}
   \]
% , where ${\tt label}(\event_2) = \pi_2(\event_2)$.
  %  
%
\end{defn}
% \todo{add explnanation}
\jl{The event \emph{May-Dependency} relation considers two situations (the value dependency and 
value control dependency) as discussed in Section 4.1.
In both of the two situations, we modify the value assigned to the 
% first variable 
first variable in $\event_1$, by changing the value 
of $\event_1$ in trace $\trace_1 \tracecat [\event_1]$ into $\event_1'$.
We use $\diff(\event_1, \event_1')$ to guarantee they only differ in their assigned value and equal on variable name and label.
\\
Then we continuously execute the same program from the same location, 
but with a different trace $\trace_1 \tracecat [\event_1']$. 
The two traces only differ in 
the $\event_1$ and $\event_1'$, specifically the value of the two events.
\\
Then, we observe two different possible changes of execution in the value dependency and 
value control dependency situations respectively.
\\
% In the first situation, we are witnessing 
In the first situation, we witness
% that the value assigned to the second variable in $\event_2$
the appearance of $\event_2'$ in the second execution, and
% a variation in $\event_2$, which changes into $\event_2'$.
a variation between $\event_2$ and $\event_2'$ on their value.
% changes in $\event_2'$.
Specifically, the constraint $\diff(\event_2, \event_2')$ guarantees that they
have the same variable name and label but only differ 
% in their assigned value. 
in their values assigned to the same variable. 
In particularly for query, if $\event_2$ and $\event_2'$ are 
% query assignment events, then 
generated from query requesting, then $\diff(\event_2, \event_2)$ guarantees that
they differ in their query value rather than the assigned value. 
\\
In order to handle the multiple occurrence of the same event through iterations of the while loop,
 where  $\event_2$ and $\event_2'$ could be 
in different while loop,
we restrict the occurrence times of $\event_2$'s label in the first trace equals to the occurrence times of $\event_2'$'s label in the second trace,
through $\vcounter(\vtrace, \pi_2(\event_2))
= 
\vcounter(\vtrace', \pi_2(\event_2'))$.
\\
In the second situation, we 
% are witnessing 
witness
the disappearance of $\event_2$ through observing the change of a testing event $\event_b$.
In order to change the appearance of 
% and event, the command that generating $\event_2$ must not be executed in 
an event, the command that generates $\event_2$ must not be executed in 
the second execution. 
The only way to control whether a command will be executed, is through the change of a guard's 
evaluation result in the if or while command.
So we first observe the testing event $\event_b$ changes into $\neg \event_b$ in the second execution, 
following with the disappearance of $\event_2$ in the second trace.
\\
In the same way, we restrict the occurrence times of $\event_b$'s label in the two traces being equal
% s to the occurrence times of $\event_2'$'s label in the second trace,
through $\vcounter(\trace', \pi_2(\event_b)) = \vcounter(\trace, \pi_2(\event_b)) $ to handle the while loop.
% changes in $\event_2'$, have the same variable and label and only differ in their assigned value. 
Again, in particularly for query, we observe the disappearance based on the query value equivalence.
% if $\event_2$ and $\event_2'$ are query assignment events, then 
% they differ in their query value rather than the assigned value. 
}
\begin{defn}[Variable May-Dependency].
  \label{def:var_dep}
  \\
  A variable ${x}_2^{l_2} \in \lvar_{{c}}$ is in the \emph{variable may-dependency} relation with another
  variable ${x}_1^{l_1} \in \lvar_{{c}}$ in a program ${c}$, denoted as 
  %
  $\vardep({x}_1^{l_1}, {x}_2^{l_2}, {c})$, if an only if.
  %
%   \[
%     \begin{array}{l}
%   \exists \event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom. ~
%   (\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
%   \land
%   (\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
%   \\ \quad 
%   \land 
%  \left(
%   \exists \trace \in \mathcal{T} \st 
%   \eventdep^{val}(\event_1, \event_2, \trace, c, D) 
%   \lor
%   \left( \exists \event_b \in \eventset^{\test} \st \eventdep^{val}(\event_1, \event_b, \trace, c, D) \land \eventdep^{\ctl}(\event_b, \event_2, c, D)  \right)  
%  \right)
%     \end{array}
%   \]
\[
  \begin{array}{l}
\exists \event_1, \event_2 \in \eventset^{\asn}, \trace \in \mathcal{T} , D \in \dbdom \st
% (\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
% \land
% (\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
\pi_{1}{(\event_1)}^{\pi_{2}{(\event_1)}} = {x}_1^{l_1}
\land
\pi_{1}{(\event_2)}^{\pi_{2}{(\event_2)}} = {x}_2^{l_2}% \\ \quad 
\land 
\eventdep(\event_1, \event_2, \trace, c, D) 
  \end{array}
\]  %
% , where $\eventdep$ is defined in Definition~\ref{def:event_dep}.
  % , where $\eventdep^{val}$ and $\eventdep^{\test}$ is defined in \ref{def:event_valdep} and \ref{def:event_ctldep}.
  % %
  %
  \end{defn}
%
% \mg{I don't understand this explanation. What are the ``assignment commands associated to the two labelled variables''}
\jl{revised but need more think}
% Explanation: 
\jl{Considering a program's all possible executions,
among all events generated during these executions
and the variables and labels of these events are 
corresponding to the two labeled variables 
% evaluations of the assignment commands associated to the two labelled variables respectively, 
as long as there is one pair of events satisfying the \emph{Event May-Dependency} relation in Definition~\ref{def:event_dep}, 
then we say the two variables have \emph{Variable May-Dependency} relation.
}
% \begin{defn}
% [Value Dependency of Events \todo{Explicit Dependency}]
% \label{def:event_valdep}.
% \\
% An event $\event_2$ is in the \emph{value may-dependency} relation with an assignment
% event $\event_1 \in \eventset^{\asn}$ in a program ${c}$
% with hidden database $D$, denoted as 
% %
% $\eventdep^{val}(\event_1, \event_2, c, D)$, if and only if
% %
% \[
% \exists \vtrace_0,
% \vtrace_1, \vtrace_2, \vtrace_2' \in \mathcal{T}, \event_2' \in \eventset, \event_1' \in \eventset^{\asn}, {c}_1, {c}_2,  {c}_2'.
%   \left(
%   \begin{array}{ll}   
%  & \config{{c}, \vtrace_0} \rightarrow^{*} 
% \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
%   \config{{c}_2,  \vtrace_1 \cdot \event_1 \cdot \vtrace_2 \cdot \event_2 } 
%   % 
%  \\ 
%  \bigwedge &
%   \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
%   \config{{c}_2',  \vtrace_1 \cdot \event_1'  \cdot \vtrace_2' \cdot \event_2' } 
% \\
% \bigwedge & \event_1 \sigeq \event_1' \land \diff(\event_2,\event_2')
% \end{array}
% \right)
%  \] 
%  % \wq{$\forall \vtrace_0$? is there any requirement of $c_2$ and $c_2'$? For example, you go 2 steps to get $\event_2$ while $\event_2'$ can be empty if it just goes 0 steps. Shall we set some requirement on $\event_2'$, for example, both goes to the end of $c_2$ or certain line?}
% %
% \end{defn}
%
% \jl{Better to Combine these two  \emph{may-dependency} definitions}
% \begin{defn}
% [Value Dependency of Events \todo{Explicit Dependency}]
% \label{def:event_valdep}.
% \\
% An event $\event_2$ is in the \emph{value may-dependency} relation with an assignment
% event $\event_1 \in \eventset^{\asn}$ in a program ${c}$
% with hidden database $D$ and a trace $\trace \in \mathcal{T}$ denoted as 
% %
% $\eventdep^{val}(\event_1, \event_2, [\event_1 ] \tracecat \trace \tracecat [\event_2], c, D)$, if and only if
% %
% \[
% \exists \vtrace_0,
% \vtrace_1, \vtrace' \in \mathcal{T}, \event_2' \in \eventset, \event_1' \in \eventset^{\asn}, {c}_1, {c}_2  \in \cdom  \st
%   \left(
%   \begin{array}{ll}   
%  & \config{{c}, \vtrace_0} \rightarrow^{*} 
% \config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
%   \config{{c}_2,  \vtrace_1 \tracecat [\event_1] \tracecat \vtrace \tracecat [\event_2] } 
%   % 
%  \\ 
%  \bigwedge &
%   \config{{c}_1, \vtrace_1 \tracecat [\event_1']}  \rightarrow^{*} 
%   \config{{c}_2,  \vtrace_1 \tracecat[ \event_1'] \tracecat \vtrace' \tracecat [\event_2'] } 
% \\
% \bigwedge &  \pi_1(\event_1) = \pi_1(\event_1') \land \pi_2(\event_1) = \pi_2(\event_1') 
% \\
% \bigwedge & 
% \diff(\event_2,\event_2' ) \land 
% \vcounter(\vtrace) ~ \pi_2(\event_2)
% = 
% \vcounter(\vtrace') ~ \pi_2(\event_2)\\
% \end{array}
% \right)
%  \]
% %  \wq{I realize Diff is little bit unclear, it means same variable, label, but only different in value:- Maybe DiffValue?}
% %
% \end{defn}
% % \begin{defn}
% % [Testing Dependency of Events]
% % \label{def:event_testdep}.
% % \\
% % One event $\event_2$ may have a testing dependency on a testing event $\event_1 = ({b}_1, l_1, n_1, v_1)$
% % in a program ${c}$, with a hidden database $D$, 
% % denoted as 
% % %
% % $\eventdep^{\ctl}(\event_1, \event_2, c, D)$, is defined as follows: 
% % %
% % \[
% % \exists \event_1' \in \eventset^{\test}, \vtrace_0,
% % \vtrace_1, \vtrace_2, \vtrace_2', {c}_1.
% %   \left(
% %   \begin{array}{ll}   
% %   & \config{{c}, \vtrace_0} \rightarrow^{*} 
% %     \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
% %     \config{\eskip,  \vtrace_1 \cdot \event_1 \vtrace_2} 
% %   \\ 
% %   \bigwedge &
% %   \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
% %   \config{\eskip,  \vtrace_1 \cdot \event_1 \vtrace_2' } 
% %   \\
% %   \bigwedge &
% %   \event_2 \sigin \vtrace_2 \land \event_2 \notsigin \vtrace_2'
% % \end{array}
% % \right)
% %  \]
% % %
% % \end{defn}
% %
% % \begin{defn}
% % [Control Dependency of Events \todo{Implicit Dependency}]
% % \label{def:event_ctldep}.
% % \\
% % An event $\event_2$ is in the \emph{control may-dependency} relation with an assignment
% % event $\event_1 \in \eventset^{\asn}$ in a program ${c}$
% % with hidden database $D$, denoted as 
% % %
% % $\eventdep^{\ctl}(\event_1, \event_2, c, D)$, if and only if: 
% % %
% % \[
% % \exists \vtrace_1, \vtrace_2, \vtrace_2', \vtrace_0 \in \mathcal{T}, 
% % \event_1' \in \eventset^{\asn}, {c}_1.
% % \left(
% % \begin{array}{ll}   
% %   & \config{{c}, \vtrace_0} \rightarrow^{*} 
% %     \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
% %     \config{\eskip,  \vtrace_1 \cdot \event_1 \cdot \vtrace_2} 
% %   \\ 
% %   \bigwedge &
% %   \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
% %   \config{\eskip,  \vtrace_1 \cdot \event_1' \cdot \vtrace_2' } 
% %   \\
% %   \bigwedge & \event_1 \sigeq \event_1' \land 
% %   \event_2 \sigin \vtrace_2 \land \event_2 \notsigin \vtrace_2'
% % \end{array}
% % \right)
% %  \]
% % %
% % \end{defn}
% %
% \begin{defn}
% [Control Dependency of Events \todo{Implicit Dependency}]
% \label{def:event_ctldep}.
% \\
% An event $\event$ is in the \emph{control may-dependency} relation with an assignment
% event $\event_b \in \eventset^{\test}$ in a program ${c}$
% with hidden database $D$, denoted as 
% %
% % doesn't rely on trace
% % $\eventdep^{\ctl}(\event_1, \event_2, \wq{\tau,} c, D)$, if and only if: 
% %
% % \[
% % \exists \vtrace_1, \vtrace_2, \vtrace_2', \vtrace_0 \in \mathcal{T}, 
% % \event_1' \in \eventset^{\asn}, {c}_1.
% % \left(
% % \begin{array}{ll}   
% %   & \config{{c}, \vtrace_0} \rightarrow^{*} 
% %     \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
% %     \config{\eskip,  \vtrace_1 \cdot \event_1 \tracecat \vtrace_2} 
% %   \\ 
% %   \bigwedge &
% %   \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
% %   \config{\eskip,  \vtrace_1 \cdot \event_1' \tracecat \vtrace_2' } 
% %   \\
% %   \bigwedge &  \pi_1(\event_1) = \pi_1(\event_1') \land \pi_2(\event_1) = \pi_2(\event_1') \\
% %   \bigwedge & l_1 = \pi_2(\event_1) \land l_2 = \pi_2(\event_2)
% %   \\
% %   \bigwedge &  \land \vcounter(\vtrace_2') l_2 \neq \vcounter(\trace_2) l_2 
% % \end{array}
% % \right)
% %  \]%
% %
% \\
% $\eventdep^{\ctl}(\event_b, \event, c, D)$, if and only if: 
% %
% % \[
% % \exists \vtrace_1, \vtrace_2', \vtrace_0 \in \mathcal{T}, 
% % \event_1, \event_1' \in \eventset^{\asn},  {c}_1.
% % \left(
% % \begin{array}{ll}   
% %   & \config{{c}, \vtrace_0} \rightarrow^{*} 
% %     \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
% %     \config{c_2,  \vtrace_1 \cdot \event_1 \tracecat \trace_2 \cdot \event_b \cdot \trace_3} 
% %   \\ 
% %   \bigwedge &
% %   \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
% %   \config{c_2,  \vtrace_1 \cdot \event_1 {\wq{\event_1'?}} \tracecat \trace_2' \cdot (\neg \event_b)\wq{+ \cdot \event_3' ?}} 
% %   \\
% %   \bigwedge &  \diff(\event_1, \event_1') \\ 
% %   \bigwedge & l_b = \pi_2(\event_b) \land \vcounter(\vtrace_2') l_b = \vcounter(\trace_2) l_b
% %     \land \event \in \trace_3
% % \end{array}
% % \right)
% %  \]
% %  %
% %  \[
% % \exists \vtrace_0, \vtrace_1, \vtrace_2, \trace_2', \vtrace_3 \in \mathcal{T}, 
% % \event_1, \event_1' \in \eventset^{\asn},  {c}_1, c_2 \in \cdom.
% % \left(
% % \begin{array}{ll}   
% %   & \config{{c}, \vtrace_0} \rightarrow^{*} 
% %     \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
% %     \config{c_2,  \vtrace_1 \cdot \event_1 \tracecat \trace_2 \cdot \event_b \tracecat  \trace_3} 
% %   \\ 
% %   \bigwedge &
% %   \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
% %   \config{c_2,  \vtrace_1 \cdot \event_1' \tracecat \trace_2' \cdot (\neg \event_b)} 
% %   \\
% %   \bigwedge &  \diff(\event_1, \event_1') \\ 
% %   \bigwedge & l_b = \pi_2(\event_b) \land \vcounter(\vtrace_2') l_b = \vcounter(\trace_2) l_b
% %     \land \event \in \trace_3
% % \end{array}
% % \right)
% %  \]
%  %
%  \[
% \exists \vtrace_0, \vtrace_1, \vtrace_2, \trace_2', \vtrace_3, \vtrace_3'  \in \mathcal{T}, 
% \event_1, \event_1' \in \eventset^{\asn},  {c}_1, c_2 \in \cdom.
% \left(
% \begin{array}{ll}   
%   & \config{{c}, \vtrace_0} \rightarrow^{*} 
%     \config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
%     \config{c_2,  \vtrace_1 \tracecat [\event_1] \tracecat \trace_2 \tracecat [\event_b] \tracecat  \trace_3} 
%   \\ 
%   \bigwedge &
%   \config{{c}_1, \vtrace_1 \tracecat [\event_1']}  \rightarrow^{*} 
%   \config{c_2,  \vtrace_1 \tracecat [\event_1'] \tracecat \trace_2' \tracecat [(\neg \event_b)] \tracecat \trace_3'} 
%   \\
%   \bigwedge &  \diff(\event_1, \event_1') \land \tlabel_{\trace_3} \cap \tlabel_{\trace_3'} = \emptyset\\ 
%   \bigwedge & l_b = \pi_2(\event_b) \land \vcounter(\vtrace_2') l_b = \vcounter(\trace_2) l_b
%     \land \event \in \trace_3
% \end{array}
% \right)
%  \]
%  %
% \end{defn}
%

%

% \mg{Ok, I see the definition of Labelled Variables here. Clearly, it is in the wrong order. Besides, I still think it is better to use just one notation.}
% \jl{defined above in Definition~\ref{def:avar} and \ref{def:lvar}}
%
%
%
\subsection{Execution Based Dependency Graph}
%
%
%
Through the variable \emph{May-Dependency} relation, we define the execution based dependency graph.
%
\begin{defn}[Execution Based Dependency Graph]
\label{def:trace_graph}
Given a program ${c}$,
its \emph{Execution-Base Dependency Graph} $\traceG({c}) = (\vertxs, \edges, \weights, \qflag)$ is defined as follows over all possible traces,
%
{\footnotesize
\[
% \begin{array}{rlcl}
%   \text{Vertices} &
%   \vertxs & := & \left\{ 
%   x^l \in \mathcal{LV}
%   ~ \middle\vert ~ x^l \in \lvar_{c}
%   \right\}
%   \\
%   \text{Directed Edges} &
%   \edges & := & 
%   \left\{ 
%   (x^i, y^j) \in \mathcal{VAR} \times \mathcal{L} \times \mathcal{VAR} \times \mathcal{L}
%   ~ \middle\vert ~
%   x^i, y^j \in \lvar_{{c}} \land \vardep(x^i, y^j, c) \text{\mg{$\land$ instead of ,}
%   \right\}
%   \\
%   \text{Weights} &
%   \weights & := & 
%   \left\{ 
%   (x^l, n) \in \mathcal{VAR} \times \mathcal{L} \times \mathbb{N}
%   ~ \middle\vert ~ 
%   x^l \in \lvar_{c},
%   n = \max \left\{ \vcounter(\vtrace') l ~ \middle\vert~
%   \forall \vtrace \in \mathcal{T} \st \config{{c}, \trace} \to^{*} \config{\eskip, \trace\cdot\vtrace'} 
%    \right\}
%   \right\}
%   \\
%   \text{Query Label} &
% \qflag & := & 
% \left\{(x^l, n)  \in  \mathcal{VAR} \times \mathcal{L} \times \{0, 1\} 
% ~ \middle\vert ~
%  x^l \in \lvar_{c},
% n = 1 \iff x^l \in \qvar_{c} \land n = 0 \iff  x^l \in \qvar_{c} .
% \right\}
% \end{array}
\begin{array}{rlcl}
  \text{Vertices} &
  \vertxs & := & \left\{ 
  x^l \in \mathcal{LV}
  ~ \middle\vert ~ x^l \in \lvar_{c}
  \right\}
  \\
  \text{Directed Edges} &
  \edges & := & 
  \left\{ 
  (x^i, y^j) \in \mathcal{LV} \times \mathcal{LV}
  ~ \middle\vert ~
  x^i, y^j \in \lvar_{{c}} \land \vardep(x^i, y^j, c) 
  % \text{\mg{$\land$ instead of ,}}
  \right\}
  \\
  \text{Weights} &
  \weights & := & 
  \left\{ 
  (x^l, n) \in \mathcal{LV} \times \mathbb{N}
  ~ \middle\vert ~ 
  x^l \in \lvar_{c} \land
  n = \max \left\{ \vcounter(\vtrace', l)~ \middle\vert~
  \forall \vtrace \in \mathcal{T} \st \config{{c}, \trace} \to^{*} \config{\eskip, \trace\cdot\vtrace'} 
   \right\}
  \right\}
  \\
  % \text{Query Label} &
  \text{Query Annotation} &
  \qflag & := & 
\left\{(x^l, n)  \in  \mathcal{LV}\times \{0, 1\} 
~ \middle\vert ~
 x^l \in \lvar_{c} \land
n = 1 \iff x^l \in \qvar_{c} \land n = 0 \iff  x^l \notin \qvar_{c} .
\right\}
\end{array}
\]
}
% \mg{I don't understand what is the set of query labels above. Specifically, the formula with three iff is confusing.}\\
\jl{TODO: I actually don't need this query annotation in the graph, I can just use $\qvar(c)$ in defining the 
query length and computing the adaptivity?
But it need to change many notations later. So I think to think if it is necessary to remove or leave it.}
% \mg{there is a dangling , below}\\
% \mg{what is ``i.ts'' referring to in the sentence below?}\\
% , where $\lvar_c$ is program $c$'s set of labeled variables.
\end{defn}
%
% \jl{TODO: add description}
%
\jl{The query annotations is 
% the weight for each vertex in $\progV(c)$,
% as 
a set of pairs $\progF(c) \in \mathcal{P}(\mathcal{LV} \times \{0, 1\} )$ 
% is the set of pairs 
% The weight for each vertex in $\progV(c)$ is computed 
mapping each $x^l \in \progV(c)$ to $0$ or $1$, indicating whether this labeled variable is assigned by a query request.}
\\
\jl{
  a set of pairs $\progW(c) \in \mathcal{P}(\mathcal{LV} \times \mathbb{N})$ 
% is the set of pairs 
% The weight for each vertex in $\progV(c)$ is computed 
mapping each $x^l \in \progV(c)$ to a natural number. 
This natural number is the maximum occurrence time of label $l$
in program's execution trace, 
}
% The edge is directed, when an annotated query $q(v)^{(l,w)}$ may depend on its previous query $q(v')^{(l',w')}$, we have the directed
% edge $(q(v)^{(l,w)}, q(v')^{(l'.w')})$, from $q(v)^{(l,w)} $ to $q(v')^{(l'.w')}$.
% 
% The query-based dependency graph only considers the newly generated annotated queries during the execution of the program $c$, so we see the nodes coming from the trace $t'-t$. The previous trace before the execution of $c$ is excluded when constructing the graph. To summary, for every execution of a program $c$ staring with different configurations, we can construct a corresponding dependency graph. 
% \\
% \mg{I don't understand the next sentence. First, by the definition edges are between nodes which are labelled variables, why do you have annotated queries now? I suspect that this and the next sentence are old.}
% \jl{I deleted but forgot to push before}
% \\
% The edge is directed, when an annotated query $q(v)^{(l,w)}$ may depend on its previous query $q(v')^{(l',w')}$, we have the directed
% edge $(q(v)^{(l,w)}, q(v')^{(l'.w')})$, from $q(v)^{(l,w)} $ to $q(v')^{(l'.w')}$.
% 
% The query-based dependency graph only considers the newly generated annotated queries during the execution of the program $c$, so we see the nodes coming from the trace $t'-t$. The previous trace before the execution of $c$ is excluded when constructing the graph. To summary\mg{To summarize}, for every execution of a program $c$ staring with different configurations, we can construct a corresponding dependency graph. 
% \\
% \mg{I also don't understand the next sentence. What is the injectivity of $\weights$ in a program dependency graph?And what is the image of $v$ in $\weights$. I find this very confusing.}
% \jl{I removed this, it is mainly used for simplify the soundness proof.}
% For any program $c$, by the injectivity of $\weights$ in its dependency graph, $\traceG({c}) = (\vertxs, \edges, \weights, \qflag)$, 
% $\weights$ forms a function. 
\jl{We use $\traceW(x^l)$ to indicate the weight of 
% $v$ in a program $c$'s execution-based dependency graph $\traceG({c}) = (\vertxs, \edges, \weights, \qflag)$.}
$x^l$ in $c$'s execution-based dependency graph $\traceG(c)$. }
%
% \mg{Is this definition given a ``labelled weighted graph'' or an ``execution-based dependency graph''? you did not define the former but only the latter. Also, you say ``there exists'', can there be more sequences of vertices satisfying this definition given a sequence of edges?}
% \jl{execution-based dependency graph}
% \begin{defn}[Finite Walk ($k$)].
% \label{def:finitewalk}
% \\
% Given a labelled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, a \emph{finite walk} $k$ in $G$ is a sequence of edges $(e_1 \ldots e_{n - 1})$ 
% for which there is a sequence of vertices $(v_1, \ldots, v_{n})$ such that:
% \begin{itemize}
%     \item $e_i = (v_{i},v_{i + 1})$ for every $1 \leq i < n$.
%     \item every vertex $v \in \vertxs$ appears in this vertices sequence $(v_1, \ldots, v_{n})$ of $k$ at most 
%     $\weights(v)$ times.  
%     % \[
%     %   \forall v \in (v_1, \ldots, v_{n}), (v, n) \in \weights \st 
%     %   \visit((v_1, \ldots, v_{n}), v) \leq n
%     %   \]
%       \[
%         \forall v \in (v_1, \ldots, v_{n})\st 
%         \visit((v_1, \ldots, v_{n}), v) \leq \weights(v)
%       \]
% \end{itemize}
% $(v_1, \ldots, v_{n})$ is the vertex sequence of this walk, and $\visit((v_1, \ldots, v_{n}), v) $ counts the occurrence times of
% $v$ in sequence $(v_1, \ldots, v_{n})$.
% \\
% %
% Length of this finite walk $k$ is the number of vertices in its vertex sequence, i.e., $\len(k) = n$.
% \end{defn}

% \mg{
% \begin{defn}[Finite Walk in a Labelled Weighted Graph (k)].
% \label{def:finitewalk}
% \\
% Given a labelled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, a \emph{finite walk} $k$ in $G$ is a sequence of edges $(e_1 \ldots e_{n - 1})$ 
% for which there is a sequence of vertices $(v_1, \ldots, v_{n})$ such that:
% \begin{itemize}
%     \item $e_i = (v_{i},v_{i + 1})$ for every $1 \leq i < n$.
%     \item every vertex $v \in \vertxs$ appears in $(v_1, \ldots, v_{n})$ at most 
%     $\weights(v)$ times.  
% \end{itemize}
% %
% The length of $k$ is the number of vertices in its vertex sequence, i.e., $\len(k) = n$.
% \end{defn}
% }
\begin{defn}[Finite Walk (k)].
  \label{def:finitewalk}
  \\
  Given a program $c$'s execution-based dependency graph $G(c) = (\vertxs, \edges, \weights, \qflag)$, 
  a \emph{finite walk} $k$ in $G$ is a sequence of edges $(e_1 \ldots e_{n - 1})$ 
  for which there is a sequence of vertices $(v_1, \ldots, v_{n})$ such that:
  \begin{itemize}
      \item $e_i = (v_{i},v_{i + 1})$ for every $1 \leq i < n$.
      \item every vertex $v \in \vertxs$ appears in $(v_1, \ldots, v_{n})$ at most 
      $\weights(v)$ times.  
  \end{itemize}
  %
  The length of $k$ is the number of vertices in its vertex sequence, i.e., $\len(k) = n$.
  \end{defn}
%
% \mg{Again, you did not define a ``labelled weighted graph''.}
% \jl{Yes, it should be the ``execution-based dependency graph'', I use ``labelled weighted graph'' because I want to 
% define the walk on a more general graph, i.e., ``labelled weighted graph''. But I didn't realized I need to define 
% this ``labelled weighted graph'' first.}
Given 
% labelled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, 
a program $c$'s execution-based dependency graph $G(c) = (\vertxs, \edges, \weights, \qflag)$
we use $\walks(G(c))$ to denote 
% \mg{``the set'', not ``a set''}a set containing all finite walks $k$ in $G$;
the set containing all finite walks $k$ in $G(c)$;
and $k_{v_1 \to v_2} \in \walks(G)$ with $v_1, v_2 \in \vertxs$ denotes the walk from vertex $v_1$ to $v_2$ .
%
% The query length of a walk $k$ is the number of vertices which correspond to query variables in the vertices sequence of this walk. 
% Instead of counting all 
% the vertices in $k$'s vertices sequence, i
\\
\jl{Revised but need more revise}
In order to define the adaptivity which is the dependency depth of the query, we need to recover the 
variables correspond to query from the walk. So we define the query length of a walk, 
instead of counting all 
the vertices in $k$'s vertices sequence, we just count the number of vertices which correspond to query variables in this sequence.
%
% \mg{I don't understand this definition. Is wrt a single query?if yes, who is chosing the query? Or is it any query?}
% \jl{It is for any query, as long as the vertex is a query variable, in another worlds, this length just counting the number of query variables in the walk, instead of counting all 
% the vertices.}
% \todo{Make the definition clear}
\begin{defn}[Query Length of the Finite Walk($\qlen$)].
\label{def:qlen}
\\
Given 
% labelled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, 
a program $c$'s execution-based dependency graph $G(c) = (\vertxs, \edges, \weights, \qflag)$
 and a \emph{finite walk} $k$ in $G(c)$ with its vertex sequence $(v_1, \ldots, v_{n})$, 
%  the length of $k$ w.r.t query is defined as:
The query length of $k$ is the number of vertices which correspond to query variables in $(v_1, \ldots, v_{n})$ as follows, 
\[
  \qlen(k) = \len\big( v \mid v \in (v_1, \ldots, v_{n}) \land \qflag(v) = 1 \big)
\]
, where $\big(v \mid v \in (v_1, \ldots, v_{n}) \land \qflag(v) = 1 \big)$ is a subsequence of $(v_1, \ldots, v_{n})$.
%  $k$'s vertex sequence.
% \mg{If I understand where you want to go, why don't you just use the cardinality of the set above, rather than taking the length of a subsequence?}
% \jl{because the same vertex could have multiple occurrence in the sequence, and we will count all the occurrence instead of just once.
% So the cardinality of set doesn't work.}
\end{defn}
%
%
% \subsection{SSA Transformation and Soundness of Transformation}
% in File {\tt ``ssa\_transform\_sound.tex''}
% \input{ssa_transform_sound}
% %
% %
% The following lemma describes a property of the trace-based dependency graph.
% For any program $c$ with a database $D$ and a initial trace $\trace$,
% the directed edges in its trace-based dependency graph can only be constructed from variable with  
% smaller labels variables of greater ones.
% There doesn't exist backward edges with direction from greater labelled variables to smaller ones.
% \begin{lem}
% \label{lem:edgeforwarding}
% [Edges are Forwarding Only].
% \\
% %
% %
% $$
% \forall \trace \in \mathcal{T}, D \in \dbdom \st G(c, D) =  (\vertxs, \edges, \weights, \qflag) 
% \implies
% \forall (\event', \event) \in \edges \st \event' \eventleq \event
% $$
% %
% \end{lem}
% %
% \begin{proof}
% Proof in File: {\tt ``edge\_forward.tex''}.
% % \input{edge_forward}
% \end{proof}
%
%
% %
% \begin{lem}
% \label{lem:DAG}
% [Trace-based Dependency Graph is Directed Acyclic].
% \\
% %
% $\forall \trace \in \mathcal{T}, D \in \dbdom $, $G(c, D)$ is a directed acyclic graph.
% \end{lem}
%
