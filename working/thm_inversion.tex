% \begin{lem}[Arithmetic Inversion]
% \label{lem:inv_a}
% For all {$ x^i \in \lvar$, and $\trace, \trace' \in \mathcal{T}$,  and arithmetic expression $\aexpr$}, if
% $ \forall z^j \in \lvar / \{x^i\} \st 
% \env(\trace) z = \env(\trace') z $ and $\config{\trace, \aexpr} \aarrow v $ and 
% $\config{\trace', \aexpr} \aarrow v' $ with $v' \neq v$, then $ x $ is in the free variables of $\aexpr$, i.e., $x \in VAR(\aexpr)$.
% %
% % \[
% 	% \forall x^i \in \lvar, \trace, \trace' \in \mathcal{T}, \aexpr \st
% % 	\Big( \forall z^j \in \lvar / \{x^i\} \st 
% % 	\env(\trace) z = \env(\trace') z\Big) \land 
% % 	\config{\trace, \expr} \aarrow v \land \config{\trace', \expr} \aarrow v' \land v \neq v'
% % 	\implies x \in VAR(\expr)
% % \]
% \end{lem}
% %
% %
% \begin{lem}[Boolean Inversion]
% \label{lem:inv_b}
% For all {$ x^i \in \lvar$, and $\trace, \trace' \in \mathcal{T}$,  and boolean expression $\bexpr$}, if
% $ \forall z^j \in \lvar / \{x^i\} \st 
% \env(\trace) z = \env(\trace') z $ and $\config{\trace, \bexpr} \barrow v $ and 
% $\config{\trace', \bexpr} \barrow v' $ with $v' \neq v$, then $ x $ is in the free variables of $\bexpr$, i.e., $x \in VAR(\bexpr)$.
% % \[
% % 	text{(\forall x^i \in \lvar, \trace, \trace' \in \mathcal{T}, \bexpr \st )}
% % 	\Big(\forall z^j \in \lvar / \{x^i\} \st
% % 	\env(\trace) z = \env(\trace') z\Big) \land
% % 	\config{\trace, \bexpr} \barrow v \land \config{\trace', \bexpr} \barrow v' \land v \neq v'
% % 	\implies x \in VAR(\bexpr) 
% % \]
% \end{lem}
% %
% \begin{lem}[Query Inversion]
% \label{lem:inv_q}
% For all {$ x^i \in \lvar$, and $\trace, \trace' \in \mathcal{T}$,  and query expression $\qexpr$}, if
% $ \forall z^j \in \lvar / \{x^i\} \st 
% \env(\trace) z = \env(\trace') z $ and $\config{\trace, \qexpr} \qarrow \qval $ and 
% $\config{\trace', \qexpr} \qarrow \qval' $ with $\qval \neq_{q} \qval'$, then $ x $ is in the free variables of $\qexpr$, i.e., $x \in VAR(\qexpr)$.
% % \[
% % 	\forall x^i \in \lvar, \trace, \trace' \in \mathcal{T}, \qexpr \st 
% % 	\left(\forall z^j \in \lvar / \{x^i \} \st
% % 	\env(\trace) z = \env(\trace') z \right) \implies 
% % 	\config{\trace, \qexpr} \qarrow \qval \land \config{\trace', \qexpr} \qarrow \qval' 
% % 	\implies \qval \neq_{q} \qval'
% % 	\implies x \in VAR(\qexpr) 
% % \]
% \end{lem}
%
\begin{lem}[Expression Inversion]
	\label{lem:inv_expr}
	For all {$ x^i \in \lvar$, and $\trace, \trace' \in \mathcal{T}$, and an expression $\expr$} if
	$ \forall z^j \in \lvar / \{x^i\} \st 
	\env(\trace) z = \env(\trace') z $, and if
	\begin{itemize}
		\item $\expr$ is an arithmetic expression $\aexpr$,
		% \\ 
		and $\config{\trace, \aexpr} \aarrow v $ and 
	$\config{\trace', \aexpr} \aarrow v' $ with $v' \neq v$, 
	then $ x $ is in the free variables of $\aexpr$, i.e., $x \in VAR(\aexpr)$.
%
	\item $\expr$ is a boolean expression $\bexpr$,
	% \\
  and $\config{\trace, \bexpr} \barrow v $ and 
 $\config{\trace', \bexpr} \barrow v' $ with $v' \neq v$, then $ x $ is in the free variables of $\bexpr$, i.e., $x \in VAR(\bexpr)$.
% 
	\item $\expr$ is a query expression $\qexpr$,
	% \\
	and $\config{\trace, \qexpr} \qarrow \qval $ and 
	$\config{\trace', \qexpr} \qarrow \qval' $ with $\qval \neq_{q} \qval'$, then $ x $ is in the free variables of $\qexpr$, i.e., $x \in VAR(\qexpr)$.
\end{itemize}	%
	\end{lem}
	%
	%
	% \begin{lem}[Boolean Inversion]
	% \label{lem:inv_b}
	% For all {$ x^i \in \lvar$, and $\trace, \trace' \in \mathcal{T}$,  and boolean expression $\bexpr$}, if
	% $ \forall z^j \in \lvar / \{x^i\} \st 
	% \env(\trace) z = \env(\trace') z $ and $\config{\trace, \bexpr} \barrow v $ and 
	% $\config{\trace', \bexpr} \barrow v' $ with $v' \neq v$, then $ x $ is in the free variables of $\bexpr$, i.e., $x \in VAR(\bexpr)$.
	% % \[
	% % 	text{(\forall x^i \in \lvar, \trace, \trace' \in \mathcal{T}, \bexpr \st )}
	% % 	\Big(\forall z^j \in \lvar / \{x^i\} \st
	% % 	\env(\trace) z = \env(\trace') z\Big) \land
	% % 	\config{\trace, \bexpr} \barrow v \land \config{\trace', \bexpr} \barrow v' \land v \neq v'
	% % 	\implies x \in VAR(\bexpr) 
	% % \]
	% \end{lem}
	% %
	% \begin{lem}[Query Inversion]
	% \label{lem:inv_q}
	% For all {$ x^i \in \lvar$, and $\trace, \trace' \in \mathcal{T}$,  and query expression $\qexpr$}, if
	% $ \forall z^j \in \lvar / \{x^i\} \st 
	% \env(\trace) z = \env(\trace') z $ and $\config{\trace, \qexpr} \qarrow \qval $ and 
	% $\config{\trace', \qexpr} \qarrow \qval' $ with $\qval \neq_{q} \qval'$, then $ x $ is in the free variables of $\qexpr$, i.e., $x \in VAR(\qexpr)$.
	% % \[
	% % 	\forall x^i \in \lvar, \trace, \trace' \in \mathcal{T}, \qexpr \st 
	% % 	\left(\forall z^j \in \lvar / \{x^i \} \st
	% % 	\env(\trace) z = \env(\trace') z \right) \implies 
	% % 	\config{\trace, \qexpr} \qarrow \qval \land \config{\trace', \qexpr} \qarrow \qval' 
	% % 	\implies \qval \neq_{q} \qval'
	% % 	\implies x \in VAR(\qexpr) 
	% % \]
	% \end{lem}
%
% \begin{lem}[Arithmetic Inversion Generalization]
% 	\label{lem:inv_a_gnl}
% 	% For all {$ x^i \in \lvar$, and $\trace, \trace' \in \mathcal{T}$,  and arithmetic expression $\aexpr$}, if
% 	% $ \forall z^j \in \lvar / \{x^i\} \st 
% 	% \env(\trace) z = \env(\trace') z $ and $\config{\trace, \aexpr} \aarrow v $ and 
% 	% $\config{\trace', \aexpr} \aarrow v' $ with $v' \neq v$, then $ x $ is in the free variables of $\aexpr$, i.e., $x \in VAR(\aexpr)$.
% 	%
% 	For all subset of the labelled variables $\diff \subset \lvar$, and $x^i \in (\lvar \setminus \diff)$,
% 	and an arithmetic expression $\aexpr$,
% 	if for all $z^j \in \lvar \setminus \diff, \trace, \trace' \in \mathcal{T}, v, v'$ such that 
% 	$\env(\trace) z = \env(\trace') z$, and 
% 	$
% 	\config{\trace, \aexpr} \aarrow v$, and $\config{\trace', \aexpr} \aarrow v'$ with $v = v'$;
% 	and for all $z^j \in \lvar / (\diff \cup \{x^i\} )$ 
% 	there exist $\trace, \trace' \in \mathcal{T}, v, v'$ such that 
% 	$\env(\trace) z = \env(\trace') z$, and 
% 	$
% 	\config{\trace, \aexpr} \aarrow v$, and $\config{\trace', \aexpr} \aarrow v'$ with $v \neq v'$,
% 	then $x \in VAR(\aexpr)$ and $i = \llabel(\trace) x$.
% 	\[
% 		\begin{array}{l}
% 		\forall \diff \subset \lvar,  x^i \in (\lvar \setminus \diff), \aexpr \st
% 		\\ \quad
% 		\forall z^j \in \lvar \setminus \diff, \trace, \trace' \in \mathcal{T}, v, v' \st 
% 		\env(\trace) z = \env(\trace') z \land 
% 		\config{\trace, \aexpr} \aarrow v \land \config{\trace', \aexpr} \aarrow v' \land v = v'
% 		\\ \quad
% 		\implies 
% 		\forall z^j \in \lvar / (\diff \cup \{x^i\} ) \st 
% 		 \exists \trace, \trace' \in \mathcal{T}, v, v'\st 
% 		\env(\trace) z = \env(\trace') z \land 
% 		\config{\trace, \aexpr} \aarrow v \land \config{\trace', \aexpr} \aarrow v' \land v \neq v'
% 		\\ \qquad
% 		\implies x \in VAR(\aexpr) \land i = \llabel(\trace) x
% 		\end{array}
% 	\]
% 	\end{lem}
% \begin{proof}.
% 	\\
% 	To show $x \in VAR(\aexpr)$, by showing contradiction ($\forall \trace, \trace'$ in second hypothesis  $v = v'$)
% 	 if $x \notin VAR(\aexpr)$.
% 	 \\
% 	To show $i = \llabel(\trace)$, by showing contradiction ($\forall \trace, \trace'$ in second hypothesis  $v = v'$ ) 
% 	if $j = \llabel(\trace) x$ and $i \neq j$.
% \end{proof}
% 	%
% \begin{lem}[Boolean Inversion Generalization]
% 		\label{lem:inv_b_gnl}
% 		% For all {$ x^i \in \lvar$, and $\trace, \trace' \in \mathcal{T}$,  and arithmetic expression $\aexpr$}, if
% 		% $ \forall z^j \in \lvar / \{x^i\} \st 
% 		% \env(\trace) z = \env(\trace') z $ and $\config{\trace, \aexpr} \aarrow v $ and 
% 		% $\config{\trace', \aexpr} \aarrow v' $ with $v' \neq v$, then $ x $ is in the free variables of $\aexpr$, i.e., $x \in VAR(\aexpr)$.
% 		%
% 		\[
% 			\begin{array}{l}
% 			\forall \diff \subset \lvar,  x^i \in (\lvar \setminus \diff), \bexpr \st
% 			\\ \quad
% 			\forall z^j \in \lvar \setminus \diff, \trace, \trace' \in \mathcal{T}, v, v' \st 
% 			\env(\trace) z = \env(\trace') z \land 
% 			\config{\trace, \bexpr} \barrow v \land \config{\trace', \bexpr} \barrow v' \land v = v'
% 			\\ \quad
% 			\implies 
% 			\forall z^j \in \lvar / (\diff \cup \{x^i\} ) \st 
% 			 \exists \trace, \trace' \in \mathcal{T}, v, v'\st 
% 			\env(\trace) z = \env(\trace') z \land 
% 			\config{\trace, \bexpr} \barrow v \land \config{\trace', \bexpr} \barrow v' \land v \neq v'
% 			\\ \qquad
% 			\implies x \in VAR(\bexpr) \land i = \llabel(\trace)
% 			\end{array}
% 		\]
% \end{lem}%
\begin{lem}[Expression Inversion Generalization]
	\label{lem:inv_expr_gnl}
	For all subset of the labelled variables $\diff \subset \lvar$, and $x^i \in (\lvar \setminus \diff)$,
	and an expression $\expr$, if 
	\begin{itemize}
		\item $\expr$ is an arithmetic expression $\aexpr$,
		% \\ 
		and for all $z^j \in \lvar \setminus \diff, \trace, \trace' \in \mathcal{T}, v, v'$ such that 
		$\env(\trace) z = \env(\trace') z$, and 
		$
		\config{\trace, \aexpr} \aarrow v$, and $\config{\trace', \aexpr} \aarrow v'$ with $v = v'$;
		and for all $z^j \in \lvar / (\diff \cup \{x^i\} )$ 
		there exist $\trace, \trace' \in \mathcal{T}, v, v'$ such that 
		$\env(\trace) z = \env(\trace') z$, and 
		$
		\config{\trace, \aexpr} \aarrow v$, and $\config{\trace', \aexpr} \aarrow v'$ with $v \neq v'$,
		then $x \in VAR(\aexpr)$ and $i = \llabel(\trace) x$.
		\[
			\begin{array}{l}
			\forall \diff \subset \lvar,  x^i \in (\lvar \setminus \diff), \aexpr \st
			\\ \quad
			\forall z^j \in \lvar \setminus \diff, \trace, \trace' \in \mathcal{T}, v, v' \st 
			\env(\trace) z = \env(\trace') z \land 
			\config{\trace, \aexpr} \aarrow v \land \config{\trace', \aexpr} \aarrow v' \land v = v'
			\\ \quad
			\implies 
			\forall z^j \in \lvar / (\diff \cup \{x^i\} ) \st 
			\exists \trace, \trace' \in \mathcal{T}, v, v'\st 
			\env(\trace) z = \env(\trace') z \land 
			\config{\trace, \aexpr} \aarrow v \land \config{\trace', \aexpr} \aarrow v' \land v \neq v'
			\\ \qquad
			\implies x \in VAR(\aexpr) \land i = \llabel(\trace) x
			\end{array}
		\]
	\item $\expr$ is a boolean expression $\bexpr$,
	and for all $ z^j \in \lvar \setminus \diff, \trace, \trace' \in \mathcal{T}, v, v'$ such that 
	$ \env(\trace) z = \env(\trace') z \land 
	\config{\trace, \bexpr} \barrow v \land \config{\trace', \bexpr} \barrow v' \land v = v'$;
	and for all
	$ z^j \in \lvar / (\diff \cup \{x^i\} ) \st 
	 \exists \trace, \trace' \in \mathcal{T}, v, v'\st 
	\env(\trace) z = \env(\trace') z \land 
	\config{\trace, \bexpr} \barrow v \land \config{\trace', \bexpr} \barrow v' \land v \neq v'$
	then 
	 $x \in VAR(\bexpr) \land i = \llabel(\trace)$
	% \\
	\[
		\begin{array}{l}
		\forall \diff \subset \lvar,  x^i \in (\lvar \setminus \diff), \bexpr \st
		\\ \quad
		\forall z^j \in \lvar \setminus \diff, \trace, \trace' \in \mathcal{T}, v, v' \st 
		\env(\trace) z = \env(\trace') z \land 
		\config{\trace, \bexpr} \barrow v \land \config{\trace', \bexpr} \barrow v' \land v = v'
		\\ \quad
		\implies 
		\forall z^j \in \lvar / (\diff \cup \{x^i\} ) \st 
		 \exists \trace, \trace' \in \mathcal{T}, v, v'\st 
		\env(\trace) z = \env(\trace') z \land 
		\config{\trace, \bexpr} \barrow v \land \config{\trace', \bexpr} \barrow v' \land v \neq v'
		\\ \qquad
		\implies x \in VAR(\bexpr) \land i = \llabel(\trace)
		\end{array}
	\]
% 
	\item $\expr$ is a query expression $\qexpr$,
	and for all $\diff \subset \lvar,  x^i \in (\lvar \setminus \diff), \qexpr$ such that 
	for all $ z^j \in \lvar \setminus \diff, \trace, \trace' \in \mathcal{T}, \qval, \qval' \st 
 \env(\trace) z = \env(\trace') z \land 
 \config{\trace, \qexpr} \qarrow \qval \land \config{\trace', \qexpr} \qarrow \qval' \land \qval =_q \qval'$;
 and for all 
	$ z^j \in \lvar / (\diff \cup \{x^i\} ) \st 
  \exists \trace, \trace' \in \mathcal{T}, \qval, \qval'\st 
 \env(\trace) z = \env(\trace') z \land 
 \config{\trace, \qexpr} \qarrow \qval \land \config{\trace', \qexpr} \qarrow \qval' \land \qval \neq_{q} \qval'$,
 then  $x \in VAR(\qexpr) \land i = \llabel(\trace)$.
	% \\
	\[
		\begin{array}{l}
		\forall \diff \subset \lvar,  x^i \in (\lvar \setminus \diff), \qexpr \st
		\\ \quad
		\forall z^j \in \lvar \setminus \diff, \trace, \trace' \in \mathcal{T}, \qval, \qval' \st 
		\env(\trace) z = \env(\trace') z \land 
		\config{\trace, \qexpr} \qarrow \qval \land \config{\trace', \qexpr} \qarrow \qval' \land \qval =_q \qval'
		\\ \quad
		\implies 
		\forall z^j \in \lvar / (\diff \cup \{x^i\} ) \st 
		 \exists \trace, \trace' \in \mathcal{T}, \qval, \qval'\st 
		\env(\trace) z = \env(\trace') z \land 
		\config{\trace, \qexpr} \qarrow \qval \land \config{\trace', \qexpr} \qarrow \qval' \land \qval \neq_{q} \qval'
		\\ \qquad
		\implies x \in VAR(\qexpr) \land i = \llabel(\trace)
		\end{array}
	\]
	\end{itemize}
	\end{lem}
	%
\begin{proof}.
	\\
	To show $x \in VAR(\aexpr)$, by showing contradiction ($\forall \trace, \trace'$ in second hypothesis  $v = v'$)
	 if $x \notin VAR(\aexpr)$.
	 \\
	To show $i = \llabel(\trace)$, by showing contradiction ($\forall \trace, \trace'$ in second hypothesis  $v = v'$ ) 
	if $j = \llabel(\trace) x$ and $i \neq j$.
\end{proof}
	%
% \begin{lem}[Boolean Inversion Generalization]
% 		\label{lem:inv_b_gnl}
% 		% For all {$ x^i \in \lvar$, and $\trace, \trace' \in \mathcal{T}$,  and arithmetic expression $\aexpr$}, if
% 		% $ \forall z^j \in \lvar / \{x^i\} \st 
% 		% \env(\trace) z = \env(\trace') z $ and $\config{\trace, \aexpr} \aarrow v $ and 
% 		% $\config{\trace', \aexpr} \aarrow v' $ with $v' \neq v$, then $ x $ is in the free variables of $\aexpr$, i.e., $x \in VAR(\aexpr)$.
% 		%
% 		\[
% 			\begin{array}{l}
% 			\forall \diff \subset \lvar,  x^i \in (\lvar \setminus \diff), \bexpr \st
% 			\\ \quad
% 			\forall z^j \in \lvar \setminus \diff, \trace, \trace' \in \mathcal{T}, v, v' \st 
% 			\env(\trace) z = \env(\trace') z \land 
% 			\config{\trace, \bexpr} \barrow v \land \config{\trace', \bexpr} \barrow v' \land v = v'
% 			\\ \quad
% 			\implies 
% 			\forall z^j \in \lvar / (\diff \cup \{x^i\} ) \st 
% 			 \exists \trace, \trace' \in \mathcal{T}, v, v'\st 
% 			\env(\trace) z = \env(\trace') z \land 
% 			\config{\trace, \bexpr} \barrow v \land \config{\trace', \bexpr} \barrow v' \land v \neq v'
% 			\\ \qquad
% 			\implies x \in VAR(\bexpr) \land i = \llabel(\trace)
% 			\end{array}
% 		\]
% \end{lem}%
%
% \begin{lem}[Assignment Inversion].
% \label{lem:inv_a}
% \[
% 	\forall x \in \lvar, \expr \st 
% 	\Big( \exists \trace, \trace' \st \forall z^i \in \lvar / \{x^l\} \st 
% 	\env(\trace) z = \env(\trace') z \st 
% 	\config{\trace, \expr} \aarrow v \land \config{\trace', \expr} \aarrow v' \land v  \neq v'
% 	\implies x \in VAR(\expr) \land x^l \in \Big)
% \]
% \end{lem}
%
% \begin{lem}[Assignment Event Inversion]
% \label{lem:inv_asn}
% \[
% \begin{array}{l}
% 	\forall \trace_0 \in \mathcal{T}, c \in \cdom,
% 	\event \in \eventset^{\asn} \st
% 	\config{c, \trace_0} \rightarrow^* \config{\eskip, \trace_0 \tracecat \trace_1} \implies
% 	(\event \eventin \trace_1 \land	x = \pi_1(\event) \land l = \pi_2(\event))
% 	\\ 
% 	\implies 
% 	\big( 
% 		\exists \trace_1' \in \mathcal{T}, \expr, c' \st
% 		\config{c, \trace_0} \rightarrow^* \config{ [\assign{x}{\expr}]^l;c', \trace_0  \tracecat  \trace'} \rightarrow^{assn}
% 		\config{c', \trace_0 \tracecat \trace_1'\cdot \event} \rightarrow^{*}
% 		\config{\eskip, \trace_0  \tracecat  \trace_1}
% 	\big)
% 	\\ \qquad \lor
% 	\big( 
% 		\exists \trace_1' \in \mathcal{T}, \qexpr, c' \st
% 		\config{c, \trace_0} \rightarrow^* \config{ [\assign{x}{\query(\qexpr)}]^l;c', \trace_0 \tracecat \trace_1'} \rightarrow^{query}
% 		\config{c', \trace_0  \tracecat  \trace_1' \cdot \event } \rightarrow^{*}
% 		\config{ \eskip, \trace_0\trace_1}
% 	\big)
% \end{array}
% \]
% %
% \end{lem}
% %
% \begin{lem}[Testing Event Inversion]
% \label{lem:inv_test}
% \[
% \begin{array}{l}
% 	\forall c\in \cdom, \trace_0 \in \mathcal{T}, \event = (b, l, n, v) \in \eventset^{\test} \st
% 	 \config{c, \trace_0} \rightarrow^* \config{\eskip, \trace_0 \tracecat \trace_1}
% 	\implies  \event \eventin \trace_1 \\
% 	\implies 
% 	\big( 
% 		\exists \trace_1' \in \mathcal{T}, \bexpr, c', c_t, c_f, c'' \in \cdom \st
% 		\config{c, \trace_0} \rightarrow^* \config{\eif ([b]^l, c_t, c_f);c', \trace_0 \tracecat \trace_1'} \rightarrow^{if-b}
% 		\config{c'', \trace_0 \tracecat \trace_1'\cdot \event } \rightarrow^{*}
% 		\config{\eskip, \trace_0 \tracecat \trace_1} 
% 	\big)
% 	\\ \qquad \lor
% 	\big( 
% 		\exists \trace_1' \in \mathcal{T}, \bexpr, c', c_w, c'' \in \cdom \st
% 		\config{c, \trace_0} \rightarrow^* \config{ \ewhile([b]^l, c_w);c', \trace_0 \tracecat  \trace_1'} \rightarrow^{while-b}
% 		\config{c'', \trace_0 \tracecat \trace_1'\cdot \event } \rightarrow^{*}
% 		\config{\eskip, \trace_0  \tracecat \trace_1}
% 	\big)
% \end{array}
% \]
% \end{lem}
\begin{lem}[Event Inversion]
\label{lem:inv_event}
For all $\forall c\in \cdom, \trace_0 \in \mathcal{T}, \event \in \eventset$such that 
$\config{c, \trace_0} \rightarrow^* \config{\eskip, \trace_0 \tracecat \trace_1}$, 
and $\event \eventin \trace_1$, if 
\begin{itemize}
	\item $\event \in \eventset^{\asn}$, then either
	\begin{itemize}

	 \item there exists $\trace_1' \in \mathcal{T}, c' \in \cdom, \expr$ such that
\[
\begin{array}{l}
	% \forall \trace_0 \in \mathcal{T}, c \in \cdom,
	% \event \in \eventset^{\asn} \st
	% \config{c, \trace_0} \rightarrow^* \config{\eskip, \trace_0 \tracecat \trace_1} \implies
	% (\event \eventin \trace_1 \land	x = \pi_1(\event) \land l = \pi_2(\event))
	% \\ 
	% \implies 
	% \big( 
		% \exists \trace_1' \in \mathcal{T}, \expr, c' \st
		\config{c, \trace_0} \rightarrow^* \config{ [\assign{x}{\expr}]^l;c', \trace_0  \tracecat  \trace'} \rightarrow^{assn}
		\config{c', \trace_0 \tracecat \trace_1'\cdot \event} \rightarrow^{*}
		\config{\eskip, \trace_0  \tracecat  \trace_1}
	% \big)
	% \\  \lor
	% \big( 
	% 	\exists \trace_1' \in \mathcal{T}, \qexpr, c' \st
	% 	\config{c, \trace_0} \rightarrow^* \config{ [\assign{x}{\query(\qexpr)}]^l;c', \trace_0 \tracecat \trace_1'} \rightarrow^{query}
	% 	\config{c', \trace_0  \tracecat  \trace_1' \cdot \event } \rightarrow^{*}
	% 	\config{ \eskip, \trace_0\trace_1}
	% \big)
\end{array}
\]
\item or there exists $\trace_1' \in \mathcal{T}, c' \in \cdom, \qexpr$ such that 
\[
\begin{array}{l}
	% \forall \trace_0 \in \mathcal{T}, c \in \cdom,
	% \event \in \eventset^{\asn} \st
	% \config{c, \trace_0} \rightarrow^* \config{\eskip, \trace_0 \tracecat \trace_1} \implies
	% (\event \eventin \trace_1 \land	x = \pi_1(\event) \land l = \pi_2(\event))
	% \\ 
	% \implies 
	% \big( 
	% 	\exists \trace_1' \in \mathcal{T}, \expr, c' \st
	% 	\config{c, \trace_0} \rightarrow^* \config{ [\assign{x}{\expr}]^l;c', \trace_0  \tracecat  \trace'} \rightarrow^{assn}
	% 	\config{c', \trace_0 \tracecat \trace_1'\cdot \event} \rightarrow^{*}
	% 	\config{\eskip, \trace_0  \tracecat  \trace_1}
	% \big)
	% \\  \lor
	% \big( 
		% \exists \trace_1' \in \mathcal{T}, \qexpr, c' \st
		\config{c, \trace_0} \rightarrow^* \config{ [\assign{x}{\query(\qexpr)}]^l;c', \trace_0 \tracecat \trace_1'} \rightarrow^{query}
		\config{c', \trace_0  \tracecat  \trace_1' \cdot \event } \rightarrow^{*}
		\config{ \eskip, \trace_0\trace_1}
	% \big)
\end{array}
\]
\end{itemize}

\item $\event\in \eventset^{\test}$ then either 
\begin{itemize}
\item there exists $\trace_1' \in \mathcal{T}, c', c_t, c_f, c'' \in \cdom, \bexpr$ such that
\[
\begin{array}{l}
	% \big( 
	% 	\exists \trace_1' \in \mathcal{T}, c', c_t, c_f, c'' \in \cdom, \bexpr \st
		\config{c, \trace_0} \rightarrow^* \config{\eif ([b]^l, c_t, c_f);c', \trace_0 \tracecat \trace_1'} \rightarrow^{if-b}
		\config{c'', \trace_0 \tracecat \trace_1'\cdot \event } \rightarrow^{*}
		\config{\eskip, \trace_0 \tracecat \trace_1} 
	% \big)
	% \\  \lor
	% \big( 
	% 	\exists \trace_1' \in \mathcal{T}, \bexpr, c', c_w, c'' \in \cdom \st
	% 	\config{c, \trace_0} \rightarrow^* \config{ \ewhile([b]^l, c_w);c', \trace_0 \tracecat  \trace_1'} \rightarrow^{while-b}
	% 	\config{c'', \trace_0 \tracecat \trace_1'\cdot \event } \rightarrow^{*}
	% 	\config{\eskip, \trace_0  \tracecat \trace_1}
	% \big)
\end{array}
\]
\item or there exists $ \trace_1' \in \mathcal{T}, c', c_w, c'' \in \cdom, \bexpr$ such that 
\[
% \begin{array}{l}
% 	\big( 
% 		\exists \trace_1' \in \mathcal{T}, \bexpr, c', c_t, c_f, c'' \in \cdom \st
% 		\config{c, \trace_0} \rightarrow^* \config{\eif ([b]^l, c_t, c_f);c', \trace_0 \tracecat \trace_1'} \rightarrow^{if-b}
% 		\config{c'', \trace_0 \tracecat \trace_1'\cdot \event } \rightarrow^{*}
% 		\config{\eskip, \trace_0 \tracecat \trace_1} 
% 	\big)
% 	\\  \lor
% 	\big( 
% 		\exists \trace_1' \in \mathcal{T}, \bexpr, c', c_w, c'' \in \cdom \st
		\config{c, \trace_0} \rightarrow^* \config{ \ewhile([b]^l, c_w);c', \trace_0 \tracecat  \trace_1'} \rightarrow^{while-b}
		\config{c'', \trace_0 \tracecat \trace_1'\cdot \event } \rightarrow^{*}
		\config{\eskip, \trace_0  \tracecat \trace_1}
% 	\big)
% \end{array}
\]
\end{itemize}
\end{itemize}
%
\end{lem}
%
% \begin{lem}[Testing Event Inversion]
% \label{lem:inv_test}
% \[
% \begin{array}{l}
% 	\forall c\in \cdom, \trace_0 \in \mathcal{T}, \event = (b, l, n, v) \in \eventset^{\test} \st
% 	 \config{c, \trace_0} \rightarrow^* \config{\eskip, \trace_0 \tracecat \trace_1}
% 	\implies  \event \eventin \trace_1 \\
% 	\implies 
% 	\big( 
% 		\exists \trace_1' \in \mathcal{T}, \bexpr, c', c_t, c_f, c'' \in \cdom \st
% 		\config{c, \trace_0} \rightarrow^* \config{\eif ([b]^l, c_t, c_f);c', \trace_0 \tracecat \trace_1'} \rightarrow^{if-b}
% 		\config{c'', \trace_0 \tracecat \trace_1'\cdot \event } \rightarrow^{*}
% 		\config{\eskip, \trace_0 \tracecat \trace_1} 
% 	\big)
% 	\\ \qquad \lor
% 	\big( 
% 		\exists \trace_1' \in \mathcal{T}, \bexpr, c', c_w, c'' \in \cdom \st
% 		\config{c, \trace_0} \rightarrow^* \config{ \ewhile([b]^l, c_w);c', \trace_0 \tracecat  \trace_1'} \rightarrow^{while-b}
% 		\config{c'', \trace_0 \tracecat \trace_1'\cdot \event } \rightarrow^{*}
% 		\config{\eskip, \trace_0  \tracecat \trace_1}
% 	\big)
% \end{array}
% \]
% \end{lem}
%
% \begin{lem}[Control Dependency -> Exists Testing Event]
% \label{lem:inv_ctltotest}
% \[
% 	\forall \event_1, \event_2 \in \eventset, c \st 
% 	\eventdep^{\ctl}(\event_1, \event_2, c, D)
% 	\implies
% 	\exists \event_b \in \eventset^{\test}, \trace_2 \in \mathcal{T} \st \eventdep^{val}(\event_1, \event_b, \trace_2, c, D)
% \]
% \end{lem}

% \begin{lem}[Control Dependency -> Event 2 in the Body Command of the Testing Event]
% \label{lem:inv_ctltoevent2}
% \[
% \begin{array}{l}
% 	\forall \event_1, \event_2 = (x_2, l_2, n_2, v_2) \in \eventset, c \st 
% 	\eventdep^{\ctl}(\event_1, \event_2, c, D)\\
% 	\implies
% 	\exists \event_b = (b, l, n, v) \in \eventset^{\test}, \expr_2 \st \eventdep^{val}(\event_1, \event_b, c, D)\\
% 	\quad \land \Big(
% 	\exists c_t, c_f \st (\eif ([b]{}^l, c_t, c_f)) \in_{c} c \land ([\assign{x_2}{\expr_2}]^{l_2}) \in_c c_t;c_f \\
% 	\qquad \lor\exists c_w \st (\ewhile [b]{}^l \edo c_w) \in_{c} c \land ([\assign{x_2}{\expr_2}]^{l_2}) \in_c c_w
% 	\Big)
% \end{array}
% \]
% \end{lem}
%
\begin{lem}[Liveness Inversion]
\label{lem:inv_live}
For all $c \in \cdom \trace, \trace' \in \mathcal{T} $, if 
$\config{c, \trace} \xrightarrow{}^* \config{c', \trace'}$,
and for all $x^l \in \lvar_c$ such that 
$\llabel(\trace') x = l $, then $(x^l \in \live^{\entry_{c'}}(c))$.
%
\[
	\forall c \in \cdom , \trace, \trace' \in \mathcal{T} \st
	\config{c, \trace} \xrightarrow{}^* \config{c', \trace'}
	\implies
	\forall x^l \in \lvar_c \st \llabel(\trace') x = l \implies (x^l \in \live^{\entry_{c'}}(c))
\]
\end{lem}
%
%
\begin{lem}[Control Dependency Inversion]
\label{lem:ctldep_inv}
For all $c \in \cdom$, $D \in \dbdom, \event_b \in \eventset^{\test}, \event \in \eventset^{\asn} $, if 
$\eventdep^{\ctl}(\event_b, \event, c, D)$, 
then for all  $z \in VAR(\pi_1(\event_b))$ there exists a label $i \in \mathbb{N}$ such that 
$\flowsto(z^i, \pi_1(\event)^{\pi_2(\event)}, c)$
\[		
	\begin{array}{l}
		\forall c \in \cdom, D \in \dbdom, \event_b \in \eventset^{\test}, \event \in \eventset^{\asn} \st 
		\eventdep^{\ctl}(\event_b, \event, c, D) 
		\\ \quad 
		\implies
		\forall z \in VAR(\pi_1(\event_b)) \st \exists i \in \mathbb{N} \st
		\flowsto(z^i, \pi_1(\event)^{\pi_2(\event)}, c)
\end{array}
\]
\end{lem}
\begin{proof}
	Proving by using the Inversion Lemmas~\ref{lem:inv_expr_gnl}, ~\ref{lem:inv_expr},
	\ref{lem:inv_event}, and \ref{lem:inv_live}, and control dependency definition.
\end{proof}
%
\begin{lem}[One Step Dependency Inversion]
	\label{lem:onestepdep_inv}
For all $ c \in \cdom, D \in \dbdom, x^i \in \lvar_c$, and $\event_y \in \eventset^{\asn}$, 
if $x^i \in VAR(\expr_y)$, 
or there exists $\event_b \in \eventset^{\test}$ such that 
$x^i \in VAR(\pi_1(\event_b)$ and 
$\eventdep^{\ctl}(\event_b, \event_y, c, D)$, then $\flowsto(x^i, \pi_1(\event_y)^{\pi_2(\event_y)}, c)$.
%
	\[
	\begin{array}{l}
		\forall c \in \cdom, D \in \dbdom, x^i \in \lvar_c, \event_y \in \eventset^{\asn}
		\st
		\\ \quad
		(x^i \in VAR(\expr_y)\lor 
		(\exists \event_b \in \eventset^{\test} \st x^i \in VAR(\pi_1(\event_b)) 
		\land \eventdep^{\ctl}(\event_b, \event_y, c, D)))
		\implies \flowsto(x^i, \pi_1(\event_y)^{\pi_2(\event_y)}, c)
	\end{array}
\]
\end{lem}
\begin{proof}
	proving by using the Inversion Lemmas~\ref{lem:inv_expr_gnl}, ~\ref{lem:inv_expr},
	\ref{lem:inv_event}, and \ref{lem:inv_live}, 
	and Control Dependency Inversion Lemmas~\ref{lem:ctldep_inv}.
\end{proof}
%
\begin{lem}[Multiple Steps Dependency Inversion]
	\label{lem:depevents_exist}
For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, and two assignment events 
$\event_1, \event_2 \in \eventset^{\asn}$,
if the trace $trace$ has the form $\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ with $\trace' \in \mathcal{T}$, and $\eventdep(\event_1, \event_2, \trace, c, D)$
then $\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) $,
or otherwise there exists
$\event \in \trace'$ such that
$\left( 		
   \eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
\land 
\flowsto(\pi_1(\event)^{\pi_2(\event)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
\right)$.
%
	\[
	\begin{array}{l}
		\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} \st \forall \event_1, \event_2 \in \eventset^{\asn} \st
		 \exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]
		\implies
		\eventdep(\event_1, \event_2, \trace, c, D) 
		\\ \quad 
		\implies 
		\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
		\\ \qquad \quad \lor
		\exists \event \in \trace' \st 
		\left( 		
			\eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
		\land 
		\flowsto(\pi_1(\event)^{\pi_2(\event)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
	\right) 
		% \\ \qquad \qquad \lor
		% \flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
	\end{array}
	\]
\end{lem}
\begin{proof}
	Proving by using Lemma~\ref{lem:inv_indepevents}, Lemma~\ref{lem:onestepdep_inv}, and the Inversion Lemmas~\ref{lem:inv_expr_gnl}, ~\ref{lem:inv_expr},
	\ref{lem:inv_event}, and \ref{lem:inv_live}
	and showing a contradiction.
\end{proof}
%
\begin{lem}[Independent Events Doesn't Block $\flowsto$ ]
		\label{lem:inv_indepevents}
		The following two conclusions hold for assignment event and testing event separately.
	\begin{itemize}
		\item
		For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, and two assignment events 
		$\event_1, \event_2 \in \eventset^{\asn}$,
		if the trace $trace$ has the form $\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ with $\trace' \in \mathcal{T}$, and $\eventdep(\event_1, \event_2, \trace, c, D)$,
		and every $\event \in \trace'$ doesn't have the dependency relations both on $\event_1$ and to $\event_2$,
		then 
		the labelled variable $\pi_1(\event_1)^{\pi_2(\event_1)}$ directly flows to the other one $\pi_1(\event_2)^{\pi_2(\event_2)}$, i.e., 
		$\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)$.
		%
		\[
		\begin{array}{l}
			\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} \st \forall \event_1, \event_2 \in \eventset^{\asn} \st
			 \exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]
			\implies
			\eventdep^{val}(\event_1, \event_2, \trace, c, D) 
			\\ \quad 
			\implies 
			\left( \forall \event \in \trace' \st \neg \eventdep^{val}(\event_1, \event, \trace[\event_1:\event], c, D)
			\lor \neg \eventdep^{val}(\event, \event_2, \trace[\event:\event_2], c, D) 
			\right) 
			\\ \quad 
			\implies 
			\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)
		\end{array}
		\]
\item 
For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, an assignment event
$\event_1 \in \eventset^{\asn}$ and a test event $\event_2 \in \eventset^{\test}$,
if the trace $trace$ has the form $\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ with $\trace' \in \mathcal{T}$, 
and $\eventdep(\event_1, \event_2, \trace, c, D)$,
and every $\event \in \trace'$ doesn't have the \emph{May-Dependency} relations both on $\event_1$ and to $\event_2$,
then 
$\pi_1(\event_1) \in VAR(\pi_1(\event_2))$, and $ {\pi_2(\event_1)} = \llabel(\trace)$
%
\[
\begin{array}{l}
	\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} \st \forall \event_1,\in \eventset^{\asn}, \event_2 \in \eventset^{\test} \st
	 \exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]
	\implies
	\eventdep^{val}(\event_1, \event_2, \trace, c, D) 
	\\ \quad 
	\implies 
	\left( \forall \event \in \trace' \st \neg \eventdep^{val}(\event_1, \event, \trace[\event_1:\event], c, D)
	\lor \neg \eventdep^{val}(\event, \event_2, \trace[\event:\event_2], c, D) 
	\right) 
	\\ \quad 
	\implies 
	\pi_1(\event_1) \in VAR(\pi_1(\event_2)) \land {\pi_2(\event_1)} = \llabel(\trace)
\end{array}
\]
\end{itemize}
\end{lem}
%
\begin{proof}
Taking arbitrary $D \in \dbdom , c \in \cdom$, and two assignment events $\event_1, \event_2\in \eventset^{\asn}$.
\\
Picking a trace satisfying $\trace = [\event_1] \tracecat \trace_2 \tracecat [\event_2]$ for arbitrary $\trace_2 \in \mathcal{T}$,
 then we know 
\\
$\exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ by picking $\trace' = \trace_2$.
\\
Unfolding $\eventdep^{val}(\event_1, \event_2, \trace, c, D)$, we know there exist $ \event_1', \event_2' \in \eventset^{\asn},
\trace_2' \in \mathcal{T}, c_1, c_2 \in \cdom$ such that 
$\diff(\event_2, \event_2')$,
 and following two executions:
% \[
%   \exists \event_1', \event_2' \in \eventset^{\asn},
%   \trace_2' \in \mathcal{T}, c_1, c_2 \in \cdom \st
% \]
%
\[
\begin{array}{l}
\config{c, \trace_0} \rightarrow^{*}
\config{c_1, \trace_1 \tracecat [\event_1]} \rightarrow^{*} \config{c_2, \trace_1 \tracecat [\event_1] \tracecat \trace_2 \tracecat [\event_2]} 
\\ \quad
\land
\config{c_1, \trace_1 \tracecat [\event_1']} \rightarrow^{*} \config{c_2, \trace_1 \tracecat [\event_1'] \tracecat \trace_2' \tracecat [\event_2']} 
\end{array}
\]
%
%
By inversion Lemma.~\ref{lem:inv_event} on $\event_2$ and $\event_2'$ in the two executions, 
since $\diff(\event_2, \event_2)$ we know there exists an expression $\expr_2$ or $\qexpr_2$ in the following two execution instances:
\[
\config{c_1, \trace_1 \tracecat [\event_1]} \rightarrow^{*} \config{[\assign{\pi_1(\event_2)}{\expr_2 / \query(\qexpr_2)}]{}^{\pi_2(\event_2)};c_2, \trace_1 \tracecat [\event_1] \tracecat \trace_2} 
\rightarrow^{asn / query} \config{c_2, \trace_1 \tracecat [\event_1] \tracecat \trace_2 \tracecat [\event_2]}  
\]
%
\[
\config{c_1, \trace_1 \tracecat [\event_1']} \rightarrow^{*} \config{[\assign{\pi_1(\event_2)}{\expr_2 / \query(\qexpr_2)}]{}^{\pi_2(\event_2)};c_2, \trace_1 \tracecat [\event_1'] \tracecat \trace_2'} 
\rightarrow^{asn / query} \config{c_2, \trace_1 \tracecat [\event_1'] \tracecat \trace_2' \tracecat [\event_2']}  
\]
%
Let $\diff_{\eventset}$ be a subset of the events in $\trace_2$, satisfying: 
% \todo{refine the notation}
\[
	\begin{array}{l}
		\forall \event_z \in \eventset^{\asn} \st 
	\event_z \in \diff_{\eventset} \Leftrightarrow 
	\exists \trace_2^h, \trace'^h_2, \trace_2^t, \trace'^t_2, \event_z' \in \trace_2' \st 
	\trace_2 = \trace_2^h \tracecat [\event_z] \tracecat \trace_2^t
	\\ \quad
	\land 
	\trace_2' = \trace'^h_2 \tracecat [\event_z'] \tracecat \trace'^t_2
	\land 
	\diff(\event_z, \event_z')
	\land 
	\vcounter(\trace_2^h) \pi_1(\event_z) = \vcounter(\trace'^h_2)(\event_z)
\end{array}		
\]
%
Then we know for all $\event_z \in  \diff_{\eventset}$,
 $\eventdep^{val}(\event_1, \event_z, \trace[\event_1:\event_z], c, D)$;
\\
and $\forall z^j \in (\lvar \setminus (\mathbb{LV}_{\diff_{\eventset}} \cup\{\pi_1(\event_1)^{\pi_2(\event_2)}\}) ) \st 
\env(\trace_1 \tracecat [\event_1] \tracecat \trace_2) z = \env(\trace_1 \tracecat [\event_1'] \tracecat \trace_2') z $,
\\
where $\mathbb{LV}_{\diff_{\eventset}}$ is the set of labelled variables of every event in $\diff_{\eventset}$.
\\
From the hypothesis, we know for all $\event_z \in  \diff_{\eventset}$, $\neg \eventdep^{val}(\event_z, \event_2, \trace[\event_z:\event_2], c, D) $.
\\
Then by $\eventdep^{val}$ definition, we know 
$\forall \event_z', \event_2'' \in \eventset^{\asn}, \trace_z',\trace_z,  \trace_1' \in \mathcal{T}, c_z \in \cdom$ satisfying following two executions, we have $\event_2 \eventeq \event_2''$.
\[
	\begin{array}{l}
		\config{c, \trace_0} \rightarrow^{*}
		\config{c_z, \trace_1' \tracecat [\event_z]} \rightarrow^{*} \config{c_2, \trace_1' \tracecat [\event_z] \tracecat \trace_z \tracecat [\event_2]} 
		\\ \quad
		\land
		\config{c_z, \trace_1' \tracecat [\event_z']} \rightarrow^{*} \config{c_2, \trace_1' \tracecat [\event_z'] \tracecat \trace_z' \tracecat [\event_2']'} 
		\end{array}		
\]
%
Then we know 
% \todo{type correctness}
\[
	\forall z^j \in (\lvar \setminus \mathbb{LV}_{\diff_{\eventset}} ), \trace, \trace' \in \mathcal{T}, v, v' \st 
	\env(\trace) z = \env(\trace') z 
	\land 
	\config{\trace, \expr_2} \aarrow v 
	\land 
	\config{\trace', \expr_2} \aarrow v'
	\land 
	v = v' 
\]
%
Since $\diff(\event_2, \event_2')$, we also know:
%
\[	
\config{\trace_1 \tracecat [\event_1] \tracecat \trace_2, \expr_2} \aarrow \pi_3(\event_2)
\land 
\config{\trace_1 \tracecat [\event_1'] \tracecat \trace_2', \expr_2} \aarrow \pi_3(\event_2') 
\land 
\pi_3(\event_2) \neq \pi_3(\event_2')
\]
%
% By construction of $\diff_{\eventset}$, we also have:
% \\
% $\forall z^j \in (\lvar \setminus \diff_{\eventset} \cup\{\event_1\} ) \st 
% \env(\trace_1 \tracecat [\event_1] \tracecat \trace_2) z = \env(\trace_1 \tracecat [\event_1'] \tracecat \trace_2') z $.
% \\
% By $\forall \event \in (\trace[\event_1:\event_y]\setminus \{\event_1, \event_y\}) \st
%   \neg \eventdep^{val} (\event_1, \event, c, D) \lor \neg \eventdep^{val} (\event, \event_y, c, D)$,
Then, we know $\event_1$ is the only cause of the difference in $\event_y$ and $\event_y'$ when evaluating 
$[\assign{\pi_1(\event_2)}{\expr_2 / \query(\qexpr_2)}]{}^{\pi_2(\event_2)}$.
%
\\
By inversion Lemma.~\ref{lem:inv_expr_gnl}, we know
\[
  \pi_1(\event_1) \in VAR(\expr) \land {\pi_2(\event_1)} = \llabel(\trace_1 \tracecat [\event_1] \tracecat \trace_2) \pi_1(\event_1) 
\]
%
By $\flowsto$ definition:
% \todo{add the Liveness inversion}
\[
  \flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_y)^{\pi_2(\event_y)}, c)
\]
\end{proof}
%
Following lemmas are for the inductive proof of the flowsto chain.
\begin{lem}[Dependency with Empty Trace Implies $\flowsto$ ]
	\label{lem:emptytrace_dep}
	For every $ c \in \cdom, D \in \dbdom$ and two assignment events $\event_1, \event_2 \in \eventset^{\asn}$,
	if $\eventdep^{val}(\event_1, \event_2, [\event_1; \event_2],  c, D) $,
	then, $\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)$.
	%
	\[
	\begin{array}{l}
		\forall \event_1, \event_2 \in \eventset^{\asn}, c \in \cdom, D \in \dbdom 
		\st 
		\eventdep^{val}(\event_1, \event_2, [\event_1; \event_2],  c, D) 
		\\ \quad 
		\implies 
		\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)
	\end{array}
	\]
\end{lem}
\begin{proof}
	This lemma is a special case of Lemma~\ref{lem:inv_indepevents} and proved in Subproof~\ref{pf:alg_correct_base}.
\end{proof}
%
\begin{lem}[Only $\eskip$ Command doesn't Produce Event].
	\label{lem:inv_skip}
	For all trace $\trace\in \mathcal{T}$, and $c, c' \in \cdom$,  
	$\config{c, \trace} \rightarrow \config{c', \trace}$ if and only if $c = [\eskip];c'$. 
	\[
		\forall \trace\in \mathcal{T}, c, c' \in \cdom \st
		\config{c, \trace} \rightarrow \config{c', \trace}
		\Leftrightarrow 
		c = [\eskip];c'
	% \footnote{$([\eskip];){}^*$ denotes a sequence command only composed of $[\eskip]$ commands.}
	\]
	\end{lem}	
%
% \begin{lem}[Independent Events Doesn't Block $\flowsto$ for Testing Event]
% 	\label{lem:inv_indepeventstest}
% 	%
% 	For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, an assignment event
% 	$\event_1 \in \eventset^{\asn}$ and a test event $\event_2 \in \eventset^{\test}$,
% 	if the trace $trace$ has the form $\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ with $\trace' \in \mathcal{T}$, 
% 	and $\eventdep(\event_1, \event_2, \trace, c, D)$,
% 	and every $\event \in \trace'$ doesn't have the \emph{May-Dependency} relations both on $\event_1$ and to $\event_2$,
% 	then 
% 	$\pi_1(\event_1) \in VAR(\pi_1(\event_2))$, and $ {\pi_2(\event_1)} = \llabel(\trace)$
% 	%
% 	\[
% 	\begin{array}{l}
% 		\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} \st \forall \event_1,\in \eventset^{\asn}, \event_2 \in \eventset^{\test} \st
% 		 \exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]
% 		\implies
% 		\eventdep^{val}(\event_1, \event_2, \trace, c, D) 
% 		\\ \quad 
% 		\implies 
% 		\left( \forall \event \in \trace' \st \neg \eventdep^{val}(\event_1, \event, \trace[\event_1:\event], c, D)
% 		\lor \neg \eventdep^{val}(\event, \event_2, \trace[\event:\event_2], c, D) 
% 		\right) 
% 		\\ \quad 
% 		\implies 
% 		\pi_1(\event_1) \in VAR(\pi_1(\event_2)) \land {\pi_2(\event_1)} = \llabel(\trace)
% 	\end{array}
% 	\]
% \end{lem}
%
\begin{lem}[Flow Search Algorithm ($\mathcal{A}$) Inversion 1]
\label{lem:inv_alg1}
For all $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}, \event_1, \event_2 \in \eventset^{\asn}$, and a list $l$,
if $l \in \mathcal{A}(\event_1, \event_2, \trace, c, D)$,
then l must have the form $[\pi_1(\event_1)^{\pi_2(\event_1)},\ldots, \pi_1(\event_2)^{\pi_2(\event_2)}]$.
\[
\begin{array}{l}
    \forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}, l \st \forall \event_1, \event_2 \in \eventset^{\asn} \st
  \\ \quad 
 l\in \mathcal{A}(\event_1, \event_2, \trace, c, D)  \implies  l = [\pi_1(\event_1)^{\pi_2(\event_1)},\ldots, \pi_1(\event_2)^{\pi_2(\event_2)}]
\end{array}
\]
\end{lem}
%
\begin{proof}
% Let $l \in \mathcal{A}(\event_1, \event_2, \trace, c, D)$. By definition of $\mathcal{A}$ we have 
% \[l\in \kw{setmap} 
% 	% \bigcup\limits_{l \in \kw{dfs}(\trace, c, D) \land l = \event_1 :: l'}
% 	\left(\emap 
% 		(\efun  \event \to \pi_1(\event)^{\pi_2(\event)})	
% 	(\efilter 
% 		(\efun \event \to  \event \in \eventset^{\asn})) \right)
% 	S
% \]
% for $S=\kw{setfilter}
% 		(\efun l \to \exists l' \st l = \event_1 :: l' ++ [\event_2]) ~ \kw{dfs}(\trace, c, D)$.
% So, in particular by definition of setmap there is a list $l_1\in S$ such that 
% \[
% 	% \bigcup\limits_{l \in \kw{dfs}(\trace, c, D) \land l = \event_1 :: l'}
% \emap 
% 		(\efun  \event \to \pi_1(\event)^{\pi_2(\event)})	
% 	(\efilter 
% 		(\efun \event \to  \event \in \eventset^{\asn}))
% 	l_1 = l
% \]
% \[
% l = [\event_1, \cdots, \event_2]
% \]
% \\
Let  $l \in \mathcal{A}(\event_1, \event_2, \trace, c, D)$,
by definition of $\mathcal{A}$, we know 
%
$$l\in \kw{setmap} 
	% \bigcup\limits_{l \in \kw{dfs}(\trace, c, D) \land l = \event_1 :: l'}
		\left(\efun l \to ( \emap 
		(\efun  \event \to \pi_1(\event)^{\pi_2(\event)})
	(\efilter 
		(\efun \event \to  \event \in \eventset^{\asn}) ~ l) \right)
	~ S,
$$
%
where $S=(\kw{setfilter} ~(\efun l \to l = [\event_1, \cdots, \event_2]) ~ (\kw{dfs} \eapp \trace \eapp c \eapp  D))$.
\\
Then, by definition of $\kw{setmap}$, we know $l$ is an output of
\\
$\left(\efun l \to ( \emap 
		(\efun  \event \to \pi_1(\event)^{\pi_2(\event)})
	(\efilter 
		(\efun \event \to  \event \in \eventset^{\asn}) ~ l) \right)$.
\\
Then we know there exists a preimage
$l_e \in S $
for $l$ such that 
$$
\emap (\efun  \event \to \pi_1(\event)^{\pi_2(\event)}) 
(\efilter (\efun \event \to  \event \in \eventset^{\asn}) ~ l_e) 
= l.
$$
 %
Since $l_e \in (\kw{setfilter} ~(\efun l \to l = [\event_1, \cdots, \event_2]) ~ (\kw{dfs} \eapp \trace \eapp c \eapp  D))$,
\\
by the $\kw{setfilter}$ function,
we know only the lists of events in $(\kw{dfs} \eapp \trace \eapp c \eapp  D)$ having the form
$ [\event_1, \cdots, \event_2] $ are preserved in $S$, i.e.,
\[
	\forall l \in (\kw{setfilter} ~(\efun l \to l = [\event_1, \cdots, \event_2]) ~ \kw{dfs}(\trace, c, D))
	\st l = [\event_1, \cdots, \event_2]
\]
%
Then we know $l_e$ also has the same form, 
i.e., $l_e = [\event_1, \cdots, \event_2]$.
%
\\
Let $l_{ef} = (\efilter (\efun \event \to  \event \in \eventset^{\asn})) ~ l_e$, 
by $\event_1, \event_2 \in \eventset^{\asn}$, 
we know $\event_1$ and $\event_2$ are preserved in $l_{ef}$, i.e.,:
\[
	l_{ef} =[\event_1, \cdots, \event_2]
\]
%
Then, by applying the function
$\emap (\efun  \event \to \pi_1(\event)^{\pi_2(\event)})$ to 
$l_{ef}$, we have $l$ as follows:
\[
	[\pi_1(\event_1)^{\pi_2(\event_1)}, \cdots, \pi_1(\event_2)^{\pi_2(\event_2)}]
\]
%
%
This lemma is proved.
\end{proof}
%
\begin{lem}[Flow Search Algorithm ($\mathcal{A}$) Inversion 2]
\label{lem:inv_alg2}
For every $\event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom , c \in \cdom$, we have either one of the two following cases:
\begin{enumerate}
  \item $\mathcal{A}(\event_1, \event_2,  [\event_1; \event_2], c, D) = 
  \left\{[\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}] \right \}$ 
  and $\eventdep^{val}(\event_1, \event_2, [\event_1; \event_2], c, D)$.
  \item  $\mathcal{A}(\event_1, \event_2, [\event_1; \event_2], c, D) = \{\}$ 
  and $\neg \eventdep^{val}(\event_1, \event_2, [\event_1; \event_2] c, D)$;
\end{enumerate}
\end{lem}
% \wq{ Good! I just realize this lemma is only used for case 4 of 5.3.}
%\jl{Yes!}
\begin{proof}
By definition of $A$, we know:
%
\[
	\begin{array}{l}
	\mathcal{A}(\event_1, \event_2, [\event_1; \event_2], c, D)
	= 
	\kw{setmap} ~
	% \bigcup\limits_{l \in \kw{dfs}(\trace, c, D) \land l = \event_1 :: l'}
	\\ \qquad \qquad
	\left(\efun l \to ( \emap 
		(\efun  \event \to \pi_1(\event)^{\pi_2(\event)})
	(\efilter 
		(\efun \event \to  \event \in \eventset^{\asn}) ~ l) \right)
	\\ \qquad \qquad
	(\kw{setfilter} ~
		(\efun l \to l = [\event_1, \cdots, \event_2]) ~ 
		% \left(\left\{[\event_2]\right\} \cup \left\{ \event_1 \stackrel{[\event_1; \event_2]}{\uplus} [\event_2] \right\} \right))
		\left(\left\{[\event_2]\right\} \cup \left(  {\uplus} \eapp \event_1 \eapp {[\event_1; \event_2]} \eapp [\event_2] \right) \right))
	\end{array}
\]
by definition of $ {\uplus} \eapp \event_1 \eapp {[\event_1; \event_2]} \eapp [\event_2]  $, we know 
\[
	\begin{array}{l}
	% \event_1 \stackrel{[\event_1; \event_2]}{\uplus} [\event_2]
	{\uplus} \eapp \event_1 \eapp {[\event_1; \event_2]} \eapp [\event_2] 
	=   
	\\ \quad \qquad 	
	\ecase \eventdep^{val}(\event_1, \event_2, [\event_1; \event_2], c, D)
	\to \left\{ [\event_1, \event_2] \right\}
	\\ \quad \qquad 	
	\ecase \_
	\to \left\{ \right\}
\end{array}
\]
%
By simplification of the $\kw{setfilter}$, $\emap$, $\efilter$ and $\kw{setmap}$ functions, we know
\\
in the case of $\eventdep^{val}(\event_1, \event_2, [\event_1; \event_2], c, D)$:
% \\
$\mathcal{A}(\event_1, \event_2, [\event_1; \event_2], c, D) = 
  \left\{[\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}] \right \}$
\\
(1) is proved.
\\
And in the case of $\neg \eventdep^{val}(\event_1, \event_2, [\event_1; \event_2], c, D)$: 
% \\
$\mathcal{A}(\event_1, \event_2, \cdot  \event_1 \tracecat [\event_2], c, D) = 
  \left\{ \right \}$
\\
(2) is proved.
\end{proof}
%
%
% \begin{lem}[\todo{Assignment Evaluation Inversion}].
% 	\label{lem:inv_eval_asn}
% 	\[
% 	\begin{array}{l}
% 		\forall x \in \lvar_c, \kw{V_{ptl}} \in \subseteq \lvar_c \expr \st 
% 		\exists \trace, \trace' \in \mathcal{T} \st 
% 		\\ \quad
% 		\forall z \in \lvar_c \setminus (\{x\} \cup \kw{V_{ptl}}) \st 
% 		\env(\trace) z = \env(\trace') z 
% 		\\ \quad \land
% 		\forall \event \in \trace, \event' \in \trace' \st 
% 		\pi_1(\event) \in \kw{V_{ptl}} \land \diff(\event, \event') 
% 		\\ \quad
% 		\implies 
% 		\neg \eventdep^{val}(\event, \event_y, \trace[\event:\event_y] ) 
% 		\implies
% 		\config{\trace, [\assign{y}{\expr}]{}^l;c'} \rightarrow^{asn} \config{\trace\cdot \event_y, c'}
% 		\\ \quad
% 		\implies 
% 		\config{\trace', [\assign{y}{\expr}]{}^l;c'} \rightarrow^{asn} \config{\trace'\cdot \event_y',c'}
% 		\land \diff(\event_y, \event_y')
% 		\implies x \in VAR(\expr)
% 	\end{array}
% 	\]
% 	\end{lem}	
%
%
% \todo{Event Dependency Transitivity}
\begin{thm}
	\label{lem:valdep_trans}
(Value Dependency Transitivity)
For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, and $\event_1, \event_2, \event_3 \in \eventset^{\asn}, \trace_{12}, \trace_{23} \in \mathcal{T}$,
if $\eventdep^{val}(\event_1, \event_2, \trace_{12}, c, D)$
and $\eventdep^{val}(\event_2, \event_3, \trace_{23}, c, D) $,
then $\eventdep^{val}(\event_1, \event_3, \trace_{12}\tracecat\trace_{23}, c, D)$.
  % An event $\event_2 \in \eventset^{\asn}$ is in the \emph{may-dependency} relation with another
  % event $\event_1 \in \eventset^{\asn}$ in a program ${c}$ with a hidden database $D$, denoted as $\eventdep(\event_1, \event_2, c, D)$,
  % if and only if
  \[
	  \begin{array}{l}
  \forall D \in \dbdom , c \in \cdom, \event_1, \event_2, \event_3 \in \eventset^{\asn}, \trace_{12}, \trace_{23} \in \mathcal{T} \st 
  \eventdep^{val}(\event_1, \event_2, \trace_{12}, c, D) 
  \land
  \eventdep^{val}(\event_2, \event_3, \trace_{23}, c, D) 
  \\ \quad
  \implies
  \eventdep^{val}(\event_1, \event_3, \trace_{12}\tracecat\trace_{23}, c, D)
	  \end{array}
  \]
\end{thm}
%
%
\begin{lem}(Control Dependency Transitivity)
\label{lem:ctl_trans}
For every $D \in \dbdom , c \in \cdom, \event_1, \event_2 \in \eventset^{\test}, \event_3 \in \eventset$
if $\eventdep^{\ctl}(\event_1, \event_2, c, D)$ and $\eventdep^{\ctl}(\event_2, \event_3, c, D)$,
then $\eventdep^{\ctl}(\event_1, \event_3, c, D)$.
%
\[
  \forall D \in \dbdom , c \in \cdom, \event_1, \event_2 \in \eventset^{\test}, \event_3 \in \eventset \st
  \eventdep^{\ctl}(\event_1, \event_2, c, D) 
  \land \eventdep^{\ctl}(\event_2, \event_3, c, D)
  \implies \eventdep^{\ctl}(\event_1, \event_3, c, D)
\]
\end{lem}
%
% \begin{lem}
% 	\label{lem:eventdep_trans}
% (\emph{Variable May-Dependency} Transitivity)
% 	\[
% 	\forall c \in \cdom, D \in \dbdom , \event_1, \event_2, \event_3 \in \eventset^{\asn}\st 
% 	\eventdep(\event_1, \event_2, c, D) 
% 	\land
% 	\eventdep(\event_2, \event_3, c, D) 
% 	\implies
% 	\eventdep(\event_1, \event_3, c, D)
% 	\]
%   \end{lem}
%
\begin{lem}[\emph{Variable May-Dependency} Transitivity]
	\label{lem:vardep_trans}
For every $c \in \cdom, x^i, y^j, z^l \in \lvar_c$, 
if $\vardep(x^i, y^j, c)$ and 
$\vardep(y^j, z^l, c)$, then $\vardep(x^i, z^l, c)$.
	\[
	\forall c \in \cdom, x^i, y^j, z^l \in \lvar_c \st 
	\vardep(x^i, y^j, c) 
	\land
	\vardep(y^j, z^l, c) 
	\implies
	\vardep(x^i, z^l, c)
	\]
  \end{lem}
  %
\begin{lem}[While Loop Inversion]
\label{lem:inv_while}
For every $\trace, \trace' \in \mathcal{T}, c, c_1, c_2 \in \cdom$ 
if $ \config{c, \trace} \rightarrow^* \config{c_1; c_2, \trace'}$ and 
$c_1 \in_c c_2$, 
then there must exist a $\ewhile$ command in $c_2$ and $c_1$ must shows up in the body of that $\ewhile$ command,
 i.e., $\exists l \in \mathbb{N}, b \in \mathcal{B}, c_w \in \cdom \st 
(\ewhile [b]^l \edo c_w) \in_c c_2 \land c_1 \in_c c_w$.
%
\[
\begin{array}{l}
\forall \trace, \trace' \in \mathcal{T}, c, c_1, c_2 \in \cdom \st
	\\ \quad
	\config{c, \trace} \rightarrow^* \config{c_1; c_2, \trace'}
	\implies
	c_1 \in_c c_2
	\implies
	\exists l \in \mathbb{N}, b \in \mathcal{B}, c_w \in \cdom \st 
	(\ewhile [b]^l \edo c_w) \in_c c_2 \land c_1 \in_c c_w
\end{array}
\]
\end{lem}
%
