\begin{lem}[Arithmetic Inversion].
\label{lem:inv_a}
\[
	\forall x \in \lvar, \expr \st 
	\Big( \exists \trace, \trace' \in \mathcal{T} \st \forall z \in \lvar / \{x\} \st 
	\env(\trace) z = \env(\trace') z \st 
	\config{\trace, \expr} \aarrow v \land \config{\trace', \expr} \aarrow v' \land v \neq v'
	\implies x \in VAR(\expr)\Big)
\]
\end{lem}
%
\begin{lem}[Assignment Evaluation Inversion].
\label{lem:inv_eval_asn}
\[
\begin{array}{l}
	\forall x \in \lvar_c, \kw{V_{ptl}} \in \subseteq \lvar_c \expr \st 
	\exists \trace, \trace' \in \mathcal{T} \st 
	\\ \quad
	\forall z \in \lvar_c \setminus (\{x\} \cup \kw{V_{ptl}}) \st 
	\env(\trace) z = \env(\trace') z 
	\\ \quad \land
	\forall \event \in \trace, \event' \in \trace' \st 
	\pi_1(\event) \in \kw{V_{ptl}} \land \diff(\event, \event') 
	\\ \quad
	\implies 
	\neg \eventdep^{val}(\event, \event_y, \trace[\event:\event_y] ) 
	\implies
	\config{\trace, [\assign{y}{\expr}]{}^l;c'} \rightarrow^{asn} \config{\trace\cdot \event_y, c'}
	\\ \quad
	\implies 
	\config{\trace', [\assign{y}{\expr}]{}^l;c'} \rightarrow^{asn} \config{\trace'\cdot \event_y',c'}
	\land \diff(\event_y, \event_y')
	\implies x \in VAR(\expr)
\end{array}
\]
\end{lem}
%
\begin{lem}[Boolean Inversion]
\label{lem:inv_b}
\[
	\forall x \in \lvar, \bexpr \st 
	\Big( \exists \trace, \trace' \in \mathcal{T} \st \forall z \in \lvar / \{x\} \st
	\env(\trace) z = \env(\trace') z \st 
	\config{\trace, \bexpr} \barrow v \land \config{\trace', \bexpr} \barrow v' \land v \neq v'
	\implies x \in VAR(\bexpr) \Big)
\]
\end{lem}
%
\begin{lem}[Query Inversion]
\label{lem:inv_q}
\[
	\forall x \in \lvar, \qexpr \st \exists \trace, \trace' \in \mathcal{T} \forall z \in \lvar / \{x\} \st
	\env(\trace) z = \env(\trace') z \st 
	\config{\trace, \qexpr} \qarrow \qval \land \config{\trace', \qexpr} \qarrow \qval' 
	\land v \neq_{q} \qval'
	\implies x \in VAR(\qexpr) \Big)
\]
\end{lem}
%
% \begin{lem}[Assignment Inversion].
% \label{lem:inv_a}
% \[
% 	\forall x \in \lvar, \expr \st 
% 	\Big( \exists \trace, \trace' \st \forall z^i \in \lvar / \{x^l\} \st 
% 	\env(\trace) z = \env(\trace') z \st 
% 	\config{\trace, \expr} \aarrow v \land \config{\trace', \expr} \aarrow v' \land v \neq v'
% 	\implies x \in VAR(\expr) \land x^l \in \Big)
% \]
% \end{lem}
%
\begin{lem}[Assignment Event -> (Assignment / Query Command)]
\label{lem:inv_asn}
\[
\begin{array}{l}
	\forall \trace_0 \in \mathcal{T}, c \st \config{\trace_0, c} \rightarrow^* \config{\trace_0\trace_1, \eskip}
	\land \exists \event = (x, l, n, v) \in \eventset^{\asn} \st
	\land \event \eventin \trace_1 \\
	\implies 
	\big( 
		\exists \trace_1' \in \mathcal{T}, \expr, c' \st
		\config{\trace_0, c} \rightarrow^* \config{\trace_0 \cdot \trace', [\assign{x}{\expr}]^l;c'} \rightarrow^{assn}
		\config{\trace_0\trace_1'\cdot \event \cdot, c'} \rightarrow^{*}
		\config{\trace_0\trace_1, \eskip}
	\big)
	\\ \qquad \lor
	\big( 
		\exists \trace_1' \in \mathcal{T}, \qexpr, c' \st
		\config{\trace_0, c} \rightarrow^* \config{\trace_0\trace_1, [\assign{x}{\query(\qexpr)}]^l;c'} \rightarrow^{query}
		\config{\trace_0\trace_1' \cdot \event \cdot, c'} \rightarrow^{*}
		\config{\trace_0\trace_1, \eskip}
	\big)
\end{array}
\]
%
\end{lem}
%
\begin{lem}[Testing Event -> (If / While command)]
\label{lem:inv_test}
\[
\begin{array}{l}
	\forall c, \trace_0 \in \mathcal{T}, \st \config{\trace_0, c} \rightarrow^* \config{\trace_0\trace_1, \eskip}
	\land \exists \event = (x, l, n, v) \land \event \eventin \trace_1 \\
	\implies 
	\big( 
		\exists \trace_1' \in \mathcal{T}, \bexpr, c', c_1, c_2, c'' \st
		\config{\trace_0, c} \rightarrow^* \config{\trace_0\trace_1, \eif ([b]^l, c_1, c_2);c'} \rightarrow^{if-b}
		\config{\trace_0\trace_1'\cdot \event \cdot, c''} \rightarrow^{*}
		\config{\trace_0\trace_1, \eskip} 
	\big)
	\\ \qquad \lor
	\big( 
		\exists \trace_1' \in \mathcal{T}, \bexpr, c', c_w, c'' \st
		\config{\trace_0, c} \rightarrow^* \config{\trace_0 \trace_1, \ewhile([b]^l, c_w);c'} \rightarrow^{while-b}
		\config{\trace_0\trace_1'\cdot \event \cdot, c''} \rightarrow^{*}
		\config{\trace_0\trace_1, \eskip}
	\big)
\end{array}
\]
\end{lem}

% \begin{lem}[Control Dependency -> Exists Testing Event]
% \label{lem:inv_ctltotest}
% \[
% 	\forall \event_1, \event_2 \in \eventset, c \st 
% 	\eventdep^{\ctl}(\event_1, \event_2, c, D)
% 	\implies
% 	\exists \event_b \in \eventset^{\test}, \trace_2 \in \mathcal{T} \st \eventdep^{val}(\event_1, \event_b, \trace_2, c, D)
% \]
% \end{lem}

% \begin{lem}[Control Dependency -> Event 2 in the Body Command of the Testing Event]
% \label{lem:inv_ctltoevent2}
% \[
% \begin{array}{l}
% 	\forall \event_1, \event_2 = (x_2, l_2, n_2, v_2) \in \eventset, c \st 
% 	\eventdep^{\ctl}(\event_1, \event_2, c, D)\\
% 	\implies
% 	\exists \event_b = (b, l, n, v) \in \eventset^{\test}, \expr_2 \st \eventdep^{val}(\event_1, \event_b, c, D)\\
% 	\quad \land \Big(
% 	\exists c_t, c_f \st (\eif ([b]{}^l, c_t, c_f)) \in_{c} c \land ([\assign{x_2}{\expr_2}]^{l_2}) \in_c c_t;c_f \\
% 	\qquad \lor\exists c_w \st (\ewhile [b]{}^l \edo c_w) \in_{c} c \land ([\assign{x_2}{\expr_2}]^{l_2}) \in_c c_w
% 	\Big)
% \end{array}
% \]
% \end{lem}

\begin{lem}[Liveness Inversion]
\label{lem:inv_live}
\[
	\forall c, \trace, \trace' \in \mathcal{T} \st
	\config{c, \trace} \xrightarrow{}^* \config{c', \trace'}
	\implies
	\forall x^l \in \lvar_c \st \llabel(\trace') x = l \implies (x^l \in \live^{\entry_{c'}}(c))
\]
\end{lem}

\begin{lem}[$\eventdep^{\ctl}$ Transitivity]
\label{lem:ctl_trans}
\[
  \forall \event_1, \event_2 \in \eventset^{\test}, \event_3 \in \eventset \st
  \eventdep^{\ctl}(\event_1, \event_2) 
  \land \eventdep^{\ctl}(\event_2, \event_3, c, D)
  \implies \eventdep^{\ctl}(\event_1, \event_3, c, D)
\]
\end{lem}
%
%
%
\begin{lem}[Flow Search Algorithm ($\mathcal{A}$) Inversion 1]
\label{lem:inv_alg1}
\[
\begin{array}{l}
  \forall \event_1, \event_2 \in \eventset^{\asn}, \trace \in \mathcal{T}, D \in \dbdom , c \in \cdom \st
  \\ \quad 
  \mathcal{A}(\event_1, \event_2, \trace, c, D) \neq \emptyset
  \implies
  \forall l \in \mathcal{A}(\event_1, \event_2, \trace, c, D) \st l = \pi_1(\event_1)^{\pi_2(\event_1)} :: l' ++ [\pi_1(\event_2)^{\pi_2(\event_2)}]
\end{array}
\]
\end{lem}
%
\begin{proof}.
\\
Taking arbitrary $\event_1, \event_2 \in \eventset^{\asn}, \trace \in \mathcal{T}, D \in \dbdom , c \in \cdom$,
\\
by definition of $\mathcal{A}$, 
the $(\kw{setfilter} ~(\efun l \to l = \event_1 :: l' ++ [\event_2]) ~ \kw{dfs}(\trace, c, D))$ operation 
will only preserve the lists of events from results of $\kw{dfs}(\trace, c, D)$ satisfying:
\[
	l = \event_1 :: l' ++ [\event_2] 
\]
%
Then we know either:
\\
$(\kw{setfilter} ~(\efun l \to l = \event_1 :: l' ++ [\event_2]) ~ \kw{dfs}(\trace, c, D)) = \emptyset$, or 
\\
$(\kw{setfilter} ~(\efun l \to l = \event_1 :: l' ++ [\event_2]) ~ \kw{dfs}(\trace, c, D)) \neq \emptyset \implies$ 
%
\[
\forall l_e \in (\kw{setfilter} ~(\efun l \to l = \event_1 :: l' ++ [\event_2]) ~ \kw{dfs}(\trace, c, D))
\st l_e = \event_1 :: l_e' ++ [\event_2] 
\]
%
In case of  $(\kw{setfilter} ~(\efun l \to l = \event_1 :: l' ++ [\event_2]) ~ \kw{dfs}(\trace, c, D)) = \emptyset$, 
we have 
\[
	\mathcal{A}(\event_1, \event_2, \trace, c, D) = \emptyset
\]
, which is contradict to the hypothesis and the conclusion is then vacuously true.
\\
In case of $(\kw{setfilter} ~(\efun l \to l = \event_1 :: l' ++ [\event_2]) ~ \kw{dfs}(\trace, c, D)) \neq \emptyset$,
\\
by $\event_1, \event_2 \in \eventset^{\asn}$, 
for every 
$l_e = \event_1 :: l_e' ++ [\event_2] 
\in (\kw{setfilter} ~ (\efun l \to l = \event_1 :: l' ++ [\event_2]) ~ \kw{dfs}(\trace, c, D))$
\\
the $(\efilter (\efun \event \to  \event \in \eventset^{\asn})) $ function preserves $\event_1$ and $\event_2$ in $l_e$.
\\
Then, by applying the function
$\emap (\efun  \event \to \pi_1(\event)^{\pi_2(\event)})$ to every filtered $l_e$, it is transformed into $l$ as follows:
\[
	l = \pi_1(\event_1)^{\pi_2(\event_1)} :: l' ++ [\pi_1(\event_2)^{\pi_2(\event_2)}]
\]
%
Then we know $\mathcal{A}(\event_1, \event_2, \trace, c, D) \neq \emptyset$ and every $l \in \mathcal{A}(\event_1, \event_2, \trace, c, D)$ is a transformed and filtered $l_e$ satisfying:
\[
	l = \pi_1(\event_1)^{\pi_2(\event_1)} :: l' ++ [\pi_1(\event_2)^{\pi_2(\event_2)}]
\]
%
This lemma is proved.
\end{proof}
%
\begin{lem}[Flow Search Algorithm ($\mathcal{A}$) Inversion 2]
\label{lem:inv_alg2}
For every $\event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom , c \in \cdom$, we have either one of the two following cases:
\begin{enumerate}
  \item $\mathcal{A}(\event_1, \event_2, \event_1 \cdot \event_2, c, D) = 
  \left\{[\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}] \right \}$ 
  and $\eventdep^{val}(\event_1, \event_2, \event_1 \cdot \event_2, c)$.
  \item  $\mathcal{A}(\event_1, \event_2, \event_1 \cdot \event_2, c, D) = \{\}$ 
  and $\neg \eventdep^{val}(\event_1, \event_2, \event_1 \cdot \event_2, c)$;
\end{enumerate}
\end{lem}
\begin{proof}
By definition of $A$, we know:
%
\[
	\begin{array}{l}
	\mathcal{A}(\event_1, \event_2, \event_1 \cdot \event_2, c, D)
	= 
	\kw{setmap} ~
	% \bigcup\limits_{l \in \kw{dfs}(\trace, c, D) \land l = \event_1 :: l'}
	\\ \qquad \qquad
	\left(\emap 
		(\efun  \event \to \pi_1(\event)^{\pi_2(\event)})	
	~
	(\efilter 
		(\efun \event \to  \event \in \eventset^{\asn}) ~ l) \right)
	\\ \qquad \qquad
	(\kw{setfilter} ~
		(\efun l \to l = \event_1 :: l' ++ [\event_2]) ~ 
		\left\{ \event_1 \stackrel{\trace}{\uplus} [\event_2] \right\})
	\end{array}
\]
by definition of $ \event_1 \stackrel{\trace}{\uplus} [\event_2] $, we know 
\[
	\begin{array}{l}
	\event_1 \stackrel{\trace}{\uplus} [\event_2]
	=   
	\\ \quad \qquad 	
	\ecase \eventdep^{val}(\event, \event', \event_1 \cdot \event_2, c, D)
	\to \left\{ [\event_1, \event_2] \right\}
	\\ \quad \qquad 	
	\ecase \neg \eventdep^{val}(\event, \event', \event_1 \cdot \event_2, c, D)
	\to \left\{ \right\}
\end{array}
\]
%
Then we know in the case of $\eventdep^{val}(\event, \event', \event_1 \cdot \event_2, c, D)$:
% \\
$\mathcal{A}(\event_1, \event_2, \event_1 \cdot \event_2, c, D) = 
  \left\{[\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}] \right \}$
\\
(1) is proved.
\\
And in the case of $\neg \eventdep^{val}(\event, \event', \event_1 \cdot \event_2, c, D)$: 
% \\
$\mathcal{A}(\event_1, \event_2, \event_1 \cdot \event_2, c, D) = 
  \left\{ \right \}$
\\
(2) is proved.
\end{proof}
%
%
%
