%
\subsection{Variable Dependency Soundness}
% \begin{thm}[$\vardep$ Soudness]
% \label{thm:algvardep_sound}
% Given a program ${c}$, 
% \[
% \begin{array}{l}
%   \forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}}.
%   \vardep({x}_1^{l_1}, {x}_2^{l_2}, {c})
%   \\ \quad \implies \exists \event_1, \event_2 \in \eventset^{\asn}, \trace, \trace'  \in \mathcal{T}, D \in \dbdom , c \in \cdom \st
%   \\ \qquad
%  \trace = \event_1 \tracecat \trace' \cdot \event_2
%    \implies 
%   (\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
% \implies
% (\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
% \implies
%   \mathcal{A}(\event_1, \event_2, \trace, c, D) \neq \emptyset
% \end{array}
% \]
% \end{thm}
% \begin{proof}
% Proved by unfolding the $\vardep$ and apply Theorem.~\ref{thm:algeventdep_sound}.
% \end{proof}
%
% \begin{thm}[$\vardep$ implies $\flowsto$]
% \label{thm:flowstovardep_sound}
% Given a program ${c}$, 
% \[
% \begin{array}{l}
%   \forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}}.
%   \vardep({x}_1^{l_1}, {x}_2^{l_2}, {c})
%   \\ \quad \implies
%   \Big( \exists n \in \mathbb{N}, z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st n \geq 0 \land
%   \flowsto(x_1^{l_1}, z_1^{r_1}, c) 
%   \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
% \end{array}
% \]
% \end{thm}
% \begin{proof}
% Proved by applying Theorem.~\ref{thm:algvardep_sound} and Correctness of $\mathcal{A}$ in Toeorem.~\ref{thm:alg_correct}.
% \end{proof}

\subsection{$\THESYSTEM$ Soundness}
{
  \begin{thm}[Soundness of the \THESYSTEM].
  Given a program $\ssa{c}$, we have:
  %
  \[
  \progA(\ssa{c}) \geq A(\ssa{c}).
  \]
  \end{thm}
}

\wq{To do: Add $\THESYSTEM$, a data flow analysis algorithm to scan the program and give a graph.}

\jl{In the $\THESYSTEM$ section, Section~\ref{sec:adpfun}?}

{\THESYSTEM} consists of three phases: 
\begin{enumerate}
    \item An algorithm to generate a precise data control flow graph
    \item An algorithm to perform a Reachability number analysis to calculate the weight of each node in the graph generated in phase 1.
    \item An algorithm to find the appropriate path in the weighted data control flow graph
\end{enumerate}

To be precise, we show the details. 
\subsubsection{Phase 1, precise data control flow graph}
There are 3 steps to generate the graph in this phase.
\begin{enumerate}
\item Generation of control flow graph
    \item Reaching definition analysis
   \item  data-control flow analysis
\end{enumerate}

\paragraph{Generate CFG}
 Define $\mathsf{init}$: Command -> label, which returns the initial label of the statement. 
 \[
 \begin{array}{ll}
    init([x := e]^{l})  & = l  \\
     init([x := q(e)]^{l})  & = l \\
     init([skip]^{l})  & = l \\
     init([if [b]^l then C_1 else C_2]^{l})  & = l \\
     init([while [b]^l do C]^{l})  & = l \\
     init(C_1 ; C_2)  & = init(C_1) \\
 \end{array}
 \]
  Define $\mathsf{final}$: Command -> Powerset(label), which returns the final labels of the statement. 
 \[
 \begin{array}{ll}
    final([x := e]^{l})  & = \{l\}  \\
     final([x := q(e)]^{l})  & = \{l\}  \\
     final([skip]^{l})  & = \{l\} \\
     final([if [b]^l then C_1 else C_2]^{l})  & = final(C_1) \cup final(C_2) \\
     final([while [b]^l do C]^{l})  & = \{l\} \footnote{while terminates after b evaluates to false} \\
     final(C_1 ; C_2)  & =  final(C_2) \\
 \end{array}
 \]
 Define block B to be either the command of the form of assignment, skip, or test of the form of $[b]^{l}$.\\
 Define $\mathsf{blocks}$ : command -> Powerset(Block)
 \[
 \begin{array}{ll}
    blocks([x := e]^{l})  & = \{[x := e]^{l}\}  \\
     block([x := q(e)]^{l})  & = \{[x := q(e)]^{l}\}  \\
     blocks([skip]^{l})  & = \{[skip]^{l}\} \\
     blocks([if [b]^l then C_1 else C_2]^{l})  & = {[b]^{l}} \cup blocks(C_1) \cup blocks(C_2) \\
     blocks([while [b]^l do C]^{l})  & = \{[b]^{l}\} \cup blocks(C) \\
     blocks(C_1 ; C_2)  & = blocks(C_1) \cup  blocks(C_2) \\
 \end{array}
 \]
 Define $\mathsf{labels}$ to get the labels of blocks.
 \[
   labels(C) = \{l | [B]^{l} \in blocks(C) \}
 \]  

The control flow graph is generated by edges between labels. Define $\mathsf{flow}$: command -> P (label $\times$ label ).

\[
 \begin{array}{ll}
    flow([x := e]^{l})  & = \emptyset  \\
     flow([x := q(e)]^{l})  & = \emptyset  \\
     flow([skip]^{l})  & = \emptyset \\
     flow([if [b]^l then C_1 else C_2]^{l})  & =  flow(C_1) \cup flow(C_2)\cup \{(l, init(C_1)) , (l, init(C_2)) \} \\
     flow([while [b]^l do C]^{l})  & =  flow(C) \cup \{(l, init(C)) \} \cup \{(l', l)| l' \in final(C) \} \\
     flow(C_1 ; C_2)  & = flow(C_1) \cup  flow(C_2) \cup \{ (l,init(C_2)) | l \in final(C_1) \} \\
 \end{array}
 \]
 
 \paragraph{Reaching definition analysis}
 Set $?$ to be undefined, $label^{?}$ is label $\cup \{?\}$.\\
 Define $\mathsf{kill}$: blocks -> Powerset(Var $\times$ $label^l$, which produces the set of labelled variables of assignment destroyed by the block.\\
 Define $\mathsf{gen}$: blocks->Powerset(Var $\times$ $label^l$, which generates the set of labelled variables generated by the block.\\
 Define $defs(x)(C)$: Var -> Set of labels, gives all the labels where assigns value to variable x in the target program C.
  \[
 \begin{array}{ll}
    kill([x := e]^{l})  & = \{ (x, ?) \} \cup \{ (x, l') | l' \in defs(x) \} \\
     kill([x := q(e)]^{l})  & = \{ (x, ?) \} \cup \{ (x, l') | l' \in defs(x) \}  \\
     kill([skip]^{l})  & = \emptyset \\
     kill([ [b]^l ]^{l})  & =  \emptyset \\
      gen([x := e]^{l})  & = \{ (x, l) \}  \\
     gen([x := q(e)]^{l})  & = \{ (x, l) \}  \\
     gen([skip]^{l})  & = \emptyset \\
     gen([ [b]^l ]^{l})  & =  \emptyset 
 \end{array}
 \]
 Define $in(l)$, $out(l)$: label -> (var $\times$ $label^l$) for the entry point and exit point of the node $l$ in the control flow graph.
 \[
 \begin{array}{lll}
    in(l)  & = \{ (x, ?) | x is assigned in C  \} & l = init(C)\\
    & \cup \{ out(l')|  | (l',l) \in flow(C) \} & ow \\
     out(l)  & =  gen(B^{l}) \cup \{ in(l) \setminus kill(B^l)  \} & B^l \in blocks(C)   
 \end{array}
 \]
 
The Reaching definition is calculated by the Worklist algorithm as below.
\begin{enumerate}
    \item initial in[l]=out[l]=$\emptyset$
    \item initial in[entry label] = $\emptyset$
    \item initialize a work queue, contains all the blocks in C
    \item while |W| != 0 \\
         pop l in W\\
          old = out[l]\\
          in(l) =  out(l') where (l',l) in flow(C)\\
           out(l) = gen($b^l$) $\cup$ (in(l) - kill($b^l$) ) where $b^l$ in block(C)   \\
          if (old != out(l)) W= W $\cup$ \{l'| (l,l') in flow(C)\}\\
          end while
\end{enumerate}

 \paragraph{control-data flow graph}
 We build this graph by using the results of Reaching definition analysis, to be specific, in(l) for every label. 

\subsubsection{Phase 2, reachability number analysis}

\subsubsection{Phase 3, path finding algorithm in weighted graph (graph in phase 1 with weights predicted in phase 2) }