%
\subsection{Variable Dependency Soundness}
% \begin{thm}[$\vardep$ Soudness]
% \label{thm:algvardep_sound}
% Given a program ${c}$, 
% \[
% \begin{array}{l}
%   \forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}}.
%   \vardep({x}_1^{l_1}, {x}_2^{l_2}, {c})
%   \\ \quad \implies \exists \event_1, \event_2 \in \eventset^{\asn}, \trace, \trace'  \in \mathcal{T}, D \in \dbdom , c \in \cdom \st
%   \\ \qquad
%  \trace = \event_1 \tracecat \trace' \cdot \event_2
%    \implies 
%   (\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
% \implies
% (\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
% \implies
%   \mathcal{A}(\event_1, \event_2, \trace, c, D) \neq \emptyset
% \end{array}
% \]
% \end{thm}
% \begin{proof}
% Proved by unfolding the $\vardep$ and apply Theorem.~\ref{thm:algeventdep_sound}.
% \end{proof}
%
% \begin{thm}[$\vardep$ implies $\flowsto$]
% \label{thm:flowstovardep_sound}
% Given a program ${c}$, 
% \[
% \begin{array}{l}
%   \forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}}.
%   \vardep({x}_1^{l_1}, {x}_2^{l_2}, {c})
%   \\ \quad \implies
%   \Big( \exists n \in \mathbb{N}, z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st n \geq 0 \land
%   \flowsto(x_1^{l_1}, z_1^{r_1}, c) 
%   \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
% \end{array}
% \]
% \end{thm}
% \begin{proof}
% Proved by applying Theorem.~\ref{thm:algvardep_sound} and Correctness of $\mathcal{A}$ in Toeorem.~\ref{thm:alg_correct}.
% \end{proof}

\subsection{$\THESYSTEM$ Soundness}
{
  \begin{thm}[Soundness of the \THESYSTEM].
  Given a program $\ssa{c}$, we have:
  %
  \[
  \progA(\ssa{c}) \geq A(\ssa{c}).
  \]
  \end{thm}
}

\wq{To do: Add $\THESYSTEM$, a data flow analysis algorithm to scan the program and give a graph.}
\jl{Adding into the $\THESYSTEM$ section.}
{\THESYSTEM} consists of three phases: 
\begin{enumerate}
    \item An algorithm to generate a precise data control flow graph
    \item An algorithm to perform a Reachability number analysis to calculate the weight of each node in the graph generated in phase 1.
    \item An algorithm to find the appropriate path in the weighted data control flow graph
\end{enumerate}

To be precise, we show the details. 
\subsubsection{Phase 1, precise data control flow graph}
There are 3 steps to generate the graph in this phase.
\begin{enumerate}
\item Generation of control flow graph
    \item Reaching definition analysis
   \item  data-control flow analysis
\end{enumerate}

\paragraph{Generate CFG}
 Define $\mathsf{init}$: Command -> label, which returns the initial label of the statement. 
 \[
 \begin{array}{ll}
    init([x := e]^{l})  & = l  \\
     init([x := q(e)]^{l})  & = l \\
     init([skip]^{l})  & = l \\
     init([if [b]^l then C_1 else C_2]^{l})  & = l \\
     init([while [b]^l do C]^{l})  & = l \\
     init(C_1 ; C_2)  & = init(C_1) \\
 \end{array}
 \]
  Define $\mathsf{final}$: Command -> Powerset(label), which returns the final labels of the statement. 
 \[
 \begin{array}{ll}
    final([x := e]^{l})  & = \{l\}  \\
     final([x := q(e)]^{l})  & = \{l\}  \\
     final([skip]^{l})  & = \{l\} \\
     final([if [b]^l then C_1 else C_2]^{l})  & = final(C_1) \cup final(C_2) \\
     final([while [b]^l do C]^{l})  & = \{l\} \footnote{while terminates after b evaluates to false} \\
     final(C_1 ; C_2)  & =  final(C_2) \\
 \end{array}
 \]
 Define block B to be either the command of the form of assignment, skip, or test of the form of $[b]^{l}$.\\
 Define $\mathsf{blocks}$ : command -> Powerset(Block)
 \[
 \begin{array}{ll}
    blocks([x := e]^{l})  & = \{[x := e]^{l}\}  \\
     block([x := q(e)]^{l})  & = \{[x := q(e)]^{l}\}  \\
     blocks([skip]^{l})  & = \{[skip]^{l}\} \\
     blocks([if [b]^l then C_1 else C_2]^{l})  & = {[b]^{l}} \cup blocks(C_1) \cup blocks(C_2) \\
     blocks([while [b]^l do C]^{l})  & = \{[b]^{l}\} \cup blocks(C) \\
     blocks(C_1 ; C_2)  & = blocks(C_1) \cup  blocks(C_2) \\
 \end{array}
 \]
 Define $\mathsf{labels}$ to get the labels of blocks.
 \[
   labels(C) = \{l | [B]^{l} \in blocks(C) \}
 \]  

The control flow graph is generated by edges between labels. Define $\mathsf{flow}$: command -> P (label $\times$ label ).

\[
 \begin{array}{ll}
    flow([x := e]^{l})  & = \emptyset  \\
     flow([x := q(e)]^{l})  & = \emptyset  \\
     flow([skip]^{l})  & = \emptyset \\
     flow([if [b]^l then C_1 else C_2]^{l})  & =  flow(C_1) \cup flow(C_2)\cup \{(l, init(C_1)) , (l, init(C_2)) \} \\
     flow([while [b]^l do C]^{l})  & =  flow(C) \cup \{(l, init(C)) \} \cup \{(l', l)| l' \in final(C) \} \\
     flow(C_1 ; C_2)  & = flow(C_1) \cup  flow(C_2) \cup \{ (l,init(C_2)) | l \in final(C_1) \} \\
 \end{array}
 \]
 
 \paragraph{Reaching definition analysis}

\subsubsection{Phase 2, reachability number analysis}

\subsubsection{Phase 3, path finding algorithm in weighted graph (graph in phase 1 with weights predicted in phase 2) }