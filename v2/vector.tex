\[\begin{array}{lcl}
\max(\bot, \nnatbiA) & = & \nnatbiA \\
\max(\nnatbiA, \bot) & = & \nnatbiA \\
\max(\infty, \nnatbiA) & = & \infty \\
\max(\nnatbiA, \infty) & = & \infty \\
\\
%
\bot + \nnatbiA & = & \bot \\
\nnatbiA + \bot & = & \bot \\
\infty + \nnatbiA & = & \infty ~~~~ \mbox{if } \nnatbiA \neq \bot \\
\nnatbiA + \infty & = & \infty ~~~~ \mbox{if } \nnatbiA \neq \bot \\
\\
%
\bot \leq \nnatbiA \\
\nnatbiA \leq \infty
\end{array}
\]

\[\begin{array}{llll}
\mbox{Expr.} & \expr & ::= & x ~|~ \expr_1 \eapp \expr_2 ~|~ \efix f(x).\expr
 ~|~ (\expr_1, \expr_2) ~|~ \eprojl(\expr) ~|~ \eprojr(\expr) ~| \\
%
& & & \etrue ~|~ \efalse ~|~ \eif(\expr_1, \expr_2, \expr_3) ~|~
\econst ~|~ \eop(\expr)  ~|~  {\eilam \expr ~|~ \expr \eapp [] } \\
& & & ~|~  {\elet  x:q = \expr_1 \ein \expr_2 } ~|~ \enil ~|~  \econs (
      \expr_1, \expr_2) \\
& & & ~|~ { ~~~~~~~
 \bernoulli \eapp \expr ~|~ \uniform \eapp \expr_1 \eapp
      \expr_2 } \\
& & & ~|~  \mathsf{vec}(\expr_i \to \expr_i', \expr) \wq{ \expr = k} ~|~ \expr \{ \expr' \} \\\
%
\mbox{Value} & \valr & ::= & \etrue ~|~ \efalse ~|~ \econst ~|~
(\efix f(x:\type).\expr, \env) ~|~ (\valr_1, \valr_2) 
    ~|~ \enil ~|~ \econs (\valr_1, \valr_2) | \\
& & & {(\eilam \expr , \env) } ~|~  \mathsf{vec}(\valr_i \to \valr_i', \valr) \wq{ \valr = k} \\
%
\mbox{Environment} & \env & ::= & x_1 \mapsto \valr_1, \ldots, x_n \mapsto \valr_n
\end{array}\]


\[\begin{array}{llll}
\mbox{Trace} & \tr & ::= &  {(x, \env)} ~|~ \trapp{\tr_1}{\tr_2}{f}{x}{\tr_3} ~|~
{ (\trfix f(x:\type).e, \env) } ~|~ (\tr_1, \tr_2) ~|~ \trprojl(\tr) ~|\\ 
%
& & & \trprojr(\tr) ~|~ \trtrue ~|~ \trfalse ~|~ \trift(\tr_b, \tr_t)
~|~ \triff(\tr_b, \tr_f) ~|~ \trconst ~|~ \trop(\tr) \\
%
& & & \trnil ~|~ \trcons (\tr_1, \tr_2) ~|~ \triapp{\tr_1}{\tr_2} ~|~
       {(\eilam \expr, \env)} \\
& & & ~|~  \mathsf{vec}(\tr_i, \valr) \wq{ \valr = k} \\
\end{array}\]



\begin{figure}
\begin{mathpar}
   { \inferrule{ }{\env, x \bigstep \env(x), (x, \env ) }  }
  %
  \and
  %
  \inferrule{ }{\env, \econst \bigstep \econst, \trconst}
  %
  \and
  %
  \inferrule{ }{\env, \etrue \bigstep \etrue, \trtrue}
  %
  \and
  %
  \inferrule{ }{\env, \efalse \bigstep \efalse, \trfalse}
  %
  \and
  { \inferrule{  \env, \expr \bigstep \econst, \tr }{\env, \bernoulli \eapp \expr \bigstep \econst,
      \bernoulli (\tr)
    } }
  \and
 \inferrule{ \env, \expr_1 \bigstep \econst, \tr_1 \\ \env, \expr_2 \bigstep \econst, \tr_2  }{\env, \uniform \eapp \expr_1 \eapp
      \expr_2\bigstep \econst, \uniform(\tr_1,\tr_2)  } 
  \and
  %
  { \inferrule{
  }{
    \env, \efix f(x:\type). \expr \bigstep (\efix f(:\type).\expr, \env),
    (\trfix f(x:\type).\expr, \env)
  }
}
  %
  \and
  %
  \inferrule{
    \env, \expr_1 \bigstep \valr_1, \tr_1 \\
    { \valr_1 = (\efix f(x:\type).\expr, \env')} \\\\
    \env, \expr_2 \bigstep \valr_2, \tr_2 \\
    \env'[f \mapsto \valr_1, x \mapsto \valr_2], \expr \bigstep \valr, \tr
  }{
    \env, \expr_1 \eapp \expr_2 \bigstep \valr, \trapp{\tr_1}{\tr_2}{f}{x}{\tr}
  }
  %
  \and
  %
  \inferrule{
    \env, \expr_1 \bigstep \valr_1, \tr_1 \\
    \env, \expr_2 \bigstep \valr_2, \tr_2
  }{
    \env, (\expr_1, \expr_2) \bigstep (\valr_1, \valr_2), (\tr_1, \tr_2)
  }
  %
  \and
  %
  \inferrule{
    \env, \expr \bigstep (\valr_1, \valr_2), \tr
  }{
    \env, \eprojl(\expr) \bigstep \valr_1, \trprojl(\tr)
  }
  %
  \and
  %
  \inferrule{
    \env, \expr \bigstep (\valr_1, \valr_2), \tr
  }{
    \env, \eprojr(\expr) \bigstep \valr_2, \trprojr(\tr)
  }
  %
  \and
  %
  \inferrule{
    \env, \expr \bigstep \etrue, \tr \\
    \env, \expr_1 \bigstep \valr, \tr_1
  }{
    \env, \eif(\expr, \expr_1, \expr_2) \bigstep \valr, \trift(\tr, \tr_1)
  }
  %
  \and
  %
  \inferrule{
    \env, \expr \bigstep \efalse, \tr \\
    \env, \expr_2 \bigstep \valr, \tr_2
  }{
    \env, \eif(\expr, \expr_1, \expr_2) \bigstep \valr, \triff(\tr, \tr_2)
  }
  %
  \and
  %
  \inferrule{
    \env, \expr \bigstep \valr, \tr \\
    \eop{}(\valr) = \valr'
  }{
    \env, \eop(\expr) \bigstep \valr', \trop(\tr)
  }
%
\and
%
  \inferrule{
}
{ \env, \enil \bigstep \enil, \trnil }
%
\and
%
\inferrule{
\env, \expr_1 \bigstep \valr_1, \tr_1 \\
\env, \expr_2 \bigstep \valr_2, \tr_2
}
{ \env, \econs (\expr_1, \expr_2)  \bigstep \econs (\valr_1, \valr_2),
  \trcons(\tr_1, \tr_2)
}
%
\and
%
\inferrule{
  \env, \expr_1 \bigstep \valr_1, \tr_1 \\
  \env[x \mapsto \valr_1] , \expr_2 \bigstep \valr, \tr_2
}
{\env, \elet x;q = \expr_1 \ein \expr_2 \bigstep \valr, \trlet (x,
  \tr_1, \tr_2) }
%
\\\\
%
\inferrule
{
  \empty
}
{
  \env, \eilam \expr \bigstep (\eilam \expr, \env), (\eilam \expr , \env)
}
%
\and
%
\inferrule{
  \env, \expr \bigstep (\eilam \expr', \env'), \tr_1 \\
  \env, \expr' \bigstep \valr, \tr_2
}
{\env, \expr [] \bigstep \valr, \triapp{\tr_1}{\tr_2} }
\and
\wq {\inferrule{
 \env, \expr_i \bigstep \valr_i, \tr_i \\
 \env, \expr_i' \bigstep \valr_i', \tr_i'\\
 \env, \expr \bigstep \valr, \tr
}
{\env, \mathsf{vec}(\expr_i \to \expr_i', \expr) \bigstep \mathsf{vec}(\valr_i \to \valr_i', \valr), \mathsf{VEC}(\tr_i',\valr) }
}
%
\and
%
\wq{
\inferrule
{\env, \expr \bigstep \mathsf{vec}(\valr_i \to \valr_i', \valr), \tr \\
\env, \expr' \bigstep \valr', \tr' \\ 
\valr' = \valr_i 
}
{\env, \expr \{ \expr' \} \bigstep \valr_i',  \mathsf{GET}(\tr, \tr')  }
}
\end{mathpar}
  \caption{Big-step semantics with provenance, vector}
  \label{fig:big-step-vector}
\end{figure}


\begin{figure}
  \framebox{$\adap: \mbox{Traces} \to \nat$}
  \begin{mathpar}
    \begin{array}{lcl}
      \wq { \adap( (x,\env) )} & = & 0 \\
      %
      \adap(\trapp{\tr_1}{\tr_2}{f}{x}{\tr_3}) & = &
      \adap(\tr_1) + \max (\adap(\tr_3), \adap(\tr_2) + \ddep{x}(\tr_3))\\
      %
      \wq {\adap( (\trfix f(x:\type).\expr, \env)  ) } & = & 0 \\
      %
      \adap((\tr_1, \tr_2)) & = & \max(\adap(\tr_1), \adap(\tr_2)) \\
      %
      \adap(\trprojl(\tr)) & = & \adap(\tr) \\
      %
      \adap(\trprojr(\tr)) & = & \adap(\tr) \\
      %
      \adap(\trtrue) & = & 0 \\
      %
      \adap(\trfalse) & = & 0 \\
      %
      \adap(\trift(\tr_b, \tr_t)) & = & \adap(\tr_b) + \adap(\tr_t) \\
      %
      \adap(\triff(\tr_b, \tr_f)) & = & \adap(\tr_b) + \adap(\tr_f) \\
      %
      \adap(\trconst) & = & 0 \\
      %
      \adap(\trop(\tr)) & = &\wq { 1 + \adap(\tr) } \\
      %
     \adap(\trnil) & = & 0 \\
     %
     \adap(\trcons(\tr_1,\tr_2) ) & = &  \max(\adap(\tr_1),
                                        \adap(\tr_2)) \\
     %
    \adap( \trlet (x, \tr_1,\tr_2) ) & = & \max (\adap(\tr_2),
                                           \adap(\tr_1)+\ddep{x}(\tr_2)  )
                                           \\
     \adap(\triapp{\tr_1}{\tr_2}) & = & \adap(\tr_1) + \adap(\tr_2)\\
    %
     { \adap( (\eilam \expr, \env) ) } & = & 0 \\
     { \adap( \bernoulli (\tr)  ) } & = & \adap(\tr) \\
      { \adap( \uniform  (\tr_1, \tr_2)  ) } & = & \max (\adap(\tr_1),
                                                      \adap(\tr_2) ) \\
     \wq { \adap( \mathsf{VEC}(\tr_i, \tr)  ) } & = & \max (\adap(\tr_i) ) \\
     \wq { \adap( \mathsf{GET}(\tr, \tr')  ) } & = & \adap(\tr) 
      \end{array}
  \end{mathpar}
  %
  \framebox{$\ddep{x}: \mbox{Traces} \to \natb$}
  \begin{mathpar}
    \begin{array}{lcl}
      { \ddep{x}( ( y, \env )) } & = &
      \left\lbrace
      \begin{array}{ll}
        0 & \mbox{if } x = y \\
        \bot & \mbox{if } x \neq y
      \end{array}
      \right.\\
      %
      \ddep{x}(\trapp{\tr_1}{\tr_2}{f}{y}{\tr_3}) & = & \max(\ddep{x}(\tr_1), \\
      & & \adap(\tr_1) + \max(\ddep{x}(\tr_3), \ddep{x}(\tr_2) + \ddep{y}(\tr_3))) \\
      %
      { \ddep{x}(  (\trfix f(y:\type).\expr,\env)  )  }& = & \bot \\
      %
      \ddep{x}((\tr_1, \tr_2)) & = & \max(\ddep{x}(\tr_1), \ddep{x}(\tr_2)) \\
      %
      \ddep{x}(\trprojl(\tr)) & = & \ddep{x}(\tr) \\
      %
      \ddep{x}(\trprojr(\tr)) & = & \ddep{x}(\tr) \\
      %
      \ddep{x}(\trtrue) & = & \bot \\
      %
      \ddep{x}(\trfalse) & = & \bot \\
      %
      \ddep{x}(\trift(\tr_b, \tr_t)) & = & \max(\ddep{x}(\tr_b), \adap(\tr_b) + \ddep{x}(\tr_t)) \\
      %
      \ddep{x}(\trift(\tr_b, \tr_f)) & = & \max(\ddep{x}(\tr_b), \adap(\tr_b) + \ddep{x}(\tr_f)) \\
      %
      \ddep{x}(\trconst) & = & \bot \\
      %
      \ddep{x}(\trop(\tr)) & = & 1 +  \ddep{x}(\tr)  \\  
       %
      \ddep{x}(\trnil) & = & \bot \\
      %
      \ddep{x}(\trcons(\tr_1,\tr_2) ) & = & \max(\ddep{x}(\tr_1),
                                            \ddep{x}(\tr_2)) \\
      %
      \ddep{x}( \trlet(y, \tr_1, \tr_2) ) & = & \max( \ddep{x}(\tr_2),
                                                \ddep{x}(\tr_1)+\ddep{y}(\tr_2)  )\\
       \ddep{x}(\triapp{\tr_1}{\tr_2})  & = & 
                                                    \max(\ddep{x}(\tr_1), \adap(\tr_1) + \ddep{x}(\tr_2))\\
    %
     { \ddep{x}( (\eilam \expr, \env) ) } & = & \bot \\
    \ddep{x}(\uniform (\tr_1,\tr_2) ) & = & \max(\ddep{x}(\tr_1),
                                            \ddep{x}(\tr_2)) \\
  \ddep{x}(\bernoulli (\tr)) & = & \ddep{x}(\tr)
    \end{array}
  \end{mathpar}
  \caption{Adaptivity of a trace and depth of variable $x$ in a trace}
  \label{fig:adap}
\end{figure}


%%%%%%EXAMPLES---TWO ROUNDS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{algorithm}
\caption{A two-round analyst strategy for random data (Algorithm 4 in ...)}
\label{alg:BitGOF}
\begin{algorithmic}
\REQUIRE Mechanism $\mathcal{M}$ with a hidden state $X\in \{-1,+1\}^{n\times (k+1)}$.
\STATE  {\bf for}\ $j\in [k]$\ {\bf do}.  
\STATE \qquad {\bf define} $q_j(x)=x(j)\cdot x(k)$ where $x\in \{-1,+1\}^{k+1}$.
\STATE \qquad {\bf let} $a_j=\mathcal{M}(q_j)$ 
\STATE \qquad \COMMENT{In the line above, $\mathcal{M}$ computes approx. the exp. value  of $q_j$ over $X$. So, $a_j\in [-1,+1]$.}
\STATE {\bf define} $q_{k+1}(x)=\mathrm{sign}\big (\sum_{i\in [k]} x(i)\times\ln\frac{1+a_i}{1-a_i} \big )$ where $x\in \{-1,+1\}^{k+1}$.
\STATE\COMMENT{In the line above,  $\mathrm{sign}(y)=\left \{ \begin{array}{lr} +1 & \mathrm{if}\ y\geq 0\\ -1 &\mathrm{otherwise} \end{array} \right . $.}
\STATE {\bf let} $a_{k+1}=\mathcal{M}(q_{k+1})$
\STATE\COMMENT{In the line above,  $\mathcal{M}$ computes approx. the exp. value  of $q_{k+1}$ over $X$. So, $a_{k+1}\in [-1,+1]$.}
\RETURN $a_{k+1}$.
\ENSURE $a_{k+1}\in [-1,+1]$
\end{algorithmic}
\end{algorithm}


\begin{figure}
\small
Two-rounds:



\[
\begin{array}{l}
\boxed{  \elet e_i = \mathsf{gererated\_ by\_hidden\_dataset} } \ein \\
  \elet \eapp  g: \bot = 
  \efix \eapp f(j: \tint). \lambda k: \tint.\\
  \hspace{.2cm}  \eif \big (  (j < k)  ,  \\
  \hspace{.8cm}  \elet \eapp  a: 0 = 
                 \eop \eapp  
                 (\mathsf{vec}(\expr_i \to (\mathsf{get}\eapp \expr_i \eapp j) * (\mathsf{get} \eapp \expr_i \eapp  k) )) ) 
                  \eapp \ein \\
  \hspace{1.2cm} (a, j) :: (f  \eapp (j+1) \eapp  k) \\
  \hspace{1.2cm} ,\eapp  [] \big) \eapp \ein\\
  \hspace{.2cm}  \efix \eapp \mathsf{twoRound}(k : \tint). 
                 \\
  \hspace{.8cm}  \elet \eapp  l: 1 = g \eapp  0 \eapp  k \eapp bd \eapp  \ein \\
  \hspace{.8cm}  \elet \eapp  q: 1 = \mathsf{vec}\big(\expr_i \to
                    \mathsf{sign} \eapp \\ 
  \hspace{.8cm}  (\mathsf{foldl} \eapp  (\lambda acc: \treal. 
                 \lambda ai: \treal \cdot \tint. 
                 \big(acc\eapp + (\mathsf{get} \eapp \expr_i \eapp  (\eprojr \eapp ai)) 
                 \cdot \mathsf{log}(\frac{1+ (\eprojl \eapp ai) }{1- (\eprojl \eapp ai)}) \big)
                 \eapp  0.0 \eapp  l )\big) \eapp  \ein \\
  \hspace{.8cm}  \eop ( q )
\end{array}
\]
\end{figure}

%%%%%%EXAMPLES--- MULTI ROUNDS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\clearpage
\begin{algorithm}
\footnotesize
\caption{A multi-round analyst strategy for random data (Algorithm 5 in ...)}
\label{alg:multiRound}
\begin{algorithmic}
\REQUIRE Mechanism $\mathcal{M}$ with a hidden state $X_0 \in [N]^{n}$ sampled u.a.r., control set size $c$
\STATE Define control dataset $C = \{0,1, \cdots, c - 1\}$
\STATE Initialize $Nscore(i) = 0$ for $i \in [N]$, $I = \emptyset$ and $Cscore(C(i)) = 0$ for $i \in [c]$
\STATE  {\bf for}\ $j\in [k]$\ {\bf do} 
\STATE \qquad {\bf let} $p=\uniform(0,1)$ 
\STATE \qquad {\bf define} $q (x) = \bernoulli ( p )$ .
\STATE \qquad {\bf define} $qc (x) = \bernoulli ( p )$ .
\STATE \qquad {\bf define} $qj(x) = \mathsf{restrict}(q, X_j)$
\STATE \qquad {\bf let} $a = \mathcal{M}(qj)$ 
\STATE \qquad {\bf for}\ $i \in [N]$\ {\bf do}
\STATE \qquad \qquad $Nscore(i) = Nscore(i) + (a - p)*(q (i) - p)$ if $i \notin I$
\STATE \qquad {\bf for}\ $i \in [c]$\ {\bf do}
\STATE \qquad \qquad $Cscore(C(i)) = Cscore(C(i)) + (a - p)*(qc (i) - p)$
\STATE \qquad {\bf let} $I = \{i | i\in [N] \land Nscore(i) > \max(Cscore)\}$
\STATE \qquad {\bf let} $X_j = X_{j - 1} \setminus I$ 
\RETURN $X_j$.
% \ENSURE 
\end{algorithmic}
\end{algorithm}



\begin{figure}
\small
\[
\begin{array}{l}
\elet \mathsf{updtSC} =\\
                 \efix \eapp  \mathsf{f}(z: \tunit). \lambda sc: \tlist{\treal}. 
                 \lambda a: \treal. \lambda p: \treal. \lambda q.\\
                 \lambda I: \tlist{\tint}. \lambda i: \tint. \lambda n: \tint. \\
 \hspace{.2cm}   \eif \Big ( (i < n)  ,  \\
 \hspace{0.4cm}  \eif \big( ( \mathsf{in} \eapp i \eapp I  ) ,       \\
 \hspace{0.8cm}  \elet \eapp x: 0 =( \mathsf{get} \eapp sc \eapp i) 
                 + (a-p)*(q \{ i\} - p)  \ein \\
 \hspace{0.8cm}  \elet \eapp sc': 0 =  \mathsf{updt} \eapp sc \eapp i
                 \eapp x \ein \\
 \hspace{1.2cm}  \mathsf{f}  \eapp () \eapp sc' \eapp a \eapp p
                 \eapp q \eapp I \eapp  \eapp (i+1) \eapp n  \\ 
 \hspace{0.4cm}  , \mathsf{f}  \eapp () \eapp sc \eapp a \eapp p
                 \eapp q \eapp I \eapp  \eapp (i+1) \eapp n \big )  \\ 
 \hspace{0.2cm}  , sc  \Big ) \eapp \ein
\end{array}
\]
%
%
\[
\begin{array}{l}
\elet \mathsf{updtSCC} = \\
                \efix \eapp  \mathsf{f}(z: \tunit). \lambda scc: \tlist{\treal}. \lambda a: \treal. 
                \lambda p: \treal. \lambda qc\\ 
                \lambda i: \tint. \lambda cr: \tint. \\
 \hspace{.2cm}  \eif \Big ( (i < cr) ,  \\
 \hspace{0.8cm} \elet \eapp x: 0 =( \mathsf{nth} \eapp scc \eapp i) 
                + (a-p)*(qc \{ i\} - p)  \ein \\
 \hspace{0.8cm} \elet \eapp scc': 0 =  \mathsf{updt} \eapp scc \eapp i
                \eapp x \ein \\
 \hspace{1.2cm} \mathsf{f}  \eapp () \eapp scc' \eapp a \eapp p \eapp qc
                \eapp (i+1) \eapp  cr  \\ 
 \hspace{0.2cm} , scc  \Big ) \eapp \ein
\end{array}
\]
%
%
\[
\begin{array}{l}
\elet \mathsf{updtI} = \\
                 \efix \eapp  \mathsf{f}(z : \tunit). \lambda maxScc: \treal. 
                 \lambda sc: \tlist{\treal}. \lambda i: \tint. \lambda n: \tint. \\
 \hspace{.2cm}   \eif \Big (   (i < n)  ,  \\
 \hspace{0.4cm}  \eif \big( ( ( \mathsf{nth} \eapp scc \eapp i)  >  maxScc  ) ,       \\
 \hspace{0.8cm}  i :: ( \mathsf{f}  \eapp () \eapp maxScc \eapp sc
                 \eapp (i+1) \eapp n  )\\
 \hspace{0.8cm}  \mathsf{f}  \eapp () \eapp maxScc \eapp sc
                 \eapp (i+1) \eapp n  \big )  \\
 \hspace{0.2cm}  , [] \Big ) \eapp \ein
\end{array}
\]
%
%
\[
\begin{array}{l}
 \efix \eapp  \mathsf{multiRound}(z : \tunit). \Lambda k. \Lambda j. 
        \lambda k: \tint[k]. \lambda j: \tint[j]. \lambda sc: \tlist{\treal}.\\
        \lambda scc: \tlist{\treal}. \lambda il: \tlist{\tint}. \lambda n: \tint.
        \lambda cr: \tint. \lambda d: \tlist{\tint}.\\
 \hspace{.2cm}  \eif   \big (   (j < k)  ,  \\
 \hspace{.2cm}  \elet \eapp p: k - j = \uniform \eapp 0 \eapp 1 \ein \\
 \hspace{0.4cm} \elet \eapp q: k - j = 
   \mathsf{vec}(\expr_i \to \bernoulli \eapp p,n) \ein \\
 \hspace{0.4cm} \elet \eapp qc: k - j = \mathsf{vec}(\expr_i \to \bernoulli \eapp p,n) \ein \\
 \hspace{0.4cm} \elet \eapp qj : k - j = \mathsf{vec}( e_i \to if( (\mathsf{in}\eapp d \eapp e_i) \, , \, q\{e_i\} \,, \mathsf{else} 0, n) )\\
 \hspace{0.4cm} \elet \eapp a: k - j - 1 = \eop (q)  \ein \\
 \hspace{0.8cm} \elet \eapp sc': k - j - 1 =  \mathsf{updtSC} \eapp () \eapp sc  \eapp a \eapp p
                \eapp qj \eapp il \eapp  \eapp 0 \eapp  n \eapp  \ein \\
 \hspace{0.8cm} \elet \eapp scc': k - j - 1 =  \mathsf{updtSCC} \eapp () \eapp scc \eapp a \eapp p
                \eapp qc \eapp  \eapp 0 \eapp  cr \ein \\
 \hspace{0.8cm} \elet \eapp maxScc: k - j - 1 =  \mathsf{foldl} \eapp 
                (\lambda acc : \treal. \lambda a: \treal. 
                \eif ( acc < a, a, acc)) \eapp 0 \eapp scc' \ein \\
 \hspace{0.8cm} \elet \eapp il': k - j - 1 =  \mathsf{updtI}  \eapp () \eapp maxScc \eapp sc
                \eapp 0 \eapp n  \ein \\
 \hspace{0.8cm} \elet \eapp d': k - j - 1 =  d \setminus il' \ein \\
 \hspace{1.2cm} a :: (\mathsf{multiRound} \eapp () \eapp [k] \eapp [j + 1]  
                 \eapp k \eapp (j+1) \eapp sc' \eapp scc' \eapp il'
                 \eapp n \eapp cr \eapp d')\\ 
 \hspace{0.2cm} , []  \big)
\end{array}
\]

\end{figure}


% \begin{figure}
% \[
% \begin{array}{l}
% q=\mathsf{vec}( 0 -> p_0,\\
%              1 -> p_1,\\
%              ...\\
%              N -> p_N\\
%              )\\
% qj = restrict q d\\
% \mathsf{vec}( e_0 -> if e_0 in d then q(e_0) else 0,
%              1 -> if e_0 in d then q(e_1) else 0,
%              ...
%              N -> if e_0 in d then q(e_N) else 0
%              )
% \end{array}
% \]
% \end{figure}
