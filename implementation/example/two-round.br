let g : index 1 = 
fix round (j: int). lambda db:int list list. lambda k : int.
	if((j < k), 
	let a: index 1 = mech (lambda x: int list. (get x j) * (get x k)) 
	in
	(a,j)::(round (j + 1) db k)
	, nil)
in
fix twoRound(k:int). lambda db:int list list. 
 let l : index 1 = g 0 db k
	in let q: index 1 = lambda x: int list. sign(foldl (lambda acc: real. lambda (a,i) : real X int list. (acc + (get x i) * log( (1 + a)/ (1 - a) ) ) ) 0 l  )
		in mech(q)



|- real