let updtSC = fix f (z). lambda sc. lambda a. lambda p. lambda q. lambda I. lambda i. lambda N.
	if	(	(i < N),
			if( (contains I i),
				let x = (nth sc i) + (a - p) * (q i - p) in
					let sc' = updt sc i x in
						f () sc' a p q I (i + 1) N,
				f () sc a p q I (i + 1) N),
			sc
		)
in
let updtSCC = fix f (z). lambda scc. lambda a. lambda p. lambda qc. lambda i. lambda C.
	if	(	(i < C),
			let x = (nth scc i) + (a - p) * (qc i - p) in
				let scc' = updt scc i x in
					f () scc' a p qc (i + 1) C,
			scc
		)
in

let updtI = fix f (z). lambda maxSCC. lambda sc. lambda i. lambda N.
	if(	(i < N),
		if(	((nth scc i) < maxScc),
			i :: (f () maxScc sc (i + 1) N),
			f () maxScc sc (i + 1) N),
		nil
		)

in 

fix f (z). Lambda. Lambda. lambda k. lambda j. lambda sc. lambda scc. lambda I. lambda N. lambda C. lambda D.
	if(	(j < k),
		let p = uniform(0, 1) in
		let q = lambda x. bernoulli p in
		let qc = lambda x. bernoulli p in
		let a = mech(q) in 
		let sc' = updtSC () sc a p q I 0 N in
		let scc' = updtSCC () scc a p qc 0 C in
		let maxScc = foldl (lambda acc. lambda a. if(acc < a, a, acc)) 0 scc' in
		let I' = updtI () maxScc sc 0 N in 
		let D' = D \ I' in
			f () [] [] k (j + 1) sc' scc' I' N C D' ,
		D)


|> forall k:::adapt. forall j:::adapt. int[index k] -> int[index j] -> real list -> real list -> int list -> int -> int -> int list, 0 -> ( dmap (sc:0) (scc : 0) (I : 0) (N : 0) ; index k - index j) int list


