let updtSC = fix f (z). lambda sc. lambda a. lambda p. lambda q. lambda ii. lambda i. lambda nn.
	if	(	(i < nn),
			if( (contains ii  i),
				let x = (get sc i) + (a - p) * ((q i) - p) in
					let sc' = updt sc i x in
						f () sc' a p q ii (i + 1) nn,
				f () sc a p q ii (i + 1) nn),
			sc
		)
in
let updtSCC = fix f (z). lambda scc. lambda a. lambda p. lambda qc. lambda i. lambda cc.
	if	(	(i < cc),
			let x = (get scc i) + (a - p) * ((qc i) - p) in
				let scc' = updt scc i x in
					f () scc' a p qc (i + 1) cc,
			scc
		)
in

let updtI = fix f (z). lambda maxScc. lambda sc. lambda i. lambda nn.
	if(	(i < nn),
		if(	((get sc i) < maxScc),
			i :: (f () maxScc sc (i + 1) nn),
			f () maxScc sc (i + 1) nn),
		nil
		)

in 

fix multiRound (z). Lambda. Lambda. lambda k. lambda j. lambda sc. lambda scc. lambda ii. lambda nn. lambda cc. lambda db.
	if(	(j < k),
		let p = uniform(0, 1) in
		let q = lambda x. bernoulli p in
		let qc = lambda x. bernoulli p in
		let qj = restrict q db in
		let a = mech(qj) in 
		let sc' = updtSC () sc a p q ii 0 nn in
		let scc' = updtSCC () scc a p qc 0 cc in
		let maxScc = foldl (lambda acc. lambda a. if(acc < a, a, acc)) 0 scc' in
		let ii' = updtI () maxScc sc 0 nn in 
		let db' = db \ ii' in
			a::(multiRound () [] [] k (j + 1) sc' scc' ii' nn cc db') ,
		nil)


|- forall k:::adapt. forall j:::adapt. int[index k] -> int[index j] -> real list -> real list -> int list -> int -> int -> int list, 0 -> ( dmap (sc:0) (scc : 0) (I : 0) (N : 0) ; index k - index j) int list


