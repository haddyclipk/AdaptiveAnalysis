fix f (z). Lambda. Lambda. lambda k. lambda j. lambda sc. lambda scc. lambda I. lambda N. lambda C. lambda D. 
	if(	(j < k),
		let p = uniform(0, 1) in 
		let q = lambda x. bernoulli p in
		let qc = lambda x. bernoulli p in
		let a = mech(q) in 
		let sc' = updtSC () sc a p q I 0 N in
		let scc' = updtSCC () scc a p qc 0 C in
		let maxScc = foldl (lambda acc. lambda a. if(acc < a, a, acc)) 0 scc' in
		let I' = updtI () maxScc sc 0 N in 
		let D' = D \ I' in
			multiRound () [] [] k (j + 1) sc' scc' I' N C D' ,
		D)

|>  forall k:::adapt. forall j:::adapt. int[index k] -> int[index j]-> real list -> real list -> int list -> int -> int -> int list,0 -> ( dmap (sc:0) ; index k - index j) int list